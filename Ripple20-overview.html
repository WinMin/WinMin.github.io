<!DOCTYPE html>
<html lang="EN">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>关于 CVE-2020-11896和CVE-2020-11898 的学习笔记 | Swing&#39;Blog 浮生若梦</title>


<meta name="description" content="Know it then hack it!">


<meta name="author" content="Swing">



<!-- Canonical -->
<link rel="canonical" href="/Ripple20-overview.html">

<!-- Favicon -->
<link rel="icon" href="/images/favicon.ico">

<!-- RSS -->

<link rel="alternate" type="application/rss+xml" title="Swing&#39;Blog 浮生若梦" href="/atom.xml">


<!-- Open Graph -->
<meta property="og:type" content="article">
<meta property="og:title" content="关于 CVE-2020-11896和CVE-2020-11898 的学习笔记">
<meta property="og:url" content="/Ripple20-overview.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">

<meta property="og:description" content="Know it then hack it!">


<!-- Twitter Card -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于 CVE-2020-11896和CVE-2020-11898 的学习笔记">

<meta name="twitter:description" content="Know it then hack it!">


<!-- Theme Color -->
<meta name="theme-color" content="#1d1f21">
<meta name="msapplication-TileColor" content="#1d1f21">

<!-- Stylesheets -->

<link rel="stylesheet" href="/css/style.css">


<!-- Custom Layout Variables -->

<style>
:root {
  --page-width: 60rem;
  --content-width: 1200px;
  --mobile-padding: 12px;
}
</style>

<!-- Analytics -->


<meta name="generator" content="Hexo 5.4.2"></head>
<body class="theme-dark">
  <div class="container">
    <header class="header">
  <div class="header-inner">
    <div class="header-brand">
      
        <a href="/" class="logo">
          <img src="/images/logo.png"
               width="50"
               height="50"
               alt="Swing&#39;Blog 浮生若梦">
        </a>
      
      <a href="/" class="site-title">
        Swing&#39;Blog 浮生若梦
      </a>
    </div>

    <nav class="nav">
      <button class="nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
        <span class="nav-toggle-bar"></span>
        <span class="nav-toggle-bar"></span>
        <span class="nav-toggle-bar"></span>
      </button>

      <ul class="nav-menu" id="nav-menu">
        
          
          
            
            <li class="nav-item">
              <a href="/"
                 class="nav-link"
                 >
                Home
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/about/"
                 class="nav-link"
                 >
                About
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/archives/"
                 class="nav-link"
                 >
                Articles
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/atom.xml"
                 class="nav-link"
                 >
                RSS
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/categories/"
                 class="nav-link"
                 >
                Categories
              </a>
            </li>
            
              <li class="nav-divider">|</li>
            
          
            
            <li class="nav-item">
              <a href="/link"
                 class="nav-link"
                 >
                Links
              </a>
            </li>
            
          
        
      </ul>
    </nav>
  </div>
</header>


    <main class="main">
      
        <div class="page-layout">
          <article class="post">
  <header class="post-header">
  <h1 class="post-title">关于 CVE-2020-11896和CVE-2020-11898 的学习笔记</h1>

  <div class="post-meta">
    <span class="meta-item">
      <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11zM9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/></svg>
      <time datetime="2020-06-30">
        2020-06-30
      </time>
    </span>

    
      <span class="meta-item">
        <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79s7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58s9.14-3.47 12.65 0L21 3v7.12z"/></svg>
        <time datetime="2020-07-02">
          Updated on 2020-07-02
        </time>
      </span>
    

    
      <span class="meta-item">
        <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>
        
          <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>
        
      </span>
    
  </div>
</header>


  
    <nav class="toc">
  <h3 class="toc-title">Table of Contents</h3>
  <div class="toc-list">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CVE-2020-11896"><span class="toc-text">CVE-2020-11896</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4-%E5%88%86%E7%89%87"><span class="toc-text">IPv4 分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E9%9A%A7%E9%81%93"><span class="toc-text">IP 隧道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP-in-IP"><span class="toc-text">IP-in-IP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Treck-TCP-IP"><span class="toc-text">Treck TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E5%9B%A0"><span class="toc-text">漏洞原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8IP%E5%B1%82%E5%A4%84%E7%90%86%E5%88%86%E6%AE%B5%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-text">在IP层处理分段数据包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8UDP%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-text">利用UDP实现堆溢出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CVE-2020-11898"><span class="toc-text">CVE-2020-11898</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-treck-%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%89%AB%E6%8F%8F"><span class="toc-text">关于 treck 协议栈扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
  </div>
</nav>

  

  <div class="post-content">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>学习了一下这 ripper 20的两个洞</p>
<h2 id="CVE-2020-11896"><a href="#CVE-2020-11896" class="headerlink" title="CVE-2020-11896"></a>CVE-2020-11896</h2><h3 id="IPv4-分片"><a href="#IPv4-分片" class="headerlink" title="IPv4 分片"></a>IPv4 分片</h3><p>IP分片使得即使在IP分组的大小大于网络的特定链路中允许的最大大小的情况下，也可以在网络中发送IP分组。IP分段是一种将分组分成几个较小部分(“片段”)以支持在这些链路和网络上传输的技术。该协议支持TH分组的分段然后重组。</p>
<p>使用IP报头中的标识字段将不同的片段分组。该标识字段描述片段属于哪个分组。这允许不同的数据包在网络中分段传输，并在另一端正确重组。最后一个片段的MF(更多片段)位标志设置为0，而所有其他片段的MF=1。</p>
<p>网络堆栈负责对大型数据包进行分段，并通过网络发送多个分段。请求发送大型数据报的UDP应用程序就是一个例子。网络堆栈还负责在接收到分段的数据包时对其进行重组。</p>
<p>如果只有部分数据包碎片到达，网络堆栈最终会丢弃这些碎片。在大多数实现中，当处理任何片段时，网络堆栈启动计时器。当该计时器到期时，网络堆栈丢弃属于同一标识组的所有片段。</p>
<p>IPv4通过Flags及Fragment Offset字段对分片进行管理，Flags由R、DF、MF三部分组成：</p>
<p>● R（Reserve bit）保留未用</p>
<p>● DF (Don’t Fragment) DF =1：禁止分片 , DF =0：允许分片</p>
<p>● MF (More Fragment) MF =1：非最后一片, MF =0：最后一片(或未分片)</p>
<p>Fragment Offset(13位)：一个IP分组分片封装原IP分组数据的相对偏移量, 片偏移字段以8字节为单位。IP包结构如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>



<h3 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h3><p>IP隧道允许两个独立网络之间的虚拟点对点链路。它是通过将一个数据包(可以是IP数据包)封装在另一个数据包中来实现的，从而使内部数据包具有与外部数据包不同的源地址和目的地址。</p>
<p>外部数据包的源地址和目的地址是隧道端点，内部数据包中的地址用于隧道两端的网络路由。<br>隧道入口点是接收应该通过隧道转发的IP分组的节点。它将此数据包封装在外部IP数据包中。当数据包到达隧道出口点时，会将其解封并转发，就好像它是在目标网络中发送的常规数据包一样。<br>隧道使用的一个主要示例是虚拟专用网(VPN)技术。<br>有几种隧道协议，最简单、最古老的协议之一是IP-in-IP(IP协议号4)。</p>
<h4 id="IP-in-IP"><a href="#IP-in-IP" class="headerlink" title="IP-in-IP"></a>IP-in-IP</h4><p>IP-in-IP是一种IP隧道协议，在该协议中，通过添加具有分别等于隧道入口点和出口点的源地址和目的地址的外部IP报头，将一个IP数据包封装在另一个IP数据包中。<br>内部数据包未修改，外部IP报头从内部IP报头复制一些字段。外部标头的IP协议号为4。</p>
<h3 id="Treck-TCP-IP"><a href="#Treck-TCP-IP" class="headerlink" title="Treck TCP/IP"></a>Treck TCP/IP</h3><p>在 Treck TCP/IP 中，有个结构体用来描述其 TCP/IP栈，称为tsPacket。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsPacket</span> &#123;</span></span><br><span class="line">ttUserPacket pktUserStruct;</span><br><span class="line">ttSharedDataPtr pktSharedDataPtr; <span class="comment">// Point to corresponding sharable ttSharedData struct tsPacket * pktChainNextPtr; // Next packet (head of a new datagram in a queue) struct tsDeviceEntry * pktDeviceEntryPtr; // pointer to network Device struct</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">anon_union_for_pktPtrUnion</span> <span class="title">pktPtrUnion</span>;</span> tt32Bit pktTcpXmitTime;</span><br><span class="line">tt16Bit pktUserFlags; tt16Bit pktFlags; tt16Bit pktFlags2;</span><br><span class="line">tt16Bit pktMhomeIndex;</span><br><span class="line">tt8Bit pktTunnelCount; <span class="comment">// Number of times this packet has been decapsulated. Initially set</span></span><br><span class="line">tt8Bit pktIpHdrLen; <span class="comment">// Number of bytes occupied by the IP header.</span></span><br><span class="line">tt8Bit pktNetworkLayer; <span class="comment">// Specifies the network layer type of this packet (IPv4, IPv6,</span></span><br><span class="line">‹→ ARP, etc).</span><br><span class="line">tt8Bit pktFiller[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是包含的ttUserPacket 结构（tsUserPacket的typedef ）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsUserPacket</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> * pktuLinkNextPtr; <span class="comment">// Next tsUserPacket for fragmented data</span></span><br><span class="line">ttUser8BitPtr pktuLinkDataPtr; <span class="comment">// Pointer to data</span></span><br><span class="line">ttPktLen pktuLinkDataLength; <span class="comment">// Size of data pointed by pktuLinkDataPtr</span></span><br><span class="line">ttPktLen pktuChainDataLength; <span class="comment">// Total packet length (of chained fragmented data). Valid</span></span><br><span class="line">‹→ in first link only.</span><br><span class="line"><span class="keyword">int</span> pktuLinkExtraCount; <span class="comment">// Number of links linked to this one (not including this one).</span></span><br><span class="line">‹→ Valid in first link only.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>pktuLinkDataPtr 指向当前片段的数据缓冲区。随着网络堆栈在不同阶段处理数据包并取决于当前正在处理的数据包层 ，此数据缓冲区内的确切位置会发生变化。 对于 例如，当网络栈处理所述以太网层（在tfEtherRecv ），该字段指向以太网报头。</p>
<p>pktuLinkDataLength字段指定pktuLinkDataPtr指向的数据的大小，即单个片段的大小。<br>pktuLinkNextPtr用于跟踪数据包中的片段。此字段指向表示下一个片段的另一个tsPacket，该片段又包含对下一个片段的引用，依此类推。因此，我们也可以在此链表中将片段称为“链接”。如果此链接是最后一个片段，或者如果数据未分段，则此字段将等于NULL。<br>pktuChainDataLength字段表示包括所有片段的分组长度，即分组的总大小。它只为第一个片段设置，如果数据没有分段，则等于pktuLinkDataLength。</p>
<p>堆栈中的一种常见模式是在堆栈中的各层之间移动时调整pktuLinkDataPtr指针。例如，如果我们的数据包是ICMP回应请求数据包(PING)，则它将由三层组成：以太网，然后是IPv4，最后是ICMP。在这种情况下，当以太网层被处理时(在函数tfEtherRecv中)，pktuLinkDataPtr指向以太网头的开始，然后在移动到下一层之前，使用以下代码对其进行调整：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkt-&gt;pktuLinkDataPtr = pkt-&gt;pktuLinkDataPtr + <span class="number">0xe</span>;</span><br><span class="line">pkt-&gt;pktuLinkDataLength = pkt-&gt;pktuLinkDataLength - <span class="number">0xe</span>; </span><br><span class="line">pkt-&gt;pktuChainDataLength = pkt-&gt;pktuChainDataLength - <span class="number">0xe</span>;</span><br></pre></td></tr></table></figure>



<p>在本例中，0xE(十进制14)是以太网头的大小(6(Dst MAC)+6(Src MAC)+2(EtherType))。<br>当tfEtherRecv完成数据包处理时，它会使用代表下一层协议的EtherType字段将数据包转发到下一层处理。遇到的支持的以太网类型有ARP、IPv4和IPv6。</p>
<a href="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" title="img" class="gallery-item"><img src="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" alt="img" style="zoom:50%;" /></a>

<p>在此的示例中，当IPv4层接收到数据包(在函数tfIpIncomingPacket中)时，指针pktuLinkDataPtr已经指向以太网头，因此可以安全地假设pktuLinkDataPtr指向的数据是IPv4头。<br>传入的数据由具有相同命名约定TF<em>IncomingPacket的函数处理(正如我们已经看到的)，其中</em>是协议名称。在以太网/IPv4/ICMP的情况下，包将由函数tfEtherRecv、tfIpIncomingPacket处理。<br>和tfIcmpIncomingPacket。<br>Treck堆栈处理从tfIpIncomingPacket调用的过程tfIpReAssemblePacket中的片段重组。每当接收到发往设备的IP片段时，都会调用此过程。如果缺少片段，则函数返回NULL。否则，如果所有片段都到达并且没有漏洞，则网络堆栈使用pktuLinkNextPtr字段将片段链接在一起，并传递数据包以供下一层进一步处理。在此上下文中的单词“重组”并不意味着将分组复制到连续的存储块，而是简单地将它们链接在一个链表中。</p>
<h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>为了了解漏洞的根本原因，我们将快速查看IP标头中的两个字段：</p>
<p><em>•</em> IHL （4个比特）：该尺寸的所述IP 报头中的双字。最低值是5 （20 个字节）。如果有IP选项，头长度变大，最多值的0xf（60个字节）。  </p>
<p><em>•</em> 总长度（2个字节）：整个IP数据包的大小，以字节（或IP片段，如果是分段的）为单位，包括报头。  </p>
<p>函数tfIpIncomingPacket 从一些基本的健全性检查开始。除了验证标头校验和之外，它还验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip_version &#x3D;&#x3D; 4 &amp;&amp; data_available &gt;&#x3D; 21 &amp;&amp; header_length &gt;&#x3D; 20 &amp;&amp; total_length &gt; header_length &amp;&amp; total_length &lt;&#x3D; data_available</span><br></pre></td></tr></table></figure>

<p>“可用数据”是使用字段pktuChainDataLength测量的。<br>如果所有健全性检查都通过，该函数将检查IP报头中指定的总长度是否严格小于数据包的pktuChainDataLength，表明实际接收的数据多于IP报头中所述的数据。如果为真，则执行修剪操作以删除额外数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((uint)ipTotalLength &lt;= pkt-&gt;pktuChainDataLength) &#123; <span class="keyword">if</span> ((uint)ipTotalLength != pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">	pkt-&gt;pktuChainDataLength = (uint)ipTotalLength; </span><br><span class="line">	pkt-&gt;pktuLinkDataLength = (uint)ipTotalLength;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是漏洞所在。回想一下，pktuLinkDataLength保存当前片段的大小，pktuChainDataLength保存整个数据包的大小。如果执行上述操作，则会创建不一致，其中pkt-&gt;pktuChainDataLength。<br>==pkt-&gt;pktuLinkDataLength，但可能有其他片段指向。<br>pkt-&gt;pktuLinkNextPtr.。另一种方式是将其视为一种虚构的不一致状态，其中链表上片段的总大小大于pktuChainDataLength中存储的大小。<br>由弱修剪操作产生的不一致对于处理的其余部分来说不是好兆头。然而，我们还有另一个挑战需要克服。每次使用一个接收到的片段调用tfIpIncomingPacket函数，并调用tfIpReAssemblePacket来处理它。tfIpReAssemblePacket负责将片段插入到上述链表中。它不会将片段复制到连续的内存缓冲区。收到所有片段后，tfIpReAssemblePacket以片段链接列表的形式返回完整的数据包，以便在下一个协议层进行进一步处理。该重组操作在易受攻击的修剪操作之后执行。一旦可靠的操作完成，tfIpIncomingPacket将返回或转发数据包，以便在下一网络层(例如：UDP)进行处理。这会阻止我们执行利用漏洞攻击，因为我们需要分段的数据包才能达到不一致的状态。换句话说，易受攻击的代码应该只在每个片段的基础上执行(或在单个片段的数据包上执行)。如果以这种方式执行，它实际上并不容易受到攻击。<br>那么，我们如何才能用传入的碎片数据触发易受攻击的修剪流，从而实现上述不一致呢？</p>
<h4 id="在IP层处理分段数据包"><a href="#在IP层处理分段数据包" class="headerlink" title="在IP层处理分段数据包"></a>在IP层处理分段数据包</h4><p>为了使分段的数据包在IP层得到处理并到达易受攻击的流，我们使用隧道。<br>隧道允许tfIpIncomingPacket将内部IP数据包作为非分段数据包进行处理。函数tfIpIncomingPacket将被递归调用两次，一次用于IP隧道的内层，多次用于外层(每个片段一次)。首先，tfIpIncomingPacket将接收来自外层的所有片段，在每个片段上调用tfIpReAssemblePacket，一旦它们都被接收，它将把执行传递到下一个协议层，在本例中再次是IPv4，因此将从具有内部IP层的tfIpIncomingPacket调用tfIpIncomingPacket。</p>
<p><a href="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" title="img" class="gallery-item"><img src="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" alt="img"></a></p>
<p>对外部IP分组进行分段会导致使用内部分组调用tfIpIncomingPacket，该内部分组现在由几个分段组成，但在IP报头中标记为未分段(MF=0)。就描述数据包的数据结构而言，它现在由链接列表中的几个单独的链接组成，每个链接都有一个单独的pktuLinkDataLength值。</p>
<p>让我们说得更具体些。请考虑下面的示例，它将伴随我们完成本文：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" title="image-20200630192655708" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" alt="image-20200630192655708"></a></p>
<p>(我们将 checksum 字段设置为0，因为这将导致跳过UDP校验和验证。)。<br>当网络堆栈处理外部片段时，它使用字段将它们链接起来。<br>如前所述，tsUserPacket结构中的pktuLinkNextPtr。当函数tfIpIncomingPacket处理内部IP包(由于协议=4)时，它正在处理传入的分片数据(内部IP包由两个链接在一起的tsPacket结构表示)，但仍会调用易受攻击的流，从而解决了我们的挑战。<br>此外，内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。在我们的示例中，内部IP数据包(32)的总长度较小。<br>超过链数据长度(1000+8+20=1028)，因此Treck堆栈将通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值-总IP长度(在我们的示例中为32)，来尝试不正确地修剪数据包。这导致内部IP分组由链接在一起的两个tsPacket结构表示，但是它们的总CUSIZE大于pktuChainDataLength字段(pktuChainDataLength字段在修整后等于32，而不是1028字节)。</p>
<p><a href="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" title="img" class="gallery-item"><img src="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" alt="img"></a></p>
<h4 id="利用UDP实现堆溢出"><a href="#利用UDP实现堆溢出" class="headerlink" title="利用UDP实现堆溢出"></a>利用UDP实现堆溢出</h4><p>既然我们已经达到了不一致的状态，我们就面临着另一个问题–我们如何利用这种不一致来获得内存损坏原语？<br>原来，至少有一条代码路径将碎片数据复制到单个连续缓冲区中。这是处理UDP数据报的代码的一部分。该流的内部逻辑由正在分配的新分组(使用tfGetSharedBuffer)组成，其大小基于pktuChainDataLength字段，随后是分组的不同片段的副本逐个进入新分配的分组。<br>负责执行复制的函数是tfCopyPacket，它按顺序接受源包和目的包。以下是片段复制代码的摘录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(dst-&gt;pktuLinkDataPtr + i,src-&gt;pktuLinkDataPtr,src-&gt;pktuLinkDataLength); i = i + src-&gt;pktuLinkDataLength;</span><br><span class="line">src = (tsPacket *)src-&gt;pktuLinkNextPtr;</span><br><span class="line">&#125; <span class="keyword">while</span> (src != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>如您所见，函数tfCopyPacket没有考虑它写入的缓冲区的长度。它只是从src包(我们的分段包)中提取每个链接，并将其数据复制到目标包中。目标数据包是根据pktuChainDataLength分配的，因此如果之前触发了该漏洞，则在我们的无效之后，分配的缓冲区可能小于数据包中所有单个链接的总和-因此，会发生堆溢出。</p>
<p>还有一件事需要描述，那就是我们如何触发这一流程。</p>
<p>如果应用程序正在侦听任何UDP端口，则发往该端口的UDP数据包将被传递给套接字处理函数tfSocketIncomingPacket。其任务是将数据包附加到套接字接收队列(稍后由应用层轮询)。</p>
<p>在我们的研究中，我们发现当UDP数据包的套接字接收队列非空并且有新的数据包到达时，上述包含堆溢出的流是可以实现的。请看tfSocketIncomingPacket的以下摘录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ocal_10 = pkt;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (sockEntry-&gt;socReceiveQueueNextPtr == <span class="literal">NULL</span>) &#123; sockEntry-&gt;socReceiveQueueNextPtr = pkt; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">queueLastPtr = sockEntry-&gt;socReceiveQueueLastPtr;</span><br><span class="line"><span class="keyword">if</span> ((queueLastPtr-&gt;pktSharedDataPtr-&gt;dataFlags &amp; <span class="number">0x40</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Shared data doesn&#x27;t point to user device memory */</span></span><br><span class="line">sizeOfPacketBuffer = (uint)(pkt-&gt;pktSharedDataPtr-&gt;dataBufLastPtr +</span><br><span class="line">‹→ -(<span class="keyword">int</span>)pkt-&gt;pktSharedDataPtr-&gt;dataBufFirstPtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (protoNum == <span class="number">6</span>) &#123;</span><br><span class="line"><span class="comment">/* Related to TCP; redacted for brevity */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sizeOfPacketBuffer != <span class="number">0</span>) &#123;</span><br><span class="line">uVar2 = (uint)sockEntry-&gt;socRecvCopyFraction * pkt-&gt;pktuChainDataLength; <span class="keyword">if</span> (uVar2 &lt;= sizeOfPacketBuffer) &#123;</span><br><span class="line">dst = tfGetSharedBuffer(<span class="number">0x54</span>,pkt-&gt;pktuChainDataLength,<span class="number">0</span>); <span class="keyword">if</span> (dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">tfCopyPacket(pkt,dst); needToDrop = <span class="literal">true</span>; local_10 = dst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queueLastPtr-&gt;pktChainNextPtr = local_10; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看到，为了到达tfGetSharedBuffer，我们需要绕过涉及到ocRecvCopyFraction的检查。我们不知道它的确切用途，但通过调试和实验，我们发现它的值是4(在我们的情况下)。</p>
<p>在我们反复出现的示例中，我们的第一个数据包链路的缓冲区大小很小，因此SizzeOfPacketBuffer。<br>相对较小(大约10s字节)。<br>但是当我们到达该流时，pkt-&gt;pktuChainDataLength等于4(修剪后为32，然后在处理IP层时递减20(IP报头的大小)，然后再次递减8(UDP报头的大小))。因此，4*4=16小于sizeOfPacketBuffer，我们通过此检查。<br>我们需要确保的最后一件事是UDP数据包的接收队列是非空的(否则无法到达此流)。在理论上，有几种方法可以做到这一点。在我们的攻击中，我们发现将多个UDP数据包足够快地发送到同一端口就可以做到这一点。然而，要让这一部分可靠地工作是很棘手的。该漏洞是用Python编写的，使用的Scapy对于我们的目的来说太慢了。为了克服这个障碍，我们使用了Scapy的L3Socket对象，并实例化了一堆线程，这些线程只会用良性的UDP数据包淹没设备，因此套接字接收队列将是非空的。用C或GO编写代码可能也可以。根据要利用的设备和侦听服务器，可以对此部分进行其他改进。<br>另一个障碍是，在我们到达发生溢出的tfSocketIncomingPacket之前，易受攻击的数据包通过tfUdpIncomingPacket。此函数包含一些与UDP相关的健全性检查，因此我们还需要通过这些检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">udpLen &#x3D; udpHdr-&gt;udpLength &gt;&gt; 8 | udpHdr-&gt;udpLength &lt;&lt; 8;</span><br><span class="line">if ((udpLen &lt; 8) || (*(ushort  *)&amp;pkt-&gt;pktuChainDataLength  &lt;  udpLen))  goto  dropPacket; if (udpLen &lt; *(ushort *)&amp;pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">tfPacketTailTrim(pkt,(uint)udpLen,0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* ... *&#x2F;</span><br><span class="line">if ((udpHdr-&gt;udpChecksum !&#x3D; 0) &amp;&amp; (tvUdpIncomingChecksumOn !&#x3D; 0)) &#123;</span><br><span class="line">&#x2F;* Compute checksum... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，通过确保UDP长度字段等于pktuChainDataLength字段减去内部IP报头的大小，我们可以避免这种类型的修剪(不要与易受攻击的流混淆)。<br>总而言之：如果我们的设备上有UDP端口在监听，我们可以快速发送数据包，这样套接字接收队列就不会为空。同时，我们将发送会触发该漏洞的零碎UDP数据包，并勾选几个复选框。我们预期的结果是使用tfGetSharedBuffer在堆上分配一个小缓冲区，然后tfCopyPacket会使其溢出。</p>
<h2 id="CVE-2020-11898"><a href="#CVE-2020-11898" class="headerlink" title="CVE-2020-11898"></a>CVE-2020-11898</h2><p>前面提到了，Treck TCP/IP不能正确处理IP-in-IP隧道上传入的IPv4片段。这还可能允许未经验证的攻击者从 heap 中泄漏内存。</p>
<p>如果 tfIcmpErrPacket 将越界数据复制到错误数据包中，则可作为信息泄漏漏洞来被利用。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" title="image-20200630213501855" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" alt="image-20200630213501855"></a></p>
<p>参考如上实例：</p>
<p>当网络堆栈接收到这两个片段时，它会使用tfIpReAssemblePacket重新组装它们。此函数使用tsUserPacket结构中的字段pktuLinkNextPtr链接两个片段。如果启用了隧道，则IP层接下来将在函数tfIpIncomingPacket中处理内部IP数据包。</p>
<p>内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。此外，由于在标准IP报头(20字节)之后有4个空字节，并且空字节表示选项列表的末尾(见<a href="https://tools.ietf.org/html/rfc791)%EF%BC%8C%E5%9B%A0%E6%AD%A4IP%E9%80%89%E9%A1%B9%E8%A7%A3%E6%9E%90%E9%80%9A%E8%BF%87%E3%80%82">https://tools.ietf.org/html/rfc791)，因此IP选项解析通过。</a></p>
<p>如果内部IP数据包的IP报头中的总长度字段严格小于链数据长度，则网络堆栈将尝试修剪数据包。如前文中所述，修剪是通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值，即总长度字段(在我们的示例中为100)来实现的。</p>
<p>由于内部IP数据包包含无效的IPv4协议号(协议0)，因此网络堆栈将通过发送类型为3(目的地不可达)代码为2(协议不可达)的ICMP错误消息来拒绝该数据包。</p>
<p>负责创建错误数据包的函数是tfIcmpErrPacket。它会分配一个新数据包，初始化一些ICMP字段，并最终从违规数据包(内部IP数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length   =   (packetPtr-&gt;pktUserStruct).pktuLinkDataLength; <span class="keyword">if</span> (headerLengthInBytes + <span class="number">8</span> &lt;= length) &#123;</span><br><span class="line">length = headerLengthInBytes + <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(icmpErrHdrPtr + <span class="number">8</span>, pktIpHdrPtr, length);</span><br></pre></td></tr></table></figure>



<p>正如我们所看到的，tfIcmpErrPacket通过取IP报头长度(以字节为单位)加8(在我们的示例中，60+8=68)和pktuLinkDataLength字段(在本例中修剪为100)之间的最小值来计算要复制的字节数。由于违规数据包的第一个片段的实际链接数据长度为24(不是100)，tfIcmpErrPacket将复制68−24=44字节从堆中泄漏的数据。</p>
<p>此漏洞可用于在启用漏洞缓解(如ASLR)时，以及在没有调试器的情况下，利用CVE2020-11896和其他RCE漏洞进行攻击。</p>
<p>2020-7-2 更新</p>
<p>试了下文章写的 poc 发现并没有任何返回，但是机器直接打崩了。等个可以调试的设备。</p>
<h2 id="关于-treck-协议栈扫描"><a href="#关于-treck-协议栈扫描" class="headerlink" title="关于 treck 协议栈扫描"></a>关于 treck 协议栈扫描</h2><p>看到 启明星辰 ADLAB 的公众号提到了 Treck协议栈自定义了类型为165(0xa5)的ICMP包，并一旦收到165的ICMP包会回复类型为166的ICMP包响应。<a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" alt="img"></a></p>
<p>由于手头没有相应的设备，以及查下公司的打印机相关设备，似乎都没有在官方公告的影响范围内，所以用这个方法跑了下，就到目前写这篇文章为止了，大概跑了1000多个 IP ，没有任何返回，目前猜测，公网 scan 的 话可能会被网关给 drop 掉。</p>
<p>2020-7-2 更新：</p>
<p>昨天发现上海公司有一台设备，测试的时候发现 scapy 写的扫描是有问题的，scapy 本身似乎对包进行了判断，导致拿不到回包，所以 github 上公开的扫描应该是不行，另外一点 ttl 如果太小似乎也会被drop掉(在多层路由的情况下)</p>
<p>这里贴一下我用 socket 写的脚本</p>
<p>设置 ICMP_ECHO_REQUEST 为0xa5 ，然后再收包判断 type</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png"></a></p>
<p>例：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" title="image-20200702113751286" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" alt="image-20200702113751286"></a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf">https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf</a></p>
<p><a href="https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw">https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw</a></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
</div>


  <footer class="post-footer">
  
    <div class="post-tags">
      
        <a href="/tags/CVE-2020-11896/" class="tag">CVE-2020-11896</a>
      
        <a href="/tags/CVE-2020-11898/" class="tag">CVE-2020-11898</a>
      
        <a href="/tags/Treck/" class="tag">Treck</a>
      
    </div>
  
</footer>


  
<nav class="post-nav">
  
    <div class="post-nav-item prev">
      <span class="post-nav-label">&larr; Prev</span>
      <a href="/codeql.html" class="post-nav-title">
        CodeQL 的学习以及尝试漏洞挖掘
      </a>
    </div>
  

  
    <div class="post-nav-item next">
      <span class="post-nav-label">Next &rarr;</span>
      <a href="/CVE-2019-14271-docker-escape.html" class="post-nav-title">
        CVE-2019-14271 docker escape
      </a>
    </div>
  
</nav>



  
</article>

        </div>
      
    </main>

    <footer class="footer">
  <div class="footer-content">
    <div class="footer-left">
      
      <span class="copyright">
        &copy; 2024 - 2026 Swing
      </span>
    </div>

    <div class="footer-right">
      
        <span class="powered">
          Powered by Hexo <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
      
      
        <span class="theme-info">
          Theme <a href="https://github.com/yourname/hexo-theme-Bloom" target="_blank" rel="noopener">Bloom</a>
        </span>
      
    </div>
  </div>

  
    <div class="footer-social">
      
        <a href="https://github.com/WinMin" class="social-link" target="_blank" rel="noopener" aria-label="GitHub">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      
      
        <a href="https://twitter.com/bestswngs" class="social-link" target="_blank" rel="noopener" aria-label="Twitter">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
        </a>
      
      
      
        <a href="mailto:ask@mail.exp.sh" class="social-link" aria-label="Email">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
        </a>
      
      
        <a href="/atom.xml" class="social-link" aria-label="RSS">
          <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M6.18 15.64a2.18 2.18 0 0 1 2.18 2.18C8.36 19 7.38 20 6.18 20C5 20 4 19 4 17.82a2.18 2.18 0 0 1 2.18-2.18M4 4.44A15.56 15.56 0 0 1 19.56 20h-2.83A12.73 12.73 0 0 0 4 7.27V4.44m0 5.66a9.9 9.9 0 0 1 9.9 9.9h-2.83A7.07 7.07 0 0 0 4 12.93V10.1z"/></svg>
        </a>
      
    </div>
  
</footer>

  </div>

  <!-- Main Script -->

<script src="/js/main.js"></script>


<!-- Search -->


<script src="/js/search.js"></script>



<!-- Baidu Analytics -->


</body>
</html>
